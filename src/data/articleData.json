[{"id":8,"title":"新版佳瑞网，上线了！","date":1335293667,"content":"<p>新一版的佳瑞网，终于在公元2012年4月25日正式上线了！此时此刻，我感到非常的激动！<p>从事web前端开发已经有近五年。一路走来，有汗水，有艰辛；有收获，有成果。多年的经历让我改变许多，但对前端开发的热情从来没有改变过！我相信，以后也不会改变！<p>制作佳瑞网的初衷在于，一是对自己的一种检验，看自己到底在前端开发有多大的能力；二是在网络上建筑一个属于自己的空间，记录自己的足迹，记录自己的心情，展示自己的精彩；三是整理记录一些网络上的前端开发资料等等，便于学习交流。<p>在此作特别声明，佳瑞网记录资料里可能有网上转载，引用的文章、图片等，仅作学习交流之用，版权归原作者所有。如果这些资料侵犯了您的权利或利益，请与我联系。我将在第一时间整理删除，谢谢！邮箱：jary[at]jary8.com。([at]=@)<p>佳瑞网还是网络世界的婴儿，我会在不断的更新、修整及改版中呵护她成长！希望她能够顺利的茁壮成长！在此谢谢各位曾经帮助和以后会帮助她的朋友们！希望你们万事如愿！<p>","description":"新一版的佳瑞网，终于在公元2012年4月25日正式上线了！<p>","category":"杂谈","hot":"n"},{"id":30,"title":"前端必备：jQuery 1.7.1API手册","date":1336728689,"content":"<p>本文基于jQuery1.7.1版本，是对官方API的整理和总结，完整的官方API见http://api.jquery.com/browser/<p>0、总述<p>jQuery框架提供了很多方法，但大致上可以分为3大类：获取jQuery对象的方法、在jQuery对象间跳转的方法，以及获取jQuery对象后调用的方法<p>其中第一步是怎样获取jQuery对象。大致来说，是通过最核心的$()方法，将页面上的元素(或者在页面上不存在的html片段)包装成jQuery对象。<p>$()方法里面支持的语法又包括3大类，分别是表达式(包括类表达式.，id表达式#，元素表达式等)、符号(包括后代符号space，next符号+等)、过滤器(包括:过滤器和[]过滤器)。<p>通过以上3种的组合，“查询”得到想要操作的元素或者元素集合，作为$()的参数，得到jQuery对象(或者jQuery对象的集合)<p>第二步是在jQuery对象间的跳转。也就是说，已经得到了一个jQuery对象，但是并不是想要的，那么可以通过一系列的跳转方法，比如parent()、next()、children()、find()等，或者过滤筛选的方法，比如eq()、filter()、not()等，来得到最终想要操作的jQuery对象。<p>用跳转和过滤方式得到的jQuery结果，往往通过比较复杂的表达式组合，可以达到同样的目的。<p>比如说$(\"div\").eq(3)，也可以用$(\"div:eq(3)\")达到同样的目的。<p>又比如说$(\"div\").find(\"span\")，可以用$(\"div span\")取到同样的元素。<p>方法是很灵活的，要根据具体的情况来选择。一般来说，HTML页面写得越规范，使用jQuery就越简单<p>还有一种情况，在得到了jQuery()对象之后，想要判断其是否满足条件，那么可以调用is()、hasClass()等方法，返回一个boolean值，进行后续的判断。这类方法也可以归到这类。<p>第三步是在获取准确的jQuery对象之后，调用其上的各种方法，来进行操作。这一步反而是比较简单的了。<p>后面就是对jQuery框架各种方法的简要介绍，更详细的内容，还是以官方API为准<p>1、$(...)<p>$() 一切的核心，可以跟4种参数<p>$(expression)，比如$(\"#id\")、$(\".class\")等，返回jQuery对象，或者jQuery对象的集合<p>$(html)，比如$(\"&lt;span&gt;hello world&lt;/span&gt;\")，返回jQuery对象，或者jQuery对象的集合<p>$(element)，比如$(document.body)，返回jQuery对象，或者jQuery对象的集合<p>$(*)，所有元素<p>2、jQuery Object Accessors<p>jQuery.index(element)，返回该jQuery对象在集合中的索引<p>jQuery.each(function)，遍历jQuery对象集合，在每个对象上执行function函数，function callback(index, domElement){this};<p>jQuery.size()，返回jQuery对象集合的大小<p>jQuery.length，相当于size()方法<p>jQuery.get()，获取原生DomElement对象的Array<p>jQuery.get(index)，获取原生DomElement对象<p>jQuery.eq(position)，获取jQuery对象集合中的一个jQuery对象<p>3、Data相关方法<p>jQuery.data(name)<p>jQuery.data(name, value)<p>jQuery.removeData(name)<p>4、选择符<p>multiple(selector1, selector2)，可以选择多个元素或者表达式，包装成jQuery对象的集合<p>例子：$(\"div,span\")<p>id(id)<p>例子：$(\"#id\")<p>class(class)<p>例子：$(\".class\")<p>element(element)<p>例子：$(\"div\")<p>all<p>例子：$(\"*\")<p>descendant<p>例子：$(\"table tr td\")<p>child(parent, child)<p>例子：$(\"#id &gt; span\")，和上一个descendant的区别在于，descendant只要是后代就会被选中，而child必须是直接子节点，不包括孙子节点<p>next(prev, next)<p>例子：$(\"label + input\")，选中的是label标签的下一个input标签，返回jQuery对象的集合<p>siblings(prev, siblings)<p>例子：$(\"#prev ~ div\")，选中的是#prev之后的所有div标签，返回jQuery对象的集合，有点像next，但是范围更大<p>Basic Filters<p>$(\":header\")，选中所有header，包括&lt;h1&gt;&lt;h2&gt;等<p>$(\"tr:odd\")，选中所有奇数行<p>$(\"tr:even\")，选中所有偶数行<p>$(\":animated\")，选中所有当前有特效的元素，$(\"div:animated\")，选中当前所有有特效的&lt;div&gt;<p>$(\"tr:first\")，选中第一行<p>$(\"tr:last\")，选中最后一行<p>$(\"input:not(:checked)\")，选中所有没有“checked”的input元素<p>$(\"td:gt(4)\")，选中所有index是4之后的td<p>$(\"td:lt(4)\")，选中所有index是4之前的td<p>$(\"td:eq(4)\")，选中index是4的td，可以用$(\"td\").eq(4)来实现同样的效果<p>Content Filters<p>$(\"div:contains(\'John\')\")，选中所有包含\"John\"字符串的div<p>$(\"td:empty\")，选中所有内容为空的td<p>$(\"div:has(p)\")，选中包含有&lt;p&gt;元素的&lt;div&gt;元素，返回jQuery对象集合<p>$(\"td:parent\")，选中所有包含子节点的元素，包括文本也可以算是子节点<p>Visibility Filters<p>$(\"span:hidden\")，选中所有隐藏的&lt;span&gt;<p>$(\"span:visible\")，选中所有可见的&lt;span&gt;<p>Attribute Filters<p>$(\"div[id]\")，选中包含id属性的&lt;div&gt;元素<p>$(\"input[name$=\'letter\']\")，选中包含某个属性的&lt;input&gt;元素，这个属性名是以\'letter\'结尾的<p>$(\"input[name^=\'letter\']\")，选中包含某个属性的&lt;input&gt;元素，这个属性名是以\'letter\'开头的<p>$(\"input[name*=\'man\']\")，选中包含某个属性的&lt;input&gt;元素，这个属性的属性名里包含\'man\'<p>$(\"input[name=\'newsletter\']\")，选中包含一个属性的&lt;input&gt;元素，这个属性的名字是\'newsletter\'<p>$(\"input[name!=\'newsletter\']\")，选中所有不包含\'newsletter\'属性的&lt;input&gt;元素<p>$(\"input[id][name$=\'man\']\")，选中包含id属性，和以\'man\'结尾属性的&lt;input&gt;元素<p>Child Filters<p>$(\"ul li:nth-child(2)\")，选中自身是&lt;ul&gt;元素的第二个子节点的&lt;li&gt;元素，注意这个计算是从1开始的，不是从0开始<p>$(\"div span:firstChild\")，选中自身是&lt;div&gt;元素的第一个子节点的&lt;span&gt;元素<p>$(\"div span:lastChild\")，选中自身是&lt;div&gt;元素的最后一个子节点的&lt;span&gt;元素<p>$(\"div span:onlyChild\")，选中自身是&lt;div&gt;元素的唯一子节点的&lt;span&gt;元素<p>Forms<p>$(\":button\")，所有&lt;button&gt;元素，和&lt;input type=\"button\"&gt;元素<p>$(\"form :checkbox\")，选中所有&lt;form&gt;标签下的&lt;input type=\"checkbox\"&gt;，不过这样会比较慢，官方建议使用$(\"input:checkbox\")<p>$(\":file\")，选中所有&lt;input type=\"file\"&gt;<p>$(\":hidden\")，选中所有隐藏元素，以及&lt;input type=\"hidden\"&gt;<p>$(\":input\")，选中所有&lt;input&gt;<p>$(\":text\")，选中所有&lt;input type=\"text\"&gt;<p>$(\":password\")，选中所有&lt;input type=\"password\"&gt;<p>$(\":radio\")，选中所有&lt;input type=\"radio\"&gt;，不过这样会比较慢，建议使用$(\"input:radio\")<p>$(\":image\")，选中所有&lt;input type=\"image\"&gt;<p>$(\":reset\")，选中所有&lt;input type=\"reset\"&gt;<p>$(\":submit\")，选中所有&lt;input type=\"submit\"&gt;<p>Form Filters<p>$(\"input:enabled\")，选中所有enabled的&lt;input&gt;元素<p>$(\"input:disabled\")，选中所有disabled的&lt;input&gt;元素<p>$(\"input:checked\")，选中所有checked的&lt;input type=\"checkbox\"&gt;元素<p>$(\"input:selected\")，选中所有selected的&lt;option&gt;元素<p>5、属性相关的方法 <p>jQuery.removeAttr(name)<p>jQuery.attr(name)，返回属性的值，比如$(\"img\").attr(\"src\")<p>jQuery.attr(key,value)，这是设置属性的值<p>jQuery.attr(properties)，也是设置属性的值<p>例子：<p>$(\"img\").attr({    src: \"/images/hat.gif\",    title: \"jQuery\",    alt: \"jQuery Logo\"    });  <p>jQuery.attr(key,function)，也是设置属性的值，这个function计算出的结果，赋给key<p>function callback(index) {    // index == position in the jQuery object    // this means DOM Element    } <p>6、class相关的方法 <p>jQuery.toggleClass(class)，反复切换class属性，该方法第一次执行，增加class，然后去除该class，循环<p>jQuery.toggleClass(class,switch)，增加一个switch表达式<p>jQuery.hasClass(class)，返回boolean<p>jQuery.removeClass(class)，删除class<p>jQueyr.addClass(class)，增加class<p>7、HTML相关的方法 <p>jQuery.html()，返回包含的html文本<p>jQuery.html(val)，用val替换包含的html文本<p>8、文本相关的方法 <p>jQuery.text()，返回包含的纯文本，不会包括html标签，比如&lt;span&gt;abcd&lt;/span&gt;，调用.text()方法，只会返回abcd，不会返回&lt;span&gt;abcd&lt;/span&gt; <p>   jQuery.text(val)，用val替换包含的纯文本，和html(val)方法的区别在于，所有的内容会被看作是纯文本，不会作为html标签进行处理，比如调用.text(\"&lt;span&gt;abcd&lt;/span&gt;\")，&lt;span&gt;和&lt;/span&gt;不会被认为是html标签<p>9、值相关的方法<p>jQuery.val()，返回string或者array<p>jQuery.val(val)，设置string值<p>jQuery.val(array)，设置多个值，以上3个方法，主要都是用在表单标签里，如&lt;input type=\"text\"&gt;，&lt;input type=\"checkbox\"&gt;等<p>10、在jQuery对象集合中进行过滤<p>以下几类方法有点像把选择符Filter进行方法化，比如$(\"label:eq(4)\")，取到第4个&lt;label&gt;元素，这个就可以用$(\"label\").eq(4)来替代，达到同样的效果<p>jQuery.is(expr)，返回boolean，比如$(this).is(\":first-child\")，判断一个元素，是不是其父节点的第一个子节点<p>jQuery.eq(index)，$(\"div\").eq(2)，取出第2个&lt;div&gt;元素<p>jQuery.filter(expr)，比如$(\"div\").filter(\".middle\")，会从div元素中筛选出属于middle的class的元素；再比如$(\"p\").filter(\".selected, :first\")，会取出是selected类，或者是第一个元素的&lt;p&gt;元素，这个可以用$(\"p.class, p:first\")来代替这个方法，会从初始的结果集中，筛选保留一部分<p>jQuery.filter(fn)，类似于上一个函数，可以传进去一个function，用这个function的返回值，进行筛选<p>function callback(index){    // index == position in the jQuery object    // this means DOM Element    return boolean;    } <p>jQuery.not(expr)，是和filter(expr)相反的方法，不是和is(expr)相反的方法。该方法把满足expr的元素给排除掉，比如$(\"div\").not(\".green, #blue\")，把class是green或者id是blue的元素过滤掉<p>jQuery.slice(start, end)，从jQuery对象集合中选出一段<p>jQuery.map(callback)，不知道是干嘛的<p>11、在jQuery对象之间查找 <p>jQuery.parent(expr)，找父亲节点，可以传入expr进行过滤，比如$(\"span\").parent()或者$(\"span\").parent(\".class\")<p>jQuery.parents(expr)，类似于jQuery.parent(expr)，但是是查找所有祖先元素，不限于父元素<p>jQuery.children(expr)，返回所有子节点，和parents()方法不一样的是，这个方法只会返回直接的孩子节点，不会返回所有的子孙节点<p>jQuery.contents()，返回下面的所有内容，包括节点和文本。这个方法和children()的区别就在于，包括空白文本，也会被作为一个jQuery对象返回，children()则只会返回节点<p>jQuery.prev()，返回上一个兄弟节点，不是所有的兄弟节点<p>jQuery.prevAll()，返回所有之前的兄弟节点<p>jQuery.next()，返回下一个兄弟节点，不是所有的兄弟节点<p>jQuery.nextAll()，返回所有之后的兄弟节点<p>jQuery.siblings()，返回兄弟姐妹节点，不分前后<p>jQuery.add(expr)，往既有的jQuery对象集合中增加新的jQuery对象，例子：$(\"div\").add(\"p\")<p>jQuery.find(expr)，跟jQuery.filter(expr)完全不一样。jQuery.filter()是从初始的jQuery对象集合中筛选出一部分，而jQuery.find()的返回结果，不会有初始集合中的内容，比如$(\"p\").find(\"span\")，是从&lt;p&gt;元素开始找&lt;span&gt;，等同于$(\"p span\")<p>12、串联方法 <p>jQuery.andSelf()，把最后一次查询前一次的集合，也增加到最终结果集中，比如$(\"div\").find(\"p\").andSelf()，这样结果集中包括所有的&lt;p&gt;和&lt;div&gt;。如果是$(\"div\").find(\"p\")，那就只有&lt;p&gt;，没有&lt;div&gt;<p>jQuery.end()，把最后一次查询前一次的集合，作为最终结果集，比如$(\"p\").find(\"span\").end()，这样的结果集，是所有的&lt;p&gt;，没有&lt;span&gt;<p>13、DOM文档操作方法 <p>jQuery.append(content)，这个方法用于追加内容，比如$(\"div\").append(\"&lt;span&gt;hello&lt;/span&gt;\");<p>jQuery.appendTo(selector)，这个方法和上一个方法相反，比如$(\"&lt;span&gt;hello&lt;/span&gt;\").appendTo(\"#div\")，这个方法其实还有一个隐藏的move作用，即原来的元素被移动了<p>jQuery.prepend(content)，跟append()方法相对应，在前面插入<p>jQuery.prependTo(selector)，跟上一个方法相反<p>jQuery.after(content)，在外部插入，插入到后面，比如$(\"#foo\").after(\"&lt;span&gt;hello&lt;/span&gt;\");<p>jQuery.insertAfter(selector)，和上一个方法相反，比如$(\"&lt;span&gt;hello&lt;/span&gt;\").insertAfter(\"#foo\");<p>jQuery.before(content)，在外部插入，插入到前面<p>jQuery.insertBefore(selector)，跟上一个方法相反<p>jQuery.wrapInner(html)，在内部插入标签，比如$(\"p\").wrapInner(\"&lt;span&gt;&lt;/span&gt;\");<p>jQuery.wrap(html)，在外部插入标签，比如$(\"p\").wrap(\"&lt;div&gt;&lt;/div&gt;\")，这样的话，所有的&lt;p&gt;都会被各自的&lt;div&gt;包裹<p>jQuery.wrapAll(html)，类似上一个，区别在于，所有的&lt;p&gt;会被同一个&lt;div&gt;包裹<p>jQuery.replaceWith(content)，比如$(this).replaceWith(\"&lt;div&gt;\"+$(this).text()+\"&lt;/div&gt;\");<p>jQuery.replaceAll(selector)，比如$(\"&lt;div&gt;hello&lt;/div&gt;\").replaceAll(\"p\");<p>jQuery.empty()，比如$(\"p\").empty()，这样的话，会把&lt;p&gt;下面的所有子节点清空<p>jQuery.remove(expr)，比如$(\"p\").remove()，这样的话，会把所有&lt;p&gt;移除，可以用表达式做参数，进行过滤<p>jQuery.clone()，复制一个页面元素<p>14、CSS相关方法 <p>jQuery.css(name)，获取一个css属性的值，比如$(\"p\").css(\"color\")<p>jQuery.css(object)，设置css属性的值，比如$(\"p\").css({\"color\":\"red\",\"border\":\"1px red solid\"});<p>jQuery.css(name,value)，设置css属性的值，比如$(\"p\").css(\"color\",\"red\");<p>15、位置计算相关方法 <p>jQuery.scrollLeft()，设置滚动条偏移，这个方法对可见元素或不可见元素都生效<p>jQuery.scrollTop()，设置滚动条偏移，这个方法对可见元素或不可见元素都生效<p>jQuery.offset()，计算偏移量，返回值有2个属性，分别是top和left<p>jQuery.position()，计算位置，返回值也有2个属性，top和left<p>16、宽度和高度计算相关方法 <p>这组方法需要结合CSS的盒子模型来理解，margin始终不参与计算<p>jQuery.height()，这个方法计算的是content<p>jQuery.innerHeight()，这个方法计算的是content+padding<p>jQuery.outerHeight()，这个方法计算的是content+padding+border<p>jQuery.width();<p>jQuery.innerWidth();<p>jQuery.outerWidth();<p>17、页面加载完成事件 <p>$(document).ready(function(){})，可以简写为$(function(){})<p>18、事件绑定方法 <p>jQuery.bind(type,data,fn)<p>bind()方法可以接受3个参数，第1个是事件类型，类型是string，可能的值有blur, focus, load, resize, scroll, unload, beforeunload, click, dblclick, mousedown, mouseup, mousemove, mouseover, mouseout, mouseenter, mouseleave, change, select,<p>submit, keydown, keypress, keyup, error<p>第3个参数是当事件发生时，要执行的函数，函数原型是<p>function callback(eventObject) {    this; // dom element    }  <p>在这个方法里return false会阻止事件冒泡并中止默认行为，如果在这个方法里调用eventObject.preventDefault()则会中止默认行为，如果在这个方法里调用eventObject.stopPropagation()则只会阻止事件冒泡<p>第2个参数是可选的，会赋值给e.data，比如<p>function handler(event) {    alert(event.data.foo);    }    $(\"p\").bind(\"click\", {foo: \"bar\"}, handler)<p>jQuery.one(type,data,fn)，这个方法类似于bind()方法，区别在于只会绑定一次<p>jQuery.unbind(type,fn)，解除绑定<p>jQuery.trigger(event,data)，触发事件，要注意这个方法，同样会引起浏览器的默认行为，比如submit<p>另外，这个方法如果和bind()方法里定义的handler配合使用，可以更加灵活地传递参数，比如<p>$(\"#test\").bind(\"click\", {name : \"kyfxbl\"}, function(e, foo) {    alert(e.data.name);    alert(\"foo: \" + foo);    });<p>以上代码，如果直接点击#test，则foo的值是undefined<p>但是如果通过$(\"#test\").trigger(\"click\",[\"foo\"])来触发，则参数foo会被赋值为\"foo\"<p>jQuery.triggerHandler(event,data)，这个方法和trigger()方法十分相像，主要有2点不同，1是这个方法不会触发浏览器的默认行为，2是它只会在jQuery对象集合的第一个元素上触发<p>jQuery.live(type,fn)，这个方法十分类似jQuery.bind()方法，区别在于这个方法对后来才添加进来的元素同样有效<p>jQuery.die(type,fn)，这个是jQuery.live()的相反方法<p>19、事件快捷方法 <p>jQuery.hover(over,out)，这个方法是mouseenter和mouseleave的便捷方法，2个参数的函数原型是：<p>function callback(eventObject) {    this; // dom element    }   <p>jQuery.toggle(fn,fn2,fn3,...)，这个方法是多次点击的便捷方法，参数的函数原型是：<p>function callback(eventObject) {    this; // dom element    }  <p>jQuery提供了两类便捷方法：<p>第一类是类似于click()这种，相当于简化的jQuery.trigger()方法，比如$(\"p\").click()相当于$(\"p\").trigger(\"click\")，不过该方法，无法像完整的jQuery.trigger(\"click\", data)方法一样，传递一个附带的参数<p>第二类是类似于click(function)这种，相当于简化的jQuery.bind()方法，比如$(\"p\").click(function)相当于$(\"p\").bind(\"click\",function)，不过该方法，无法像完整的jQuery.bind(\"click\", data, func)一样，传递一个额外的参数<p>20、切换元素显示与否的方法 <p>jQuery.toggle()，原本显示的元素会不显示，原本不显示的会显示出来。这些元素可以是通过show()和hide()切换的，也可以是通过display:none来设置的<p>jQuery.show()，显示元素<p>jQuery.hide()，隐藏元素<p>jQuery.show(speed, callback)，类似于上面的jQuery.show()，不过可以设置速度以及回调函数<p>speed可以是\"slow\"、\"normal\"、\"fast\"，也可以是毫秒数<p>callback函数的原型是：<p>function callback() {    this; // dom element    } <p>jQuery.hide(speed, callback)<p>   jQuery.toggle(speed, callback)<p>21、页面一些特效方法 <p>jQuery.slideDown(speed, callback)，让一个元素下滑，从无到有<p>jQuery.slideUp(speed, callback)，让一个元素上升，从有到无<p>jQuery.slideToggle(speed, callback)，切换一个下滑和上升<p>jQuery.fadeIn(speed, callback)，淡入效果<p>jQuery.fadeOut(speed, callback)，淡出效果<p>jQuery.fadeTo(speed, opacity, callback)，变淡效果<p>22、ajax相关方法 <p>$.ajax(options)，这个是底层方法，上层的$.get()和$.post()都是基于此方法的封装<p>options:<p>async：是否异步，默认为true<p>url：目标地址<p>type：请求类型，可以是\"POST\"或者\"GET\"<p>data：请求参数，比如\"name=kyfxbl&amp;location=shenzhen\"<p>complete(function)：请求结束后的回调函数，函数原型是<p>function (XMLHttpRequest, textStatus) {    this; // the options for this ajax request    } <p>success(function)：请求成功后的回调函数，函数原型是<p>function (data, textStatus) {    // data could be xmlDoc, jsonObj, html, text, etc...    this; // the options for this ajax request    } <p>例子：<p>$.ajax({    url : \"user/ajax\",    type : \"GET\",    data : \"name=kyfxbl&amp;location=shenzhen\",    success : function(data, textStatus) {    alert(data);    alert(this.success);    }    });<p>$.get(url, data, callback, type)，$.ajax()的简易方法，用于发送GET请求<p>url：请求地址<p>data：发送到服务端的请求参数<p>callback：请求成功后的回调函数，函数原型是：<p>function (data, textStatus) {    // data could be xmlDoc, jsonObj, html, text, etc...    this; // the options for this ajax request    }<p>$.post(url, data, callback, type)，$.ajax()的简易方法，跟$.get()差不多，用于发送POST请求<p>23、浏览器及特性检测 <p>$.support，可以检测当前浏览器是否支持下列属性，返回boolean。包括boxModel、cssFloat、opacity、tbody等 <p>   $.browser，检测当前浏览器类型，返回一个map，其中可能的值有safari、opera、msie、mozilla<p>24、数据缓存方法 <p>该类方法是jQuery.data()方法和jQuery.removeData()的另一种形式，增加的elem参数是DOM Element<p>$.data(elem, name)，取出elem上name的值<p>$.data(elem, name, value)，设置elem上name的值为value<p>$.removeData(elem, name)，删除elem上的name<p>$.removeData(elem)，删除elem上的所有缓存数据<p>25、工具方法 <p>$.isArray(obj)，检测一个对象是否是数组<p>$.isFunction(obj)，检测一个对象是否是函数<p>$.trim(str)，去除string的空格<p>$.inArray(value, array)，返回value在array中的下标，如果没有找到则返回-1，比如$.inArray(123, [\"john\",1,123,\"f\"])将会返回2<p>$.unique(array)，去除array中的重复元素，该方法只对DOM Element有效，对string和number无效<p>本文章来源于：jQuery1.7.1 API手册<p>","description":"jQuery框架提供了很多方法，但大致上可以分为3大类：获取jQuery对象的方法、在jQuery对象间跳转的方法，以及获取jQuery对象后调用的方法.本文基于jQuery1.7.1版本，是对官方API的整理和总结。","category":"JavaScript","hot":"n"},{"id":22,"title":"W3C 发布 CSS Variables 首个公开草案","date":1336534465,"content":"<p>W3C（World Wide Web Consortium，万维网联盟）的CSS工作组近日发布了CSS Variables（CSS 变量）的首个公开工作草案。<p>如果在样式表中经常使用某个值（比如某个颜色或页面背景颜色的值），可以将其定义为变量，只需更改该变量的值，即可更新整个样式表，而无需逐个更改每个样式规则。自从1998年CSS Level 2 Recommendation发布以来，Web开发者社区就建议制定CSS定义变量的标准方式。<p><img src=\"/content/uploadfile/201205/thum-6d2f6acbb5a1ab37c9cb2e7cc52266a220120509033842.png\" alt=\"点击查看原图\" border=\"0\" /><p>本草案包含了CSS变量定义的一般约定，并引入了一系列用户自定义的、已知的公共属性作为变量属性，这允许开发者从中选择属性名称，并分配值。<p>这使得阅读大型CSS文件更加容易，因为看似随意的值现在有了确切的名称（含义），编辑这些文件也更加容易且不易出错，只需改变一个值，就可以应用到整个站点。<p>W3C表示，该规范目前还处于起步阶段，刚刚开始实施，并欢迎开发者提交关于功能和语法上的反馈。<p>CSS Variables草案：http://www.w3.org/TR/css-variables/<p>本文章来源于：W3C 发布 CSS Variables 首个公开草案<p>","description":"W3C（World Wide Web Consortium，万维网联盟）的CSS工作组近日发布了CSS Variables（CSS 变量）的首个公开工作草案。如果在样式表中经常使用某个值（比如某个颜色或页面背景颜色的值），可以将其定义为变量，只需更改该变量的值，即可更新整个样式表，而无需逐个更改每个样式规则。","category":"杂谈","hot":"n"},{"id":17,"title":"使用jquery插件实现图片延迟加载技术","date":1336101327,"content":"<p>有时我们看到一些大型网站，页面如果有很多图片的时候，当你滚动到相应的行时，当前行的图片才即时加载的，这样子的话页面在打开只加可视区域的图片，而其它隐藏的图片则不加载，一定程序上加快了页面加载的速度，对于比较长的页面来说，这个方案是比较好的。<p>这里推荐使用jquery图片延迟加载插件jquery.lazyload实现图片延迟加载提高网站打开速度。<p>下载地址：http://www.appelsiini.net/download/jquery.lazyload.js<p>修正版：jquery.lazyload修正版.rar（修正版说明）<p>一、快速使用篇<p>   1.导入JS插件<p>&lt;script src=\"js\\jquery.js\" type=\"text/javascript\"&gt;&lt;/script&gt; &lt;script src=\"js\\jquery.lazyload.js\" type=\"text/javascript\"&gt;&lt;/script&gt;<p>2.在你的页面中加入如下的javascript：<p>&lt;script type=\"text/javascript\"&gt;     $(\"img\").lazyload(); &lt;/script&gt;<p>这将会使所有的图片都延迟加载；<p>二、高级篇详细介绍（不想了解那么多的可以直接绕过）<p>Lazy Load 是一个用 JavaScript 编写的 jQuery 插件。它可以延迟加载长页面中的图片。在浏览器可视区域外的图片不会被载入，直到用户将页面滚动到它们所在的位置。这与图片预加载的处理方式正好是相反的。<p>在包含很多大图片长页面中延迟加载图片可以加快页面加载速度。浏览器将会在加载可见图片之后即进入就绪状态，在某些情况下还可以帮助降低服务器负担。<p>Lazy Load 灵感来自 Matt Mlinac 制作的 YUI ImageLoader 工具箱。<p>怎样使用?<p>Lazy Load 依赖于 jQuery。请将下列代码加入页面 head 区域：<p>&lt;script src=\"jquery.js\" type=\"text/javascript\"&gt;&lt;/script&gt; &lt;script src=\"jquery.lazyload.js\" type=\"text/javascript\"&gt;&lt;/script&gt;<p>并且在你的执行代码中加入下面语句：<p>$(\"#xd\").lazyload();<p>这将使id=”xd” 区域下的图片将被延迟加载。<p>设置敏感度<p>插件提供了 threshold 选项，可以通过设置临界值 (触发加载处到图片的距离) 来控制图片的加载。默认值为 0（到达图片边界的时候加载）。<p>$(\"#xd\").lazyload({ threshold : 200 });<p>将临界值定为 200，当可视区域离图片还有 200 个象素的时候开始加载图片。（这一句原文的字面意思和本人理解不一致，原文：Setting threshold to 200 causes image to load 200 pixels before it is visible.）<p>参数：threshold，值为数字，代表页面高度。如设置为200，表示滚动条在离目标位置还有200的高度时就开始加载图片，可以做到不让用户察觉。<p>占位图片<p>你还可以设定一个占位图片并定义事件来触发加载动作。这时需要为占位图片设定一个 URL 地址。透明，灰色和白色的 1×1 象素的图片已经包含在插件里面。<p>$(\"img\").lazyload({ placeholder : \"img/grey.gif\" });<p>参数：placeholder，值为某一图片路径。此图片用来占据将要加载的图片的位置，待图片加载时，占位图则会隐藏。<p>事件触发加载<p>事件可以是任何 jQuery 时间，如：click 和 mouseover。你还可以使用自定义的事件，如：sporty和foobar。默认情况下处于等待状态，直到用户滚动到窗口上图片所在位置。在灰色占位图片被点击之前阻止加载图片，你可以这样做：<p>$(\"img\").lazyload({     placeholder: \"img/grey.gif\",     event: \"click\" });<p>参数：event，值有click（点击），mouseover（鼠标划过），sporty（运动的），foobar（…），可以实现鼠标莫过或点击图片才开始加载，后两个值未测试……<p>使用特效<p>当图片完全加载的时候，插件默认地使用 show() 方法来将图显示出来。其实你可以使用任何你想用的特效来处理。下面的代码使用 FadeIn 效果。<p>$(\"img\").lazyload({     placeholder: \"img/grey.gif\",     effect : \"fadeIn\" });<p>参数：effect（特效），值有show（直接显示），fadeIn（淡入），slideDown（下拉）等，常用fadeIn。<p>图片在容器里面<p>你可以将插件用在可滚动容器的图片上，例如带滚动条的 DIV 元素。你要做的只是将容器定义为 jQuery 对象并作为参数传到初始化方法里面。这是水平滚动演示页面和垂直滚动的演示页面。<p>CSS 代码：<p>#container { height: 600px;overflow: scroll; }<p>JavaScript 代码：<p>$(\"img\").lazyload({     placeholder: \"img/grey.gif\",     container: $(\"#container\") });<p>参数：container，值为某容器。lazyload默认在拉动浏览器滚动条时生效，这个参数可以让你在拉动某DIV的滚动条时依次加载其中的图片。<p>当图片不顺序排列<p>滚动页面的时候，Lazy Load 会循环为加载的图片。在循环中检测图片是否在可视区域内。默认情况下在找到第一张不在可见区域的图片时停止循环。图片被认为是流式分布的，图片在页面中的次序和 HTML 代码中次序相同。但是在一些布局中，这样的假设是不成立的。不过你可以通过 failurelimit 选项来控制加载行为。<p>$(\"img\").lazyload({     failurelimit: 10 });<p>将failurelimit设为10，令插件找到10 个不在可见区域的图片是才停止搜索。如果你有一个猥琐的布局，请把这个参数设高一点.<p>参数：failurelimit，值为数字。lazyload默认在找到第一张不在可见区域里的图片时则不再继续加载，但当HTML容器混乱的时候可能出现可见区域内图片并没加载出来的情况，failurelimit意在加载N张可见区域外的图片，以避免出现这个问题。<p>多参数同时设置方法<p>&lt;script type=\"text/javascript\"&gt;         $(\"img\").lazyload({ placeholder: \"images/white.gif\", threshold: 200, effect: \"fadeIn\" }); &lt;/script&gt; <p>延迟加载图片<p>Lazy Load 插件的一个不完整的功能，但是这也能用来实现图片的延迟加载。下面的代码实现了页面加载完成后再加载。页面加载完成 5 秒后，指定区域内的图片会自动进行加载。这是延迟加载演示页面。<p>$(function() {     $(\"img:below-the-fold\").lazyload({         placeholder: \"img/grey.gif\",         event: \"sporty\"     }); }); $(window).bind(\"load\", function() {     var timeout = setTimeout(function() { $(\"img\").trigger(\"sporty\") }, 5000); });<p>","description":"有时我们看到一些大型网站，页面如果有很多图片的时候，当你滚动到相应的行时，当前行的图片才即时加载的，这样子的话页面在打开只加可视区域的图片，而其它隐藏的图片则不加载，一定程序上加快了页面加载的速度，对于比较长的页面来说，这个方案是比较好的。","category":"JavaScript","hot":"n"},{"id":29,"title":"什么是响应式Web设计？怎样进行？","date":1336636731,"content":"<p>在Web设计和开发领域，很快的，我们将会无法跟上设备与分辨率革新的步伐。对于多数网站来说，为每种新设备及分辨率创建其独立的版本根本就是不切实际的；结果就是，我们将会赢得使用某些设备的用户群，而失去那些使用其他设备的用户。不过，或许会有另外一种方式，可以帮助我们避免这种情况的发生。<p>响应式Web设计(Responsive Web design)的理念是，页面的设计与开发应当根据用户行为以及设备环境（系统平台、屏幕尺寸、屏幕定向等）进行相应的响应和调整。具体的实践方式由多方面组成，包括弹性网格和布局、图片、CSS media query的使用等。无论用户正在使用笔记本还是iPad，我们的页面都应该能够自动切换分辨率、图片尺寸及相关脚本功能等，以适应不同设备；换句话说，页面应该有能力去自动响应用户的设备环境。这样，我们就可以不必为不断到来的新设备做专门的版本设计和开发了。<p>响应式Web设计的概念<p>Ethan Marcotte曾经在A List Apart发表过一篇文章\"Responsive Web Design\"，文中援引了响应式建筑设计的概念：<p>最近出现了一门新兴的学科——\"响应式建筑(responsive architecture)\"——提出，物理空间应该可以根据存在于其中的人的情况进行响应。结合嵌入式机器人技术以及可拉伸材料的应用，建筑师们正在尝试建造一种可以根据周围人群的情况进行弯曲、伸缩和扩展的墙体结构；还可以使用运动传感器配合气候控制系统，调整室内的温度及环境光。已经有公司在生产\"智能玻璃\"：当室内人数达到一定的阀值时，这种玻璃可以自动变为不透明，确保隐私。<p>将这个思路延伸到Web设计的领域，我们就得到了一个全新的概念。为什么一定要为每个用户群各自打造一套设计和开发方案?和响应式建筑相似，Web设计同样应该做到根据不同设备环境自动响应及调整。<p>显然，我们无法也无需使用运动传感器或是机器人技术，响应式Web设计更多需要的是抽象思维。好在，一些相关的概念已经得到了实践，比如液态布局、帮助页面重新格式化的media queries和脚本等。但是响应式Web设计不仅仅是关于屏幕分辨率自适应以及自动缩放的图片等等，它更像是一种对于设计的全新思维模式。<p>调整分辨率<p>不同的设备都有各自的屏幕分辨率、清晰度以及屏幕定向方式，不断被研发着的各种新设备也将带来新的屏幕尺寸规格。有些设备基于横屏(portrait)，有些是竖屏(landscape)，甚至还有正方形；对于日益流行的iPhone、iPad及其他一些智能手机、平板电脑，用户还可以通过转动设备来任意切换屏幕的定向方式。怎样才能做到让一种设计方案满足所有情况？<p><img src=\"/content/uploadfile/201205/thum-f3ccdd27d2000e3f9255a7e3e2c4880020120510083351.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>要想做到同时兼容横、竖屏（用户还有可能在页面加载的过程中切换方向），我们就必须考虑N种屏幕尺寸规格。诚然，我们可以将这些规格划分为几个大类，然后为每一类做一种方案，确保该方案至少在本组中尽量具有弹性。但即使这样，结果也将是无比焦虑的，谁知道某类设备在5年之后的占有率是多少?而且很多用户甚至不去将浏览器的窗口最大化；类似这样的变数，我们还要考虑多少呢？<p>Morten Hjerde和他的同事们对2005至2008年市场中的400余种移动设备进行了统计，下图展示了大致的统计结果：<p><img src=\"/content/uploadfile/201205/thum-156005c5baf40ff51a327f1c34f2975b20120510083352.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>在08年之后，更多更有代表性的新设备问世并普及了。显然，我们不可以沿着\"多方案\"的思路继续走下去；那么我们应该怎样做呢？<p>部分解决方案：一切弹性化<p>几年前，弹性布局(flexible layout)几乎是一种奢侈品，所谓弹性，也只是体现在竖排布局以及字号等方面；图片始终可以轻易的破坏页面结构，而且即使是哪些弹性的元素结构，在很极端的情况下，仍会破坏布局。所以，所谓的弹性布局其实并非那样弹性，它有时甚至不能适应台式机与笔记本的屏幕分辨率差异，更不用说手机等移动设备了。<p>现在，我们可以通过响应式的设计和开发思路让页面更加\"弹性\"了。图片的尺寸可以被自动调整，页面布局再不会被破坏。虽然永远没有最完美的解决方案，但它给了我们更多选择。无论用户切换设备的屏幕定向方式，还是从台式机屏幕转到iPad上浏览，页面都会真正的富有弹性。<p>在前文提到的Ethan Marcotte的文章中，他通过一个实例展示了响应式Web设计在页面弹性方面的特性：<p><img src=\"/content/uploadfile/201205/thum-799bad5a3b514f096e69bbc4a7896cd920120510083352.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>该实例的实现方式完美的结合了液态网格和液态图片技术，并且聪明的在正确的地方使用了正确的HTML标记。\"液态网格\"是一种很常见的实践方式；对于\"液态图片\"技术，下面的文章做了不错的介绍：<p>Hiding and Revealing Portions of Images<p>Creating Sliding Composite Images<p>Foreground Images That Scale With the Layout<p>说到创建液态页面，最好看看Zoe Mickley Gillenwater的那本《Flexible Web Design: Creating Liquid and Elastic Layouts with CSS》，或是下载个样章先：\"怎样创建弹性图片\"。另外，Zoe的这篇\"Essential Resources for Creating Liquid and Elastic Layouts.\"提供了不少关于创建弹性网格和布局的教程、资源、创意指导和最佳实践方式。<p>从技术角度讲，虽然听上去这些都简单可行，但它比\"将这些功能结合在一起\"要复杂些。举个例子，仔细观察Ethan Marcotte提供的实例中的logo图片：<p><img src=\"/content/uploadfile/201205/thum-d0096ec6c83575373e3a21d129ff8fef20120510083352.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>如果我们将浏览器窗口不断调小，会发现logo图片的文字部分始终会保持同比缩小，保证其完整可读，而不会和周围的插图一样被两边裁掉。所以整个logo其实包括两部分：插图作为页面标题的背景图片，会保持尺寸，但会随着布局调整而被裁切；文字部分则是一张单独的图片。<p>&lt;h1 id=\"logo\"&gt;  &lt;a href=\"#\"&gt;&lt;img src=\"site/logo.png\" alt=\"The Baker Street Inquirer\" /&gt;&lt;/a&gt;  &lt;/h1&gt;<p>其中，&lt;h1&gt;元素使用插图作为背景，文字部分的图片始终保持与背景的对齐。<p>这个实例小小的展示一下响应式Web设计的思路。不过这点小努力还不足以避免整个布局在小尺寸窗口中变的过窄或过短，并且logo文字最终会变的小到难以识别，背景图片也会被过多的裁切。<p>弹性图片<p>响应式Web设计的思路中，一个重要的因素是怎样处理图片方面的问题。有很多同比缩放图片的技术，其中有不少是简单易行的。其中，由Richard Rutter最先尝试的一种做法比较流行，即使用CSS的max-width属性。这个方法在Ethan Marcotte的液态图片一文中也有提到。<p>img { max-width: 100%;}<p>只要没有其他涉及到图片宽度的样式代码覆盖掉这一行规则，页面上所有的图片就会以其原始宽度进行加载，除非其容器可视部分的宽度小于图片的原始宽度。上面的代码确保图片最大的宽度不会超过浏览器窗口或是其容器可视部分的宽度，所以当窗口或容器的可视部分开始变窄时，图片的最大宽度值也会相应的减小，图片本身永远不会容器边缘隐藏和覆盖。实际上，就像Jason Grigsby在他的CSS Media Query for Mobile is Fool\'s Gold一文中提到的，\"液态图片背后的思路，就是无论何时，都确保在其原始宽度范围内，以最大的宽度同比完整的显示图片。我们不必在样式表中为图片设置宽度和高度，只需要让样式表在窗口尺寸发生变化时辅助浏览器对图片进行缩放。\" 一种简而美的方法。<p>图片本身的分辨率及加载时间是另外一个需要考虑的问题。虽然通过上面的方法，可以很轻松的缩放图片，确保在移动设备的窗口中可以被完整浏览，但如果原始图片本身过大，便会显著降低图片文件的下载速度，对存储空间也会造成没有必要的消耗。<p>响应式图片<p>由Filament Group提出的\"响应式图片\"技术思想，有助于解决上面提到的问题：不仅要同比的缩放图片，还要在小设备上降低图片自身的分辨率。可以看下demo页面先。<p><img src=\"/content/uploadfile/201205/thum-032b2cc936860b03048302d991c3498f20120510083353.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>这个技术的实现需要使用几个相关文件，我们可以在Github上获取。包括一个JavaScript文件(rwd-images.js)，一个.htaccess文件，以及一些范例资源文件。具体使用方法可以参考Responsive Images的说明文档。大致的原理是，rwd-images.js会检测当前设备的屏幕分辨率，如果是大屏幕设备，则向页面head部分中添加BASE标记，并将后续的图片、脚本和样式表加载请求定向到一个虚拟路径\"/rwd-router\"。当这些请求到达服务器端，.htacces文件会决定这些请求所需要的是原始图片还是小尺寸的\"响应式图片\"，并进行相应的反馈输出。对于小屏幕的移动设备，原始尺寸的大图片永远不会被用到。<p>这项技术支持多数的现代浏览器，包括IE8+、Safari、Chrome和Opera，以及这些浏览器的移动设备版本；在FireFox及一些旧浏览器中，则会优雅降级：我们仍可得到小图片的输出，但同时，原始大图也会被下载。<p>禁用iPhone中的图片自动缩放<p>在iPhone及iPod Touch中，页面会被自动的同比例缩小至最适合屏幕大小的尺寸，x轴不会产生滚动条，用户可以上下拖拽浏览全部页面，或在需要的时候放大页面的局部。这里会产生一个问题，即使我们运用响应式Web设计的思想，专门为iPhone的小屏输出小图片，它同样会随着整个页面一起被同比例缩小，如下图左侧所示。<p><img src=\"/content/uploadfile/201205/thum-18e2999891374a475d0687ca9f989d8320120510083353.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>我们可以使用苹果专有的一些meta标记来解决类似的问题。在页面的部分添加以下代码（详情可以参考Think Vitamin的相关文章）：<p>&lt;meta name=\"viewport\" content=\"width=device-width; initial-scale=1.0\"&gt;<p>将initial-scale的值设定为\"1\"，即可覆写默认的缩放方式，保持原始的尺寸及比例。更多关于viewport meta标记的用法，可以参考苹果官方的文档。<p>打造布局结构<p>当页面所需要适应的不同设备的屏幕尺寸差异过大时，除了图片方面，我们也应该考虑到整个布局结构的响应式调整；我们可以使用独立的样式表，或者更有效的，使用CSS media query。这不会引起多大的麻烦，多数样式设定不会被影响和改变，只有一些特定的元素会通过浮动、宽度和高度等的设置来改变位置。<p>我们可以使用一个默认主样式表来定义页面的主要结构元素，比如#wrapper、#content、#sidebar、#nav等的默认布局方式，以及一些全局性的配色和字体方案。<p>我们可以监测页面布局随着不同的浏览环境而产生的变化，如果它们变的过窄过短或是过宽过长，则通过一个子级样式表来继承主样式表的设定，并专门针对某些布局结构进行样式覆写。我们来看下代码示例：<p>下面的代码可以放在默认主样式表style.css中：<p>/* Default styles that will carry to the child style sheet */   html,body{   background...   font...   color...   }   h1,h2,h3{}   p, blockquote, pre, code, ol, ul{}   /* Structural elements */   #wrapper{   width: 80%;   margin: 0 auto;   background: #fff;   padding: 20px;   }   #content{   width: 54%;   float: left;   margin-right: 3%;   }   #sidebar-left{   width: 20%;   float: left;   margin-right: 3%;   } #sidebar-right{   width: 20%;   float: left;   } <p>下面的代码可以放在子级样式表mobile.css中，专门针对移动设备进行样式覆写：<p>#wrapper{   width: 90%;   }   #content{   width: 100%;   }   #sidebar-left{   width: 100%;   clear: both;   /* Additional styling for our new layout */   border-top: 1px solid #ccc;   margin-top: 20px;   }   #sidebar-right{   width: 100%;   clear: both;   /* Additional styling for our new layout */   border-top: 1px solid #ccc;   margin-top: 20px;   } <p>大致的视觉效果如下图所示：<p><img src=\"/content/uploadfile/201205/thum-fe5df232cafa4c4e0f1a0294418e566020120510083354.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>Media Queries<p>CSS3支持CSS2.1所支持的所有媒体类型，例如screen、print、handheld等，同时添加了很多涉及媒体类型的功能属性，包括max-width（最大宽度）、device-width（设备宽度）、orientation（屏幕定向，横屏或竖屏）和color。在CSS3发布之后出现的新玩具，如iPad或Android相关设备，都可以完美的支持这些属性。所以我们可以通过media query为新设备设置独特的样式，而忽略那些不支持CSS3的台式机中的旧浏览器。<p>在Ethan的文章中，我们能看到一段media query使用实例：<p>&lt;link rel=\"stylesheet\" type=\"text/css\" media=\"screen and (max-device-width: 480px)\" href=\"shetland.css\" /&gt; <p><p>代码本身可以很好的说明工作机制：如果页面通过屏幕呈现（非打印一类），并且屏幕宽度不超过480px，则加载shetland.css样式表。要了解更多关于CSS3媒体新属性的信息，可以参考\"The Orientation Media Query\"一文。<p>我们可以创建多个样式表，以适应不同设备类型的宽度范围。Ethan的文章中的\"Meet the media query\"部分有更多的范例及解释。更有效率的做法是，将多个media queries整合在一个样式表文件中：<p>/* Smartphones (portrait and landscape) ----------- */   @media only screen   and (min-device-width : 320px)   and (max-device-width : 480px) {   /* Styles */   }   /* Smartphones (landscape) ----------- */   @media only screen   and (min-width : 321px) {   /* Styles */   }   /* Smartphones (portrait) ----------- */   @media only screen   and (max-width : 320px) {   /* Styles */   } <p>上面的代码来自于Andy Clark创建的可以兼容各种主流设备的免费模板。这样整合多个media queries于一个样式表文件的方式，与通过media queries调用不同样式表的方式之间的区别与联系，可以参考\"Hardboiled CSS3 Media Queries\"一文。<p>CSS3 Media Queries<p>上面演示的一些代码范例是CSS2.1与CSS3通吃的。现在让我们来看看怎样使用CSS3专有的media queries功能来创建响应式Web设计。其中某些方法在当前就有切实的使用价值，不久的将来则一定会全部派上用场。<p>min-width和max-width这两个属性很靠谱。通过min-width的设置，我们可以在浏览器窗口或设备屏幕宽度高于这个值的情况下，为页面指定一个特定的样式表；max-width则反之。<p>下面的几个示例中，我们使用的是将多个media queries整合在单一样式表中进行编码的句法。如前文所述，这样做更加高效，减少请求数量。<p>@media screen and (min-width: 600px) {   .hereIsMyClass {   width: 30%;   float: right;   }   } <p>上面代码中定义的类(hereIsMyClass)只有在浏览器或屏幕宽度超过600px时才会有效。<p>@media screen and (max-width: 600px) {   .aClassforSmallScreens {   clear: both;   font-size: 1.3em;   }   } <p>而这段代码的作用则相反：aClassforSmallScreens类只有在浏览器或屏幕宽度小于600px时才会有效。<p>可以看出min-width和max-width可以同时判断设备屏幕尺寸与浏览器实际宽度。有些时候，我们希望通过media queries作用于某种特定的设备，而忽略其上运行的浏览器是否由于没有最大化而在尺寸上与设备屏幕尺寸产生不一致的情况。这时，我们需要使用min-device-width与max-device-width，用来判断设备本身的屏幕尺寸。<p>@media screen and (max-device-width: 480px) {   .classForiPhoneDisplay {   font-size: 1.2em;   }   } <p>@media screen and (min-device-width: 768px) {   .minimumiPadWidth {   clear: both;   margin-bottom: 2px solid #ccc;   }   } <p>还有一些其他方法，可以帮我们有效的使用media queries锁定某些指定的设备。可以参考下面两篇出自Thomas Maier的文章：<p>CSS for iPhone 4 (Retina display)<p>How To: CSS for the iPad<p>对于iPad来说，orientation属性尤其有用。它的值可以是landscape（横屏）或portrait（竖屏）。<p>@media screen and (orientation: landscape) {   .iPadLandscape {   width: 30%;   float: right;   }   } <p>@media screen and (orientation: portrait) {   .iPadPortrait {   clear: both;   }   } <p>不幸的是，这个属性目前确实只在iPad上有效。对于其他可以转屏的设备，譬如iPhone，可以使用min-device-width和max-device-width来变通实现；详情可以参考\"Determine iPhone orientation using CSS\"一文。<p>我们还可以将上述属性组合使用，来锁定某个屏幕尺寸范围：<p>@media screen and (min-width: 800px) and (max-width: 1200px) {   .classForaMediumScreen {   background: #cc0000;   width: 30%;   float: right;   }   } <p>上面的代码可以作用于浏览器窗口或屏幕宽度在800px至1200px之间的所有设备。<p>其实，很多设计师和开发者仍会选择使用多个样式表的方式来实现media queries。如果从资源的组织和维护的角度出发，其益处确实高于效率的损耗的话，那么这样做也完全不坏：<p>&lt;link rel=\"stylesheet\" media=\"screen and (max-width: 600px)\" href=\"small.css\" /&gt;  &lt;link rel=\"stylesheet\" media=\"screen and (min-width: 600px)\" href=\"large.css\" /&gt;  &lt;link rel=\"stylesheet\" media=\"print\" href=\"print.css\" /&gt; <p>所以呐，凡事没有绝对，最好根据实际情况决定使用media queries的方式。比如，对于iPad，我们可以将多个media queries直接写在一个样式表中。因为iPad用户随时有可能切换屏幕定向，这种情况下，要保证页面在极短的时间内响应屏幕尺寸的调整，我们必须选择效率最高的方式。<p>JavaScript<p>JavaScript也是我们的武器之一，特别是当某些旧设备无法完美支持CSS3的media query时，它可以作为后备支援。幸运的是，已经有专门的JS库来帮助旧浏览器(IE 5+，Firefox 1+，Safari 2等)支持CSS3的media queries。使用方法很简单，下载css3-mediaqueries.js并在你的页面中调用它。<p>而下面的代码则演示了怎样使用简单的几行jQuery代码来检测浏览器宽度，并为不同的情况调用不同的样式表：<p>&lt;script type=\"text/javascript\" src=\"http://ajax.googleapis.com/ajax/libs/jquery/1.4.4/jquery.min.js\"&gt;&lt;/script&gt;  &lt;script type=\"text/javascript\"&gt;  $(document).ready(function(){   $(window).bind(\"resize\", resizeWindow);   function resizeWindow(e){   var newWindowWidth = $(window).width();   // If width width is below 600px, switch to the mobile stylesheet   if(newWindowWidth &lt; 600){   $(\"link[rel=stylesheet]\").attr({href : \"mobile.css\"});   } // Else if width is above 600px, switch to the large stylesheet   else if(newWindowWidth &gt; 600){   $(\"link[rel=stylesheet]\").attr({href : \"style.css\"});   }   }   });   &lt;/script&gt; <p>类似这样的解决方案还有很多。所以我们要清楚，media queries不是一个绝对唯一的答案，它只是一个以纯CSS方式实现响应式Web设计思路的手段。借助JavaScript，我们则可以实现更多的变化。这篇\"Combining Media Queries and JavaScript\"向我们展示了JavaScript配合media queries的更多细节信息。<p>显示或隐藏内容<p>通过前文的学习，我们已经了解到，对于响应式Web设计，同比例缩减元素尺寸以及调整页面结构布局，是两个重要的方式方法。但是对于页面中的文字内容信息来说，则不能简单的只从\"同比缩小\"和\"调整布局结构\"这两方面去处理。对于手机等移动设备来说，在文字内容方面，已经有了很多最佳实践方式和指导原则：简化的导航、更易聚焦的内容、以信息列表代替传统的多行文案内容等。<p><img src=\"/content/uploadfile/201205/thum-8cda81fc7ad906927144235dda5fdf1520120510083354.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>响应式Web设计的思想，一方面要保证页面元素及布局具有足够的弹性，来兼容各类设备平台和屏幕尺寸；另一方面，则是增强可读性和易用性，帮助用户在任何设备环境中都能更容易的获取最重要的内容信息。<p>有一条样式代码，我们已经使用了多年：<p>display: none;<p>我们可以在一个针对某类小屏幕设备的样式表中使用它来隐藏掉页面中的某些块级元素，也可以使用前文的方法，通过JS判断当前硬件屏幕规格，在小屏幕设备的情况下直接为需要隐藏的元素添加工具类class。比如，对于手机类设备，我们可以隐藏掉大块的文字内容区，而只显示一个简单的导航结构，其中的导航元素可以指向详细内容页面。<p>注意，不要使用visibility: hidden的方式，因为这只能使元素在视觉上不做呈现；display属性则可帮助我们设置整块内容是否需要被输出。对于移动设备来说，避免这些不必要的资源浪费还是很重要的。我们来看一个简单的示例：<p><img src=\"/content/uploadfile/201205/thum-30e62fddc14c05988b44e7c02788e18720120510083355.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>图中上半部分是大屏幕设备所显示的完整页面，下面的则是该页面在小屏幕设备的呈现方式。页面HTML代码如下：<p>&lt;p class=\"sidebar-nav\"&gt;&lt;a href=\"#\"&gt;Left Sidebar Content&lt;/a&gt; | &lt;a href=\"#\"&gt;Right Sidebar Content&lt;/a&gt;&lt;/p&gt;  &lt;div id=\"content\"&gt;  &lt;h2&gt;Main Content&lt;/h2&gt;  &lt;/div&gt;  &lt;div id=\"sidebar-left\"&gt;  &lt;h2&gt;A Left Sidebar&lt;/h2&gt;  &lt;/div&gt;  &lt;div id=\"sidebar-right\"&gt;  &lt;h2&gt;A Right Sidebar&lt;/h2&gt;  &lt;/div&gt; <p>下面是默认的主样式表，其中，我们要隐藏掉链接导航部分(sidebar-nav)，因为默认样式适用的设备屏幕会足够大，足够显示包括两个侧边栏在内的所有内容。<p>#content{   width: 54%;   float: left;   margin-right: 3%;   }   #sidebar-left{   width: 20%;   float: left;   margin-right: 3%;   }   #sidebar-right{   width: 20%;   float: left;   }   .sidebar-nav{display: none;} <p>下面是用于小屏幕移动设备的样式表代码。现在，我们要隐藏掉两个侧边栏，并使sidebar-nav显示出来。借助JavaScript，当用户点击sidebar-nav中的链接时，对应的侧边栏可以恢复显示。当然，触发恢复显示的方式有很多种，即可以通过JS改变侧边栏的display属性值，也可以为其添加额外的布局样式。<p>#content{   width: 100%;   }   #sidebar-left{   display: none;   }   #sidebar-right{   display: none;   }   .sidebar-nav{display: inline;} <p>现在，我们的页面已经可以随着设备和屏幕规格的变更，响应式的做到元素的同比缩放、布局结构的改变、内容的优化调整。特别是对于手机设备，我们还要在实践过程中注意一些该类设备共有的设计指导原则。比如，针对手机设备，使用一个特定的样式，将页面原有的文字导航元素变为更易操作的图标形式。下面的一些文章资源可作参考阅读：<p>Mobile Web Design Trends For 2009<p>7 Usability Guidelines for Websites on Mobile Devices<p>触屏与鼠标<p>触屏设备已经成为主流。虽然目前多数触屏设备还是小屏幕类型的产品，比如手机，但是市场上越来越多的大屏幕设备也开始使用触屏技术；且不说iPad一类的平板电脑，就连一些笔记本和台式机也加入了这一行列。比如HP Touchsmart tm2t，即使用传统的键鼠设备，同时也加入了触屏技术。<p><img src=\"/content/uploadfile/201205/thum-ae566253288191ce5d879e51dae1d8c320120510083355.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>相比于传统的基于鼠标指针的互动，触屏技术显然带来了截然不同的交互方式与相应的设计规范；两者又有各自所适用的领域。所幸，要使我们的设计方案同时满足这两类设备的规范，并非一件难事，只是有些地方需要注意。比如，触屏设备无法反映CSS定义的hover行为及相应的样式，因为它没有鼠标指针的概念，手指点击就是click行为。所以不要让任何功能依赖于对hover状态的触发。<p>有兴趣的话，可以读读这篇\"Designing for Touchscreen\"，这里提到的很多建议即有利于改进针对触屏设备的设计方式，同时也不会削弱传统键鼠设备上的用户体验。比如，放在页面右侧的导航列表可以对触屏设备的用户更加友好。因为多数人习惯用右手点击操作，而左手负责握住设备；这样，放在右侧的导航列表即方便右手的点击，又可以避免被握着设备的左手不小心触碰到。而这一点与键鼠设备用户的习惯完全不矛盾。<p>本文章来源于：什么是响应式Web设计？怎样进行？<p>","description":"在Web设计和开发领域，很快的，我们将会无法跟上设备与分辨率革新的步伐。对于多数网站来说，为每种新设备及分辨率创建其独立的版本根本就是不切实际的;结果就是，我们将会赢得使用某些设备的用户群，而失去那些使用其他设备的用户。不过，或许会有另外一种方式，可以帮助我们避免这种情况的发生。","category":"HTML","hot":"y"},{"id":15,"title":"为什么使用<!DOCTYPE HTML>","date":1335513947,"content":"<p>不管是刚接触前端，还是你已经“精通”web前端开发的内容，你应该知道在你写html的时候需要定义文档类型；<p> 你知道如果没有它，浏览器在渲染页面的时候会使用怪异模式；<p> 你知道各个浏览器在怪异模式下对各个元素渲染是有差异的。<p>所以你会写像这样的doctype：<p>&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt;<p>你也许可以尝试这个写法：<p>&lt;!DOCTYPE html&gt;<p>一、写下这个doctype，而不用担心会写错；<p> 二、省下了105字节字符，每日PV达到千万级站点，省下相当客观流量；<p> 三、向后兼容，html5的doctype就是这样写的，并且现代浏览器都认识它。<p>没有定义doctype才会开启怪异模式，也就是说你只需要定义&lt;!doctype html&gt;就可以让浏览器在严格模式（标准模式）下渲染页面，而不需要指定某个类型dtd。<p>根本不需要根据选择的doctype来验证你的页面，只要doctype标签存在就足以开启严格模式（标准模式）了</span><p>","description":"不管是刚接触前端，还是你已经“精通”web前端开发的内容，你应该知道在你写html的时候需要定义文档类型；你知道如果没有它，浏览器在渲染页面的时候会使用怪异模式；你知道各个浏览器在怪异模式下对各个元素渲染是有差异的。","category":"HTML","hot":"n"},{"id":18,"title":"css3 calc()功能小窥","date":1336110423,"content":"<p>之前，我们想要实现一个完美的宽度自适应的输入框好麻烦，曾经也被作为对前端技术的一个挑战。类似的常见场景还有100%宽+边框的容器等。遇到这些情况，我们不得不分外小心，因为各个浏览器的表现可能不一致。现在，firefox和webkit相继支持calc()功能了，我们也可以学习下了。<p>calc()是干嘛的？<p>calc()是单词calculate(计算)的缩写，是css3的一个新的长度单位功能，可以使用简单的数学运算。<p>嗯，CSS3越来越高级了。<p>运算规则<p>calc()使用通用的数学运算规则，但是也提供更智能的功能：<p>    <p>使用“+”“-”“*”“/”四则运算；<p>   <p>可以使用百分比、px、em、rem等单位；<p>   <p>可以混合使用各种单位进行计算。<p>  <p>实例：<p>我们来看几个小例子来理解下calc()功能吧：<p>.box{ border:1px solid #ddd; width:calc(100%-2px) }<p>容器宽度加上边框宽度正好100%。<p>.box{ width:calc(10em+20px) }<p>宽度，10em加20px。<p>.box{ margin-left:20px; width:calc(100%/3-20px); } .box:nth-child(3n){ margin-left:0; }<p>3栏等宽布局。<p>浏览器支持<p>firefox 4.0+已经开支支持calc()功能，不过要使用-moz-calc()私有属性，chrome从19 dev版，也开始支持私有的-webkit-calc()写法，IE9这次则牛逼了一次，原生支持标准的不带前缀的写法了。Opera貌似还不支持～～<p>所以如果我们要用这个属性的话，要记得带上各浏览器的兼容性。<p> <p>本文章来源于：css3 calc()功能小窥<p>","description":"之前，我们想要实现一个完美的宽度自适应的输入框好麻烦，曾经也被作为对前端技术的一个挑战。类似的常见场景还有100%宽+边框的容器等。遇到这些情况，我们不得不分外小心，因为各个浏览器的表现可能不一致。现在，firefox和webkit相继支持calc()功能了，我们也可以学习下了。","category":"CSS","hot":"y"},{"id":19,"title":"HTML5 中 div section article 的区别","date":1336113987,"content":"<p>刚刚开始接触 HTML5 时，对它的标签很不适应，甚至一度有点反感。尤其是对 div、section、article 这几个标签，实在弄不清楚应该使用在什么场合下。<p>div<p>HTML Spec: “The div element has no special meaning at all.”<p>这个标签是我们见得最多、用得最多的一个标签。本身没有任何语义，用作布局以及样式化或脚本的钩子(hook)。<p>section<p>HTML Spec: “The section element represents a generic section of a document or application. A section, in this context, is a thematic grouping of content, typically with a heading.”<p>与 div 的无语义相对，简单地说 section 就是带有语义的 div 了，但是千万不要觉得真得这么简单。section 表示一段专题性的内容，一般会带有标题。看到这里，我们也许会想到，那么一篇博客文章，或者一条单独的评论岂不是正好可以用 section 吗？接着看：<p>“Authors are encouraged to use the article element instead of the section element when it would make sense to syndicate the contents of the elemen.”<p>当元素内容聚合起来更加言之有物时，应该使用 article 来替换 section 。<p>那么，section 应该什么时候用呢？再接着看：<p>“Examples of sections would be chapters, the various tabbed pages in a tabbed dialog box, or the numbered sections of a thesis. A Web site’s home page could be split into sections for an introduction, news items, and contact information.”<p>section 应用的典型场景有文章的章节、标签对话框中的标签页、或者论文中有编号的部分。一个网站的主页可以分成简介、新闻和联系信息等几部分。其实我对这里传达信息很感兴趣，因为感觉 section 和下面要介绍的 artilce 更加适用于模块化应用，这个话题以后会出篇专门的文章来讨论，这里暂时略过。<p>要注意，W3C 还警告说：<p>“The section element is not a generic container element. When an element is needed for styling purposes or as a convenience for scripting, authors are encouraged to use the div element instead. A general rule is that the section element is appropriate only if the element’s contents would be listed explicitly in the document’s outline.”<p>section 不仅仅是一个普通的容器标签。当一个标签只是为了样式化或者方便脚本使用时，应该使用 div 。一般来说，当元素内容明确地出现在文档大纲中时，section 就是适用的。<p>&lt;article&gt;  &lt;hgroup&gt;   &lt;h1&gt;Apples&lt;/h1&gt;   &lt;h2&gt;Tasty, delicious fruit!&lt;/h2&gt;  &lt;/hgroup&gt;  &lt;p&gt;The apple is the pomaceous fruit of the apple tree.&lt;/p&gt;  &lt;section&gt;   &lt;h1&gt;Red Delicious&lt;/h1&gt;   &lt;p&gt;These bright red apples are the most common found in many   supermarkets.&lt;/p&gt;  &lt;/section&gt;  &lt;section&gt;   &lt;h1&gt;Granny Smith&lt;/h1&gt;   &lt;p&gt;These juicy, green apples make a great filling for   apple pies.&lt;/p&gt;  &lt;/section&gt; &lt;/article&gt;<p>article<p>HTML Spec: “The article element represents a self-contained composition in a document, page, application, or site and that is, in principle, independently distributable or reusable, e.g. in syndication.”<p>article 是一个特殊的 section 标签，它比 section 具有更明确的语义，它代表一个独立的、完整的相关内容块。一般来说， article 会有标题部分（通常包含在 header 内），有时也会 包含 footer。虽然 section 也是带有主题性的一块内容，但是无论从结构上还是内容上来说，article 本身就是独立的、完整的。<p>HTML Spec 中接着又列举了一些 article 适用的场景。 “This could be a forum post, a magazine or newspaper article, a blog entry, a user-submitted comment,an interactive widget or gadget, or any other independent item of content.”<p>当 article 内嵌 article 时，原则上来说，内部的 article 的内容是和外层的 article 内容是相关的。例如，一篇博客文章中，包含用户提交的评论的 article 就应该潜逃在包含博客文章 article 之中。<p>问题是怎么才算“完整的独立内容”？有个最简单的判断方法是看这段内容在 RSS feed 中是不是完整的。看这段内容脱离了所在的语境，是否还是完整的、独立的。<p>例子：<p>&lt;article&gt;  &lt;hgroup&gt;   &lt;h1&gt;Apples&lt;/h1&gt;   &lt;h2&gt;Tasty, delicious fruit!&lt;/h2&gt;  &lt;/hgroup&gt;  &lt;p&gt;The apple is the pomaceous fruit of the apple tree.&lt;/p&gt;  &lt;section&gt;   &lt;h1&gt;Red Delicious&lt;/h1&gt;   &lt;p&gt;These bright red apples are the most common found in many   supermarkets.&lt;/p&gt;  &lt;/section&gt;  &lt;section&gt;   &lt;h1&gt;Granny Smith&lt;/h1&gt;   &lt;p&gt;These juicy, green apples make a great filling for   apple pies.&lt;/p&gt;  &lt;/section&gt; &lt;/article&gt;<p>&lt;article&gt;  &lt;header&gt;   &lt;h1&gt;The Very First Rule of Life&lt;/h1&gt;   &lt;p&gt;&lt;time pubdate datetime=\"2009-10-09T14:28-08:00\"&gt;&lt;/time&gt;&lt;/p&gt;  &lt;/header&gt;  &lt;p&gt;If there\'s a microphone anywhere near you, assume it\'s hot and  sending whatever you\'re saying to the world. Seriously.&lt;/p&gt;  &lt;p&gt;...&lt;/p&gt;  &lt;section&gt;   &lt;h1&gt;Comments&lt;/h1&gt;   &lt;article&gt;    &lt;footer&gt;     &lt;p&gt;Posted by: George Washington&lt;/p&gt;     &lt;p&gt;&lt;time pubdate datetime=\"2009-10-10T19:10-08:00\"&gt;&lt;/time&gt;&lt;/p&gt;    &lt;/footer&gt;    &lt;p&gt;Yeah! Especially when talking about your lobbyist friends!&lt;/p&gt;   &lt;/article&gt;   &lt;article&gt;    &lt;footer&gt;     &lt;p&gt;Posted by: George Hammond&lt;/p&gt;     &lt;p&gt;&lt;time pubdate datetime=\"2009-10-10T19:15-08:00\"&gt;&lt;/time&gt;&lt;/p&gt;    &lt;/footer&gt;    &lt;p&gt;Hey, you have the same first name as me.&lt;/p&gt;   &lt;/article&gt;  &lt;/section&gt; &lt;/article&gt;<p>总结<p>div section article ，语义是从无到有，逐渐增强的。div 无任何语义，仅仅用作样式化或者脚本化的钩子(hook)，对于一段主题性的内容，则就适用 section，而假如这段内容可以脱离上下文，作为完整的独立存在的一段内容，则就适用 article。原则上来说，能使用 article 的时候，也是可以使用 section 的，但是实际上，假如使用 article 更合适，那么就不要使用 section 。nav 和 aside的使用也是如此，这两个标签也是特殊的 section，在使用 nav 和 aside 更合适的情况下，也不要使用 section 了。<p>对于 div 和 section、 article 以及其他标签的区分比较简单。对于 section 和 article 的区分乍看比较难，其实重点就是看看这段内容脱离了整体是不是还能作为一个完整的、独立的内容而存在，这里面的重点又在完整身上。因为其实说起来section 包含的内容也能算作独立的一块，但是它只能算是组成整体的一部分，article 才是一个完整的整体。<p>因为其实有些时候每个人都有自己的看法，所以难免有难于决断的时候，怎么办？<p>在HTML5 设计原理中，有一条是专门用来解决类似情况的：<p>最终用户优先(Priority of Constituencies)<p>“In case of conflict, consider users over authors over implementors over specifiers over theoretical purity.” 一旦遇到冲突，最终用户优先，其次是作者，其次是实现者，其次标准制定者，最后才是理论上的完满。<p> <p>本文章来源于：HTML5 中 div section article 的区别<p>","description":"刚刚开始接触 HTML5 时，对它的标签很不适应，甚至一度有点反感。尤其是对 div、section、article 这几个标签，实在弄不清楚应该使用在什么场合下。","category":"HTML","hot":"n"},{"id":23,"title":"写代码如坐禅：你是哪一类程序员？","date":1336542105,"content":"<p>当编译占用你时间时你会怎么做。不只是编译，即使是在等待任何短暂的计算机操作结束，这段时间你会干些什么?<p>和你的工作日休息比起来这点时间是微不足道的，但是总的来说它还是能对你的生产率和幸福感感带来巨大帮助的。<p>顺便说一下，这篇文章内容不是只针对开发者和程序的。它对任何使用电脑的聪明人都有效。后面还会附上图片。现在让我们开始吧!<p>为什么要写这篇文章<p>我最近开始在我的工作习惯里使用某种时间管理技巧来提升我的生产率，减小压力，并帮助我的身体和大脑得到休息。我基本上想要在不被打扰的100%注意力集中的一两个小时里工作,然后就是20到30分钟的休息。<p>然而，我几乎立刻就进入了一个巨大的问题里：当我正在编译或部署什么东西时，我会自动地打开邮件客户端，facebook，新闻阅读器，新闻站点中的某一个或几个。这是一个坏习惯。它很难改掉。它扰乱了我本来专注的注意力。<p>所以我决定搜索相关资料。在 StackExchange 有一个关于“编译时应该做什么”的论坛。投票最多的答案是“减少编译时间”一类的。然而，这些答案并不能解决更多的普遍问题：在电脑上工作时总是有些事项是需要时间来等待的。<p>与之不同的，论坛上的人多半建议那些时间可以做些什么(类似收发邮件或是看新闻)，这是一个差劲的想法。一个好的建议是这个——“同一时间干多件事是不好的”。我赞同这个观点。但其他人呢?不认为?好的。这个答案令人失望。所以在这篇文章里，我将深入探索这个问题并且向你展示最理想的方法。<p>两种类型的程序员<p>有两种极端原型的程序员——“禅宗的程序员”，我们称为心如止水的程序员，还有“不能克制分心的程序员”，我们称为心绪不定的程序员。两者都是非常极端的，所以他们应该处于贝尔钟形曲线的两端，对吗?<p>错。实际上，心绪不定的程序员是难以置信地普遍存在着。<p>图片的效果要比文字有用，所以我现在用图片来说明两种程序员的精神世界的状态。<p>心如止水的程序员<p>心如止水的程序员会怎么做?<p>他写代码。这是他做的唯一的事情，这也说明了一切。也许更重要的问题是什么事情他没有做：他没有受分心的影响。专注的注意力，专注的修改，专注的编码。一到两个小时的纯代码时间，然后才是20-30分钟的休息，通常是离开电脑。之后他会继续开始写代码。(以上所说的时间只是一个例子。他可以用其它方式安排时间-不过他总是能平衡并搞定长时间的生产率。)<p>他的思维像平静的水缓慢地流动。当然它不像那种恒久不变的凝固的冰。<p>这就是心如止水的程序员精神世界看起来的样子：<p><img src=\"/content/uploadfile/201205/thum-9d1719fe518e66cb6176e9629a5e0e1920120509055314.png\" alt=\"点击查看原图\" border=\"0\" /><p>心绪不定的程序员<p>即使你的精神世界现在看起来像一个心如止水的程序员，只要你在编译的时候打开了Facebook或者检查了你的邮件还是做了其它什么事情。几分钟之后它就会像这样：<p><img src=\"/content/uploadfile/201205/thum-e95da2b946f4de5c5907607b2980cfda20120509055321.png\" alt=\"点击查看原图\" border=\"0\" /><p>女士们先生们，这就是你检查你的邮件和打开Facebook后的状况。如果你还拥有一堆实时通知，即时通讯，还要去检查你的RSS源和推特，结果就是大脑像上面图中变成碎片的灾难一样。<p>你可能还没有完全从这张图恢复过来。不在特定的某天，任何时候都有可能发生。即使你把精神世界所有无用的东西最小化到任务栏，它仍会留在那里，不停地引诱你，消耗你的精神资源。朋友，时间就这样走了，你会困惑它是怎么不见的。<p>顺便说一下，如果你是一个心绪不定的人，你还是可以看看我们网站的网页漫画!不必立刻回来把这篇文章读完。别忘了订阅那个漫画源!看完所有的漫画后可以分享给你的朋友并聊聊!做这些事不会过于分心的，真的!<p>心如止水的程序员与心绪不定的程序员之间的区别<p>心如止水的程序员更倾向于长期的幸福感和生产率。他有能力高度集中注意力，关注目标。<p>心绪不定的程序员更倾向于短暂的满足感，长期这样不能到达全部的潜力并且会对他自己的身体和精神带来双方面的伤害。他不能定下心来集中注意力。<p>为了彻底领悟这点，我们首先需要理解我们的大脑是怎样工作的。<p>我们的大脑是怎么工作的<p>事实上我们不能完全知道，不过，基于我们现在已有的理解，心理学家已经提出了一些有用的类比方法，可以帮助我们领悟复杂的东西。<p>电脑的类比<p>你的大脑像一台电脑。当然，它要比一台个人电脑复杂多了，不过电脑的比喻说法可以让我们形容许多在大脑里运行的进程。有些东西像硬盘，有些东西像内存和中央处理器，还有进程和线程，它们的确需要一些时间来访问信息并计算数据。<p>很明显我们的大脑拥有一定的容量在任一时刻集中注意力。你可以很好地集中在某一东西上，或是不太好地集中到几样东西上，但你不能两者都做到。把注意力从一个任务转到另一个任务甚至会影响认知能力，特别是两种毫不相干的任务。<p>只要你把意识关注在某样东西上，就会花些时间处理它和它所分配的资源并会从内存和后台进程里初始化它。它可以存在几个小时甚至几天。最近的关注到的东西在任何时刻都会不断出现的。即时你没有注意到它们在你的大脑里流动，它们一直都在那儿——而且它们占用资源，使你不能集中注意力。<p>抽屉的类比<p>另一种有用的比喻说法是柜子里的抽屉。你的大脑像存放东西的抽屉。每个抽屉都是拥有数据且互相连接的，基于某种上下文关系和概念。在特定的时间里，一些抽屉是打开的，一些是关闭的。打开的抽屉代表着你当前的精神空间，它们很容易访问到。<p>主要的问题是关闭抽屉是需要很长时间的，而打开它们是非常快的。<p>所以，当你在工作时，注意力转到新的地方，它会立即打开一堆抽屉。当你回到工作状态时，那些抽屉仍然是开着的。这样唯一的好处是可以提高你的创造力和头脑风暴——但是不需要的抽屉开着会有影响的。它们抑制左脑的思维并降低注意力。<p>编译时应该做什么<p>在等待电脑执行操作的时间里，你的行为可以判断出你是一个心如止水的程序员还是心绪不定的程序员。<p>主要的意见是：<p>    <p>1.不要分心<p>   <p>2.短暂的休息<p>  <p>保持注意力并不是那么难——你必须要切断你大脑的电源，或者保持注意力集中在你的代码上。不过，关闭大脑效果更好。这样会进入一个微冥想状态，在短暂休息之后它仍会有效。<p>为什么要进入冥想?好的，你的大脑每天都在咀嚼代码，为什么不给它一个休息呢?此外冥想科学上被证实能不断增加幸福等级。想象一下每天进行两次30-60秒表面上看起来不重要的冥想所带来的长期优势吧。<p>现在，短暂的休息时应该做些什么?从以下内容中选择任何事，按你的想法组合在一起。你可以把它们按照这个顺序全部做一遍，这取决于(也可以不在意)这些行为所需要的时间。<p>    <p>1.站起来<p>   <p>2.眺望远处<p>   <p>3.把双手放在脑后，斜靠在椅子上<p>   <p>4.伸长双腿，把双手尽量举高<p>   <p>5.闭上双眼<p>   <p>6.轻揉眼睛<p>   <p>7.慢慢地把头向各个方向转，舒展颈椎<p>   <p>8.闭上双眼然后深呼吸<p>   <p>9.倒一杯水(要小心路上别被同事分心了)<p>  <p>你也可以做任何主要身体参与而不影响思维的事——静力锻炼，变戏法，决斗，哈哈<p>顺便说一下，如果你的老板不给你足够的时间做以上的任何事，那么推荐他来看这篇文章。让自己更快地恢复精神并保持注意力，比看起来在工作其实已经分散注意力并很快就感到累的情况要好很多。<p>伸展放松是很有益处的。我上一次见我的理疗师时她发现我的肩膀很多地方很紧绷。她告诉我这可能是因为我坐在电脑前双手总是弯曲造成的，所以肌肉缩短而且不能用力。那我应该怎么做最好呢?举高我的双手，试着举到最高。这是我在编译或是等待电脑执行操作时常做的一件事。<p>你可能已经听说过当你在用电脑时进行有规律伸展放松和短暂休息是一个不错的想法。问题是怎么做到——即使你设置了一个计时器，但假如到时你正处在一个复杂的事情，正做到一半的时候怎么办?这样看来就无法实现了。然而，如果你在编译时短暂休息一下，就能很好地做到了，你甚至可以把它养成一种习惯，让它变得更“自然”!现在编译就开始能提醒你做伸展放松了。这太令人不可思议了。<p>编译时你不应该做的事情<p>我其实想用力点击我的主页，这样做能让事情变得简单，这里有一张你在编译时不应该做的事情的列表。以这种方式思考：这些事情不仅会使你不能集中注意力，还会让你的思维和身体不能很好地短暂休息。<p>    <p>1.阅读你的RSS源<p>   <p>2.阅读新闻(任何新闻)<p>   <p>3.收发邮件<p>   <p>4.浏览各类社交媒体(Facebook,twitter,google+,linkedin,reddit)<p>   <p>5.观看视频<p>   <p>做以下两件事要比上面的好一点，但依然不推荐：<p>   <p>1.和同事聊天<p>   <p>2.读一本物理书<p>  <p>专注的注意力和专注地修改<p>我马上就要结束这篇我所想的每日工作流程的理想方法——禅宗程序员的文章了。<p>保证生产率和效率的关键是注意力100%集中在你现在正在做的事情上，做完后再把注意力完全转移到其他地方。注意力从一件事情到下一件事情的过渡不能有任何的拖泥带水。<p>把你的工作时间分成1-2个小时一段。注意力100%集中在这些时间段里。然后是20-30分钟的休息，完全可以做任何事情。在休息时间你可以浏览你的邮件和社交媒体，当然，散个步打个盹吃些健康的点心会更好。休息结束后，检查任务管理软件(比如，我用的是我的Swift To-Do List)里下一个工作是什么，再开始另一段需要百分百注意力集中的工作。在较大程度上，这与番茄工作法有点相似。<p>休息不是可以选择要不要的。别想去跳过它。你的身体需要休息。即使你在做你喜欢的工作，你也需要休息一下——在这种情况，你会在接下来的时间段里有动力做更多事。<p>你的工作流程看起来应该像这样：<p>(任务1 - 任务2)- 休息 - (任务2 - 任务3 - 任务4) - 休息 -(另一个1-2小时的时间段) - 休息 ……<p>不要让它完成起来是像这样混乱随机，让人看不下去的的：<p>任务1 - 邮件 - 任务1 - Facebook - 任务1 - 任务2 - 短暂休息 - Facebook - 任务2 - 邮件 - reddit - 任务3 - 邮件 - 休息 - 任务2 - 邮件 - 任务3 - 推特 - 黑客新闻 - 推特 - 任务1 - 任务3 - 休息 - 任务4<p>如果你的工作流程是像上面这样，那你既不能完全放松也不能做完你能完成的事情。这是最低级的方法。这不仅浪费了你的潜力和时间，也让你长期身体会不适。<p>我不想撒谎。集中注意力真的不容易。它很困难，因为当你没有集中注意力时，你基本上会朝着相反的方向过去。习惯和根深蒂固的惯例像潜意识一样难改变。<p>好消息就是，你还可以练习。你可以学习怎样去集中精神。这是每个人都可以学的技能，而且它非常有用，值得为之努力。<p>——转载于Jiri Novotny+，作者由于Windows平台任务管理软件的困扰。他把这篇用户文章投递在 ComponentOwl.com，因为他的Swift To-Do List要使用 Component Owl上基于.Net框架的Better ListView作为它的核心组件。<p>另附：你有没有身边的人会每天要检查50次邮箱?把这篇文章发给他。他之后会感谢你的。<p>本文章来源于：写代码如坐禅：你是哪一类程序员？<p>","description":"当编译占用你时间时你会怎么做。不只是编译，即使是在等待任何短暂的计算机操作结束，这段时间你会干些什么?和你的工作日休息比起来这点时间是微不足道的，但是总的来说它还是能对你的生产率和幸福感感带来巨大帮助的。顺便说一下，这篇文章内容不是只针对开发者和程序的。它对任何使用电脑的聪明人都有效。后面还会附上图片。现在让我们开始吧!","category":"杂谈","hot":"y"},{"id":24,"title":"谷歌研发先进编程技术 简化Web应用开发","date":1336544047,"content":"<p>北京时间3月28日消息，据国外媒体报道，谷歌工程师亚历克斯·拉塞尔(Alex Russell)本周在EclipseCon会议上表示，该公司在开发许多先进的编程技术，简化Web应用开发。<p>拉塞尔说，“Web的发展已经到了一个关键点，正在成为运行时间库整合平台。”尽管非常普及，但与Java或Windows等平台相比，Web只提供了相对原始的编程能力。Web的一大缺点是没有“通用组件模型”(common component model)，影响了代码测试和重用。<p>拉塞尔表示，谷歌在从事大量不同的项目，为Web带来先进的软件技术概念。谷歌的目标是，在不给初学者带来困惑的情况下，为Web带来底层控制元素。<p>拉塞尔承认，Web很大一部分优势在于其易用性，但这种易用性限制了开发者的表达能力。谷歌的努力包括创建一个通用组件模型，为JavaScript增添类，甚至开发面向大型Web应用的编程语言。<p>拉塞尔称，谷歌工程师还在制订为下一版JavaScript增添类的提案。类是面向对象编程语言的核心元素，是数据和代码重用的基础。目前，JavaScript不支持类，编程人员只能使用函数调用完成一些功能，既浪费时间，编写出的代码也不利于重用。<p>谷歌的另一个项目是去年推出的名为Dart的编程语言。谷歌软件开发人员丹·拉贝尔(Dan Rubel)在EclipseCon会议上谈到Dart时说，“在开发大型Web应用时，当前的编程语言在可伸缩性方面都存在问题。”<p><img src=\"/content/uploadfile/201205/d0e0ebbe031e7aac7ebf6e63ad23cc3120120509071256.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>本文章来源于：谷歌研发先进编程技术 简化Web应用开发<p>","description":"北京时间3月28日消息，据国外媒体报道，谷歌工程师亚历克斯·拉塞尔(Alex Russell)本周在EclipseCon会议上表示，该公司在开发许多先进的编程技术，简化Web应用开发。","category":"杂谈","hot":"n"},{"id":25,"title":"难以置信的HTML 5和JS实验","date":1336618547,"content":"<p>Google的Chrome实验室收集了很多让人难以置信的基于 HTML5 Canvas 和 JavaScript 的实验项目，里面的例子都很独特，让人惊叹。我从未想过结合 HTML 和 JavaScript 能实现这么强大的效果。<p>今天，本文与大家分享其中9个很棒的例子，为了有更好的效果，建议在Chrome浏览器中浏览。<p>Untangle<p><img src=\"/content/uploadfile/201205/f3ccdd27d2000e3f9255a7e3e2c4880020120510031442.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>拖动蓝点，让所有线都不相交，看看你多久能解开？ :)<p>Z Type<p><img src=\"/content/uploadfile/201205/156005c5baf40ff51a327f1c34f2975b20120510031442.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>一款太空射击游戏，基于ImpactJS游戏库开发。<p>Cube Out<p><img src=\"/content/uploadfile/201205/799bad5a3b514f096e69bbc4a7896cd920120510031442.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>模仿经典的益智游戏Blockout（三维俄罗斯方块），移动和旋转方块填补空白，完成一层后会自动消隐。<p>Bounce<p><img src=\"/content/uploadfile/201205/d0096ec6c83575373e3a21d129ff8fef20120510031445.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>一款javascript游戏，点击和控制蓝色的盒子，让黄色的点击不要碰到红色的点。<p>Sketch 3D<p><img src=\"/content/uploadfile/201205/032b2cc936860b03048302d991c3498f20120510031446.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>一款非常棒的素描工具，这里可看别人的作品。<p>Conductor<p><img src=\"/content/uploadfile/201205/18e2999891374a475d0687ca9f989d8320120510031446.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>Conductor转换纽约地铁系统为一个互动的弦乐器，使用真实的地铁时刻表来模拟。<p>Bacterium<p><img src=\"/content/uploadfile/201205/fe5df232cafa4c4e0f1a0294418e566020120510031446.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>模仿水族馆，您可以创建丰富多彩，充满活力的运动模式。<p>Ultra Neuron Pong<p><img src=\"/content/uploadfile/201205/8cda81fc7ad906927144235dda5fdf1520120510031446.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>这是模仿经典的Pong游戏开发的一款基于HTML5技术的游戏。<p>Tank World<p><img src=\"/content/uploadfile/201205/30e62fddc14c05988b44e7c02788e18720120510031441.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>一款让人惊叹的三维射击游戏。<p>本文章来源于：九个让人难以置信的HTML5和JavaScript实验<p>","description":"今天，本文与大家分享其中9个很棒的例子，HTML5 Canvas 和 JavaScript 的实验项目，里面的例子都很独特，让人惊叹。为了有更好的效果，建议在Chrome浏览器中浏览","category":"JavaScript","hot":"n"},{"id":26,"title":"HTML5实现的Loading缓冲效果","date":1336620998,"content":"<p>HTML5在移动设备上表现，相信已经不用我多说了，干掉了Flash之后，它已经坐上了移动应用程序的第一把交椅。几乎所有稍微高端一点的设备（乔帮主的iPad，iPhone和Andriod的平板手机等）的浏览器都支持HTML5，而且据权威人士测试，这些支持HTML5的设备对Canvas标签的支持也是相当的好。<p>大家都知道Web2.0以来，应用程序的实现使用了大量Ajax，而Loading的小图标也有很多，甚至还有专门提供Loading图片的网站，所以我就想能不能让HTML5一并解决这个以前用gif文件才能解决的问题。出乎我意料的是，实现的过程非常简单，只用了不到一小时的时间我就用HTML5实验出了两个Loading效果，而且这样做出来的Loading图标是可定制的，既可以定制颜色，也可以定制大小等属性。<p>第一个带着小尾巴转动的loading图标画图的思路是，首先画一个圆，然后在圆的边上按顺序画大小逐渐减小的小圆点，在每次刷新画布时改变这一系列的小圆点在大圆边上的位置。<p>这里是案例的演示代码：<p>&lt;!doctype html&gt; &lt;html&gt;   &lt;head&gt;    &lt;meta http-equiv=\"content-type\" content=\"GBK\"/&gt;    &lt;title&gt;loading&lt;/title&gt;    &lt;script type=\"text/javascript\"&gt;     function loading(canvas,options){       this.canvas = canvas;       if(options){         this.radius = options.radius||12;         this.circleLineWidth = options.circleLineWidth||4;         this.circleColor = options.circleColor||\'lightgray\';         this.dotColor = options.dotColor||\'gray\';       }else{         this.radius = 12;         this.circelLineWidth = 4;         this.circleColor = \'lightgray\';         this.dotColor = \'gray\';       }     }     loading.prototype = {       show:function (){         var canvas = this.canvas;         if(!canvas.getContext)return;         if(canvas.__loading)return;         canvas.__loading = this;         var ctx = canvas.getContext(\'2d\');         var radius = this.radius;         var rotators = [{angle:0,radius:1.5},{angle:3/radius,radius:2},{angle:7/radius,radius:2.5},{angle:12/radius,radius:3}];         var me = this;         canvas.loadingInterval = setInterval(function(){           ctx.clearRect(0,0,canvas.width,canvas.height);           var lineWidth = me.circleLineWidth;           var center = {x:canvas.width/2 - radius,y:canvas.height/2-radius};           ctx.beginPath();           ctx.lineWidth = lineWidth;           ctx.strokeStyle = me.circleColor;           ctx.arc(center.x,center.y,radius,0,Math.PI*2);           ctx.closePath();           ctx.stroke();           for(var i=0;i&lt;rotators.length;i++){             var rotatorAngle = rotators[i].currentAngle||rotators[i].angle;             //在圆圈上面画小圆             var rotatorCenter = {x:center.x-(radius)*Math.cos(rotatorAngle) ,y:center.y-(radius)*Math.sin(rotatorAngle)};             var rotatorRadius = rotators[i].radius;             ctx.beginPath();             ctx.fillStyle = me.dotColor;             ctx.arc(rotatorCenter.x,rotatorCenter.y,rotatorRadius,0,Math.PI*2);             ctx.closePath();             ctx.fill();             rotators[i].currentAngle = rotatorAngle+4/radius;           }         },50);       },       hide:function(){         var canvas = this.canvas;         canvas.__loading = false;         if(canvas.loadingInterval){           window.clearInterval(canvas.loadingInterval);         }         var ctx = canvas.getContext(\'2d\');         if(ctx)ctx.clearRect(0,0,canvas.width,canvas.height);       }     };     &lt;/script&gt;   &lt;/head&gt;   &lt;body&gt;     &lt;canvas id=\"canvas\" width=\"300\" height=\"100\" style=\"border:1px solid #69c\"&gt;&lt;/canvas&gt;     &lt;p&gt;     &lt;input type=\"button\" onclick=\"loadingObj.hide()\" value=\"HideLoading\"/&gt;     &lt;input type=\"button\" onclick=\"loadingObj.show()\" value=\"showLoading\"/&gt; &lt;/style&gt;     &lt;p&gt;     &lt;script&gt;     var loadingObj = new loading(document.getElementById(\'canvas\'),{radius:8,circleLineWidth:3});     loadingObj.show();     &lt;/script&gt;   &lt;/body&gt; &lt;/html&gt;<p>第二个较为简单，在一个圆环上有一个相同圆心相同半径的圆弧在不停的转动。画图的步骤是首先画一个圆环，然后画一个不同颜色相同圆心半径的圆弧，在每次刷新画布时改变圆弧的起始角度。<p>这里是案例的演示代码：<p>&lt;!doctype html&gt; &lt;html&gt; &lt;head&gt;   &lt;meta http-equiv=\"content-type\" content=\"text/html;charset=gbk\"/&gt;   &lt;title&gt;loading&lt;/title&gt;   &lt;script&gt;    /*     html5 loading 控件     作者：玉开 博客：http://www.cnblogs.com/yukaizhao/     发布或使用此控件，请保留作者声明     */     function loading(canvas,options){       this.canvas = canvas;       if(options){         this.radius = options.radius||12;         this.circleLineWidth = options.circleLineWidth||4;         this.circleColor = options.circleColor||\'lightgray\';         this.moveArcColor = options.moveArcColor||\'gray\';       }else{         this.radius = 12;         this.circelLineWidth = 4;         this.circleColor = \'lightgray\';         this.moveArcColor = \'gray\';       }     }     loading.prototype = {       show:function (){         var canvas = this.canvas;         if(!canvas.getContext)return;         if(canvas.__loading)return;         canvas.__loading = this;         var ctx = canvas.getContext(\'2d\');         var radius = this.radius;         var me = this;         var rotatorAngle = Math.PI*1.5;         var step = Math.PI/6;         canvas.loadingInterval = setInterval(function(){           ctx.clearRect(0,0,canvas.width,canvas.height);           var lineWidth = me.circleLineWidth;           var center = {x:canvas.width/2 - radius,y:canvas.height/2-radius};           ctx.beginPath();           ctx.lineWidth = lineWidth;           ctx.strokeStyle = me.circleColor;           ctx.arc(center.x,center.y,radius,0,Math.PI*2);           ctx.closePath();           ctx.stroke();           //在圆圈上面画小圆           ctx.beginPath();           ctx.strokeStyle = me.moveArcColor;           ctx.arc(center.x,center.y,radius,rotatorAngle,rotatorAngle+Math.PI*.45);           ctx.stroke();           rotatorAngle+=step;         },50);       },       hide:function(){         var canvas = this.canvas;         canvas.__loading = false;         if(canvas.loadingInterval){           window.clearInterval(canvas.loadingInterval);         }         var ctx = canvas.getContext(\'2d\');         if(ctx)ctx.clearRect(0,0,canvas.width,canvas.height);       }     };     &lt;/script&gt;   &lt;/head&gt;   &lt;body&gt;     &lt;canvas id=\"canvas\" width=\"300\" height=\"100\" style=\"border:1px solid #69c\"&gt;您的浏览器不支持html5哟&lt;/canvas&gt;     &lt;p&gt;     &lt;input type=\"button\" onclick=\"loadingObj.hide()\" value=\"HideLoading\"/&gt;     &lt;input type=\"button\" onclick=\"loadingObj.show()\" value=\"showLoading\"/&gt;     &lt;/p&gt;     &lt;script&gt;     var loadingObj = new loading(document.getElementById(\'canvas\'),{radius:8,circleLineWidth:3});     loadingObj.show();     &lt;/script&gt;   &lt;/body&gt; &lt;/html&gt;<p>目前从移动设备对HTML5的支持来看，HTML5将来必定大有可为。<p>天下大势，合久必分，分久必和。PC开发时Web应用在很大程度上统一了客户端程序；而现在移动开发使用不同的系统不同的语言，将来大多数应用必然会统一到一种语言，这种语言必然是html5加Javascript。<p>注意：由于目前支持HTML5的浏览器还不是很多，请各位在查看演示案例的时候使用Firefox10或者Oprea11等高版本浏览器。<p>本文章来源于：HTML5实现的Loading缓冲效果<p>","description":"大家都知道Web2.0以来，应用程序的实现使用了大量Ajax，而Loading的小图标也有很多，甚至还有专门提供Loading图片的网站，所以我就想能不能让HTML5一并解决这个以前用gif文件才能解决的问题。","category":"HTML","hot":"y"},{"id":28,"title":"5种在设计中应用光线和阴影的简单技法","date":1336628455,"content":"<p>凡是你目光所及——光线和阴影无处不在。你看到的任何东西都反射回光线，也都或多或少产生阴影。光线和阴影帮助我们去感知我们的所见，并且帮助我们理解材质纹理、尺寸大小以及位置空间。<p>所以，当我们试图让Web页面设计更加自然生动、栩栩如生的时候，对于光线和阴影的透彻理解就显得相当重要了。以下5种利用光线和阴影的技法让你的页面得以重塑，使它们在屏幕上变得引人注目。<p>光线和阴影的快速解析<p>在下面这个简单的图例中，我们可以看到，光源从画面左上方投射过来，高光在光线最强的那一面上，而阴影则落在离光源最远的那一面。在这张图片中，通过光和影的表现，我们得以了解物体的外观和纹理质感。<p><img src=\"/content/uploadfile/201205/thum-f3ccdd27d2000e3f9255a7e3e2c4880020120510060208.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>但是你有疑问了，这些和Web设计有什么关系?<p>如果你正尝试投身入丰富、真实的界面和网站设计，那么光线和阴影无疑是你的良师益友。同样的，许多传统艺术家运用此法让笔下所画之物跃然纸上，你也可以利用光影让你的设计空间感十足并博得人们的视觉兴趣点。让我们开始吧。<p><p>1、使用光源<p>也许运用光线的最重要的一点就是要了解光是从哪里来的。光源的方向几乎决定了高光和阴影投射的位置（虽然在Web设计中你可以适当的调整一下规则）。如果你使用的是Photoshop，使用“全局光”可将所有的光照效果遵循同一个光源方向。<p>在设计中（哪怕只是线性或径向渐变）控制光源有助于为你的设计增添一种环境效果。当然也可以为设计添加一个视觉焦点。<p>案例<p>Campaign Monitor 运用一个放射性的光线以表现一种太阳在页面后升起的效果。<p><img src=\"/content/uploadfile/201205/thum-156005c5baf40ff51a327f1c34f2975b20120510060208.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>Icebrrg 运用光线让网站有种处于水面之下的感觉。<p><img src=\"/content/uploadfile/201205/thum-799bad5a3b514f096e69bbc4a7896cd920120510060207.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>Mike Precious 使用了多处光源以增加视觉兴趣点，并且风格上合（右上角的）工作灯联系起来。<p><img src=\"/content/uploadfile/201205/thum-d0096ec6c83575373e3a21d129ff8fef20120510060207.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>Deaxon在其logo背后运用一个细微的光源，起到了突出logo视觉效果的作用。<p><img src=\"/content/uploadfile/201205/thum-032b2cc936860b03048302d991c3498f20120510060206.jpg\" alt=\"点击查看原图\" border=\"0\" /><p><p>2、渐变<p>在真实世界种，几乎没有什么是单一色调的。光影无处不在。巧妙的渐变运用是让设计具有深度并让设计在屏幕之上变得真实生动的绝好方法。<p>渐变的关键点是不要太过生硬。如果你使用Photoshop，可在图层样式中添加渐变。你可以随意的设置渐变的起始点；如果你改变了元素的大小，那么渐变也将重新调整。<p><img src=\"/content/uploadfile/201205/thum-18e2999891374a475d0687ca9f989d8320120510060206.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>案例<p>nclud’s website 是渐变运用的经典教案，它告诉我们即使细微的渐变也可以在分割和组织内容版面上取得非常好效果的。<p><img src=\"/content/uploadfile/201205/thum-fe5df232cafa4c4e0f1a0294418e566020120510060205.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>CSS Ninjas 给人的第一眼印象是单调的颜色，但细看之下每种颜色都有着细微的渐变，使其变得具有质感。<p><img src=\"/content/uploadfile/201205/thum-8cda81fc7ad906927144235dda5fdf1520120510060205.jpg\" alt=\"点击查看原图\" border=\"0\" /><p><p>3、高光 <p>高光可以平衡阴影，并且需要在靠近光源的物体边缘上使用。巧妙的设计之下，高光往往被忽略掉，因为你甚至没有注意到它。虽然不是每一处设计都适用，但是一个细小的高光往往可以让界面在光亮度上显得不同。高光越“明晰”，界面呈现上就越显光亮。<p>要细致的体会高光，我们需要放大拉近观察它。添加高光的一个妙计就是在200%或者更大的放大比例下工作，因为原始尺寸之下你很难清楚地观察你所做的一切。<p>案例<p>Icon Dock 以及 Newism 两者都运用一个半透明白色线条以给页面元素的顶端边缘添加一个高光。几乎难以察觉的效果却让设计十分出彩。<p><img src=\"/content/uploadfile/201205/thum-30e62fddc14c05988b44e7c02788e18720120510060204.jpg\" alt=\"点击查看原图\" border=\"0\" /><p><img src=\"/content/uploadfile/201205/thum-ae566253288191ce5d879e51dae1d8c320120510060204.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>你也许已经去过Apple的网站。但是，你也许没有注意到它导航栏中元素底部的漂亮的高光效果，这让导航文字变得凹凸有致。<p><img src=\"/content/uploadfile/201205/thum-62bf1edb36141f114521ec4bb417557920120510060203.jpg\" alt=\"点击查看原图\" border=\"0\" /><p><p>4、阴影基础 <p>就像渐变一样，阴影也是Web设计师手中“常用武器”之一。如果运用恰当，阴影可以很好的增加立体感和质感。关键是不要用过火了。<p>阴影的特征取决与光线的方向和强弱，以及物体和阴影投射面之间的距离。光线越强，阴影随之越深和明显；光线越弱，阴影随之越柔和。<p><img src=\"/content/uploadfile/201205/thum-8df7b73a7820f4aef47864f2a6c5fccf20120510060203.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>案例<p>由于应用起来十分简单，当阴影效果在网上崭露头角时，无数的网站便开始选择使用这种设计。如果经过巧妙运用的话，哪怕是很细微的一处设计也能让空间感油然而生。<p>LinkedIn 在它侧边栏的底部添加了一个非常细微的阴影，从而产生立体感。<p><img src=\"/content/uploadfile/201205/thum-9414a8f5b810972c3c9a0e2860c0753220120510060202.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>Google —— 也许是互联网上最忙碌的页面 —— 依然在它的搜索页上加入细微的阴影效果。<p><img src=\"/content/uploadfile/201205/thum-edab7ba7e203cd7576d1200465194ea820120510060202.jpg\" alt=\"点击查看原图\" border=\"0\" /><p><p>5、阴影进阶<p>你可以用很多方式超越基础的阴影效果，从而赋予一个物体以三维空间感。拉长投影是一种在页面上改变物体空间位置关系的很好的途径。<p>在下面这个例子中，同样一听可乐罐依靠阴影呈现出完全不同的空间位置感觉。<p><img src=\"/content/uploadfile/201205/thum-db3a17f7bcac837ecc1fe2bc630a547320120510060202.jpg\" alt=\"点击查看原图\" border=\"0\" /><p><img src=\"/content/uploadfile/201205/thum-85b6f89b41cae26786ac72365fff771b20120510060201.jpg\" alt=\"点击查看原图\" border=\"0\" /><p><img src=\"/content/uploadfile/201205/thum-64b8299d1597b8a5c7b9cb9c88642f6c20120510060201.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>案例<p>Emotions by Mike 很聪明的用阴影（以及光线）将一个原本是平面的背景变成地面。<p><img src=\"/content/uploadfile/201205/thum-a269962fe1424e1ca3e68c328b9fed6120120510060200.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>Superkix 运用阴影让运动鞋像是“浮”在网站之上。当你改变页面大小的时候，阴影也跟着改变，好像光线在移动一样。<p><img src=\"/content/uploadfile/201205/thum-e89666feb714ab9c3946f28f00c5d8c420120510060208.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>Sofa 在光线和阴影的优秀运用下，白色背景上产生了地面的空间感觉。<p>本文章来源于：5种在设计中应用光线和阴影的简单技法<p>","description":"凡是你目光所及——光线和阴影无处不在。你看到的任何东西都反射回光线，也都或多或少产生阴影。光线和阴影帮助我们去感知我们的所见，并且帮助我们理解材质纹理、尺寸大小以及位置空间。所以，当我们试图让Web页面设计更加自然生动、栩栩如生的时候，对于光线和阴影的透彻理解就显得相当重要了。以下5种利用光线和阴影的技法让你的页面得以重塑，使它们在屏幕上变得引人注目。","category":"杂谈","hot":"n"},{"id":35,"title":"导航设计中的信息结构","date":1338775902,"content":"<p><img src=\"/content/uploadfile/201206/thum-f3ccdd27d2000e3f9255a7e3e2c4880020120604022928.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>在进入今天的主题之前，我们先来探讨导航的重要性，并分析一下门户网站中导航的表现。<p>导航直接影响到公司的财政收入<p>导航会给我们带来哪些好处？导航不光只是提供信息获取的途径，它的设计优劣会直接影响到整个公司财政收入。下面我们看一个例子（以下内容来自alibaba李凡的《设计师的商业意识》）：﻿<p><img src=\"/content/uploadfile/201206/thum-156005c5baf40ff51a327f1c34f2975b20120604022928.jpg\" alt=\"点击查看原图\" border=\"0\" /><p> <p style=\"text-align:center;font-size:12px;\">alibaba大致的广告价格<p>上图反映了阿里巴巴网站大致的广告价格。<p>其实页面上方大量的空间都被导航占据了，见下图：<p><img src=\"/content/uploadfile/201206/thum-799bad5a3b514f096e69bbc4a7896cd920120604022929.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>可以看出，上方的导航非常庞大，在一屏之内，用户几乎看不到搜索结果。<p>用户是来找信息的，第一屏完全看不到结果！！！<p>下面我们要为导航减肥：<p><img src=\"/content/uploadfile/201206/thum-d0096ec6c83575373e3a21d129ff8fef20120604022929.jpg\" alt=\"点击查看原图\" border=\"0\" /><p> <p style=\"text-align:center;font-size:12px;\">导航减肥后的页面<p>这是减肥之后的导航，搜索结果在更高的位置呈现，同时每个产品位的价格也增加了很多，第一个位置的广告位由9.5万增加到12万。<p>导航的改变，直接带来了网站的财政收益。<p>门户网站的导航<p>导航在Web设计中占据着非常重要的位置，但是我们在设计网站时，常常会忽略导航的重要性，特别在门户网站中，这种现象更加普遍。以下为网易财经频道的页面导航：<p><img src=\"/content/uploadfile/201206/thum-032b2cc936860b03048302d991c3498f20120604022930.jpg\" alt=\"点击查看原图\" border=\"0\" /><p> <p style=\"text-align:center;font-size:12px;\">财经频道页面<p>第一幅图是财经频道的首页、第二幅为二级频道股票的首页，第三幅图是大盘的首页。<p>从上图可以看出：<p>· 三张图对比，主导航有了明显的变化，且这个变化是颠覆性的，我们完全没法找出一些关联性的东西。当看到首页时我在想，操盘是股票下面的二级页，但是到了股票的页面，却没有操盘这个导航项了。<p>· 同一页面上不支持多级导航，导航能体现的层级有限。<p>· 打开大盘页面用户更加不知所措，我到底在哪，导航上没有当前选中的导航。<p>· 几乎每点击一次导航，都会在新窗口打开页面，这样给浏览器造成了很大压力。<p>总览各大门户网站，由于信息内容庞大，结构复杂，前期规划不当，信息需要快速迭代等因素，导航上面都会有很多问题。解决导航问题已经刻不容缓。<p>在研究导航问题时，阅读了《Web导航设计》这本书，对书中的内容进行了一些总结归纳。今天主要分享一下“导航设计中的信息结构”这一方面。<p>导航的信息结构<p>什么是信息结构<p>结构能够具体的涵盖页面和内容的特定位置。信息结构指的是网站上页面的规划或是架构图，它是你网站的骨架。信息的结构类型包括：<p>线型结构、网状结构、层级结构、分面结构、逐渐显露的结构。<p>信息结构的具体分析<p>1、线性结构<p>如下图，在此页面可以限制淘宝买家按线性结构完成购买流程。上方的1,2,3,4的步骤很好的引导用户一步一步完成任务，并告知用户所在流程中的位置。<p><img src=\"/content/uploadfile/201206/thum-18e2999891374a475d0687ca9f989d8320120604022931.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>一般的面包屑导航，也是一个线性结构：<p><img src=\"/content/uploadfile/201206/thum-edab7ba7e203cd7576d1200465194ea820120604023300.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>2、网状结构<p>如下图，这是可以由用户设置产出的页面。<p>网状结构的导航没有起点也没有终点，甚至是没有层级或是序列。<p><img src=\"/content/uploadfile/201206/thum-fe5df232cafa4c4e0f1a0294418e566020120604022931.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>   <p>3、层级结构<p>大多数的网站可能都是采用这种结构。以上下级关系排列节点，以展开其层级。<p><img src=\"/content/uploadfile/201206/thum-8cda81fc7ad906927144235dda5fdf1520120604022931.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>以下为网易数码频道的导航：<p><img src=\"/content/uploadfile/201206/thum-30e62fddc14c05988b44e7c02788e18720120604022932.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>4、分面结构<p>分面结构中，一个项目的定位由它的属性类别给出：项目1属于类别a，b，c，但不属于d、它有多个访问点。<p>如下图九天音乐，歌手林宥嘉同时可以在歌手或是排行榜中找到。人们可以从任何顺序取值，从而支持了同一个目标的多种完成方式：<p><img src=\"/content/uploadfile/201206/thum-ae566253288191ce5d879e51dae1d8c320120604022932.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>5、逐渐显露的结构<p>它不是一个事先建立好的信息结构，而是自发形成的，这就是逐渐显露的结构。例如维基百科，它是由每个贡献者参与构建了网站的内容，规模，甚至是方向。<p>从上面的结构类型可以看出，不同的网站类型需要不同的信息结构，比如音乐类的网址，就是需要通过“音乐”、“歌手”等分面结构来呈现。<p>理解和掌握这些结构类型有助于我们更好的把握导航的设计。<p>延伸：信息的组织<p>确定了信息结构以后，我们要考虑的就是如何组织信息。<p>比如汽车频道按字母排序的例子：<p><img src=\"/content/uploadfile/201206/thum-62bf1edb36141f114521ec4bb417557920120604022933.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>信息结构和信息组织设计-卡片分类法<p>卡片分类介绍<p>在进行网站信息结构和组织设计的时候，我们会用到卡片分类法，卡片分类需要：<p>制作一些我们事先预设好的分类，交给用户进行排列；<p>用户可以说出自己的想法，也可以修改分类的名称；<p>鼓励用户遇到难以理解的分类，大声说出来。<p>在进行卡片分类时，一般会有两个阶段：<p>开放阶段，大概需要15个用户，给用户足够的自由度来进行信息分类。<p>封闭阶段，大概需要8名用户，对之前开发阶段的结果进行验证。<p><img src=\"/content/uploadfile/201206/thum-8df7b73a7820f4aef47864f2a6c5fccf20120604022934.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>卡片分类在实际过程中的应用<p>卡片分类定量结果<p>在进行卡片分类时，会用到两个软件usort和ezsort，usort用于导入用户卡片分类的结果，ezsort可以将所有结果都导进去，并产出统计图。<p><img src=\"/content/uploadfile/201206/thum-9414a8f5b810972c3c9a0e2860c0753220120604022927.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>卡片分类统计结果<p>总结<p>这次分享，主要是我对于“web导航设计”这本书部分内容的总结和一些感悟，希望大家在今后的设计中，更加重视导航的设计，在导航设计中找到一些有效的方法。<p>当然导航设计不光只是信息结构或是组织方法，还与导航的交互方式，导航的视觉表现，导航的扩展性，导航的平衡等有很多联系。针对门户类网站，也有它特殊的导航需求，这是我下面需要研究的内容。<p>本文章来源于：导航设计中的信息结构<p>","description":"<img src=\"/content/uploadfile/201206/f3ccdd27d2000e3f9255a7e3e2c4880020120604022928.jpg\" alt=\"导航设计中的信息结构\" border=\"0\" style=\"display:block;margin:0 auto 10px auto;\" />在进入今天的主题之前，我们先来探讨导航的重要性，并分析一下门户网站中导航的表现。导航在Web设计中占据着非常重要的位置，但是我们在设计网站时，常常会忽略导航的重要性，特别在门户网","category":"杂谈","hot":"n"},{"id":31,"title":"知识普及：天煞的HTML 5到底是个什么东西","date":1336961987,"content":"<p>DamnDigital近日制作了一篇由浅入深的知识普及帖，详细介绍了HTML5的方方面面，包括什么是HTML5?HTML5有哪些特质?HTML5/4有什么区别?谁先试水HTML5的?HTML5相关站点有哪些?HTML5的经典案例何处寻?<p><img src=\"/content/uploadfile/201205/thum-f3ccdd27d2000e3f9255a7e3e2c4880020120514024103.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>一、什么是HTML，以及HTML5<p>1. HTML<p>HTML是超文本标记语言的英文缩写，这是一种标记语言，不需要进行编译，直接由浏览器执行。<p>语言就必须有一个语法的规则，如果没有规则，谁知道应该把一个HTML元素以怎样的形式展现给用户呢?目前HTML语言的标准是由 W3C(World Wide Web Consortium)负责制定的。依照规则，无论是何种浏览器，对于相同的HTML代码，应当展现给用户相同的效果。<p>目前HTML语言最新版本为4(HTML4)，此外还有一个可扩展超文本标记语言(XHTML)作为其扩展版本，提供更为丰富的功能和更严谨的语法规范。<p>2. HTML5<p>HTML5草案的前身名为Web Applications 1.0。於2004年被WHATWG提出，於2007年被W3C接纳，并成立了新的HTML工作团队。2008年1月22日，W3C发布了最新的HTML5工作草案，HTML工作组包括AOL、Apple、Google、IBM、 Microsoft、Mozilla、Nokia、Opera等数百个开发上。HTML5中增加了许多新特性，例如嵌入音频、视频和图片的函数、客户端存 储数据、交互式文档等，通过制定如何处理所有HTML元素以及如何从错误中恢复的精确规则，HTML5进一步增强了互动性，并有效减少了开发成本。<p>二、HTML5 有哪些特质<p><img src=\"/content/uploadfile/201205/thum-156005c5baf40ff51a327f1c34f2975b20120514024103.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>我们来看看W3.org列举出来的8个Class技术描述：<p>A. 语义特性(Class：Semantic)<p>HTML5赋予网页更好的意义和结构。更加丰富的标签将随着对RDFa的，微数据与微格式等方面的支持，构建对程序、对用户都更有价值的数据驱动的Web。<p>B. 本地存储特性(Class：OFFLINE &amp; STORAGE)<p>基于HTML5开发的网页APP拥有更短的启动时间，更快的联网速度，这些全得益于HTML5 APP Cache，以及本地存储功能。Indexed DB(HTML5本地存储最重要的技术之一) 和API说明文档。<p>C. 设备兼容特性 (Class：DEVICE ACCESS)<p>从Geolocation 功能的API文档公开以来，HTML5为网页应用开发者们提供了更多功能上的优化选择，带来了更多体验功能的优势。HTML5提供了前所未有的数据与应用接入开放接口。使外部应用可以直接与浏览器内部的数据直接相连，例如视频影音可直接与microphones及摄像头相联<p>D. 连接特性(Class：CONNECTIVITY)<p>更有效的连接工作效率，使得基于页面的实时聊天，更快速的网页游戏体验，更优化的在线交流得到了实现。HTML5拥有更有效的服务器推送技术，Server-Sent Event和WebSockets就是其中的两个特性，这两个特性能够帮助我们实现服务器将数据’推送’到客户端的功能。<p>E. 网页多媒体特性(Class：MULTIMEDIA)<p>支持网页端的Audio、Video等多媒体功能， 与网站自带的APPS、摄像头、影音功能相得益彰。<p>F. 三维、图形及特效特性(Class：3D, Graphics &amp; Effects)<p>基于SVG、Canvas、WebGL及CSS3的3D功能，用户会惊叹于在浏览器中，所呈现的惊人视觉效果。<p>G. 性能与集成特性(Class：Performance &amp; Integration)<p>没有用户会永远等待你的Loading——HML5会通过XMLHttpRequest2等技术，帮助您的Web应用和网站在多样化的环境中更快速的工作。<p>H. CSS3特性(Class：CSS3)<p>在不牺牲性能和语义结构的前提下，CSS3中提供了更多的风格和更强的效果。此外，较之以前的Web排版，Web的开放字体格式(WOFF)也提供了更高的灵活性和控制性。<p>Apple 官方对HTML5的各个特性做了详细并且动态的展示：http://www.apple.com/HTML5/showcase<p>三、HTML5与HTML4的区别<p>A.简化的语法<p>更简单的doctype声明是HTML5里众多新特征之一。现在你只需要写，这就行了。HTML5的语法兼容HTML4和XHTML1，但不兼容SGML。<p>B. 一个替代Flash的新”canvas”标记<p>对于Web用户来说，Flash既是一个惊喜，也是一种痛苦。有很多的Web开发人员对HTML5对Flash产生的威胁很不满。但对于那些忍受着要花几年时间加载和运行的臃肿的Flash视频的人来说，用新的 “canvas” 标记生成视频的技术已经到来。<p>目前， “canvas” 标记并不能提供所有的Flash具有的功能，但假以时日，Flash必将从web上淘汰。我们拭目以待，因为很多人还并不认同这种观点。<p>C. 新的 “header” 和 “footer” 标记<p>HTML5的设计是要更好的描绘网站的解剖结构。这就是为什么这些”header” 和”footer” 等新标记的出现，它们是专门为标志网站的这些部分设计的。在开发网站时，你不在需要用”div”标记来标注网页的这些部分。<p>D. 新的 “section” 和 “article” 标记<p>跟”header” 和 “footer”标记类似，HTML5中引入的新的”section” 和 “article” 标记可以让开发人员更好的标注页面上的这些区域。<p>据推测，除了让代码更有组织外，它也能改善SEO效果，能让搜索引擎更容易的分析你的页面。<p>E.新的 “menu” 和 “figure” 标记<p>新的”menu”标记可以被用作普通的菜单，也可以用在工具条和右键菜单上，虽然这些东西在页面上并不常用。类似的，新的 “figure” 标记是一种更专业的管理页面上文字和图像的方式。当然，你可以用样式表来控制文字和图像，但使用HTML5内置的这个标记更适合。<p>F. 新的 “audio” 和 “video” 标记<p>新的”audio” 和 “video” 标记可能是HTML5中增加的最有用处的两个东西了。正如标记名称，它们是用来嵌入音频和视频文件的。<p>除此之外还有一些新的多媒体的标记和属性，例如”track”，它是用来提供跟踪视频的文字信息的。有了这些标记，HTML5使Web2.0特征变得越来越友好。问题在于，在HTML5还未被广泛的接受之前，Web2.0还是老的Web2.0。<p>G. 全新的表单设计<p>新的 “form” 和 “forminput” 标记对原有的表单元素进行的全新的修改，它们有很多的新属性(以及一些修改)。如果你经常的开发表单，你应该花时间更详细的研究一下。<p>H. 不再使用 “b” 和 “font” 标记<p>对我个人来说，这是一个让我不太理解的改动。我并不认为去除 “b” 和 “font”标记会带来多大的好处。我知道，官方的指导说这些标记可以通过CCS来做更好的处理，但这样一来，为了在文章一两个地方出现的这种标记，你就需要在独立的css和文本两个地方来实现这一的功能，岂不笨拙。也许我们以后会习惯这种方法。<p>i. 不再使用 “frame”, “center”, “big” 标记<p>事实上，我已经记不清曾经何时用过这些标记了，所以，我并不为去除这些标记感到悲哀。相同的原因，有更好的标记能实现它们的功能——这很好，任何作废的标记从标准中剔除都是受欢迎的。<p>四、早期试行者：<p>体验 HTML5 的最好浏览器是那些基于 Webkit 引擎的浏览器(Apple 开发的开源浏览器内核)，如 Chrome 和 Safari，Firefox 不太流畅，即使现在Firefox 9官方声称完美支持HTML5，但是实际应用中，我们发现还是相对于Chrome和Safari欠缺许多。<p>W3C在2011年上半年正式推出了HTML5的初步标准，随之而来是谨慎的Mircosoft 发布了完美支持HTML5的IE9.<p>当然，介于目前浏览器市场玲琅满目，目前除了主流的浏览器的最新版本之外，之前的版本都在或多或少的拒绝HTML5。<p>五、其他HTML5开发相关站点：<p> <img src=\"/content/uploadfile/201205/thum-799bad5a3b514f096e69bbc4a7896cd920120514024104.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>URL: http://phonegap.com/<p>PhoneGap是一个开源的、基于JavaScript语言、用于快速和简便开发手机应用程序的开发框架，用来构建跨平台的使用HTML，CSS和JavaScript的移动应用程序。我们将会放出phoneGap的详细介绍。它是最普及的HTML5 to App的工具。<p> <img src=\"/content/uploadfile/201205/thum-d0096ec6c83575373e3a21d129ff8fef20120514024104.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>URL: http://jsdo.it<p>JSDO.IT是一个js 代码分享的网站，强调社区参与和协作，它可以让程序员，开发者在站内分享自己写的程序代码和作品，也可以在站内相互交流，共享JS代码相关的内容，是通过社交网络或社区为基础来建立的代码分享功能的网站。其界面流畅，带有自动更新的预览面板，可接受开源JS库。另外，它还有一个独特的性能，即可在智能手机中打开浏览器查看的“智能手机预览”命令。这个工具需要用户注册并登陆才能使用。<p> <img src=\"/content/uploadfile/201205/thum-032b2cc936860b03048302d991c3498f20120514024104.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>URL: http://HTML5boilerplate.com/<p>HTML5 Boilerplate 是一个HTML / CSS / js模板，是实现跨浏览器正常化、性能优化，稳定的可选功能如跨域Ajax和Flash的最佳实践。<p>此网站由业界众多专业资深前辈共同发起的一个开源开发模板站点，来帮助大家快速使用HTML5技术开发网站，同时兼容其他各种旧版本的浏览器浏览体验。HTML5 Boilerplate并不是一套框架，他仅仅是一套模板。大家可以把他当作自己的新项目模板，在此基础上建立自己的项目。这一网站志在建立一套简单的模板帮助大家快速的进行开发，一般来说下载了这套模板后，便可以在其上进行修改，测试，查看兼容性浏览等。<p> <img src=\"/content/uploadfile/201205/thum-18e2999891374a475d0687ca9f989d8320120514024105.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>URL: http://proHTML5.com/<p>所有程序员开发者,或是对HTML5有过些许了解的人都听说过有一本程序员编程手册《PRO HTML5 PROGRAMMING》，而此网站是此书的线上官方站点，除了提供书中所提及的关于目前HTML5提供新特性讲解的部分内容，包括使用实例讲解API的调用方法等等，同时还提供更多线上编程方面的指导学习资料，以及学习实践工具。值得收藏。<p> <img src=\"/content/uploadfile/201205/thum-fe5df232cafa4c4e0f1a0294418e566020120514024102.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>URL: http://www.beautyoftheweb.com/<p>在beautyoftheweb网站上,可以下载到40种语言的IE9 RC版(开发者体验版)，通过Bautyoftheweb，开发人员和爱好者即可有规律地对IE9平台上的HTML5实现效果进行预览，目前，此网站上的IE9 RC版可以直接下载，同时还可以看线上指导视频，就算非开发者，程序员也能通过视频，领略到HTML5在IE9平台上带来的良好体验感受。目前所有RC版下载都是免费得，比较开放，透明。可以说，这是微软为了宣传IE9而进行推广的一个网站。<p>本文章来源于：知识普及：天煞的HTML5到底是个什么东西<p>","description":"HTML 5开始大热标志性的事件是苹果前CEO Steve Jobs 公开炮轰Adobe Flash，并指出Flash在移动终端的不利因素，而且HTML 5将获得胜利。顿时IT界、数字营销界、数字媒体界等相关领域的人开始一窝蜂地议论、追捧、打击，HTML5成了当仁不让的明星(就在不久前Adobe宣布停止对Mobile端Flash的开发与更新)。但是很多人都在问：HTML 5是什么?如何鉴定HTML 5产品?","category":"HTML","hot":"n"},{"id":32,"title":"你需要知道的22个HTML5技巧","date":1336965247,"content":"<p>当今科技发展的速度真惊人，稍不留神，就可能无法跟上它的步伐。新一代的HTML-HTML5的发展也不停的带给我们新的惊喜，我们将通过这篇文章向大家介绍一些HTML技巧。<p>1. 新的文档类型（Doctype）<p>&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt;<p>你还在使用上面这个既麻烦又难记的XHTML文档类型吗？ 如果还是这样的话，现在该切换到新的HTML5文档类型了。<p>&lt;!DOCTYPE html&gt;<p>现在只要这么简单的15个字符就可以了。（注意：你的doctype的申明需要出现在你html文件的第一行。）<p>2. 图形（Figure）元素<p>你还在考虑用下面的代码来标记图片吗？<p>&lt;img src=\"path/to/image\" alt=\"About image\" /&gt; &lt;p&gt;Image of Mars. &lt;/p&gt;<p>上面的代码它不能以简单而且富有语义关联的方式与图形的标题关联，因为它仅仅是用段落标记以及图片元素包裹，而 HTML5通过引进&lt;figure&gt;元素，改进了这一点。当结合 &lt;figcaption&gt; 元素使用时，我们就可以将图形标题与图形配对起来。代码如下：<p>&lt;figure&gt; &lt;img src=\"path/to/image\" alt=\"About image\" /&gt; &lt;figcaption&gt; &lt;p&gt;This is an image of something interesting. &lt;/p&gt; &lt;/figcaption&gt; &lt;/figure&gt;<p>3. 重新定义&lt;small&gt;<p>原来你可以利用&lt;small&gt;元素来创建与logo密切相关的副标题。不过，现在HTML5修改了这个用法，&lt;small&gt;元素被重新定义了，或者更恰当地说，它现在用来代表小字或其他边注（如，网站底部的版权声明）。<p>4. 不再需要脚本、链接类型<p>很可能你仍然像下面的代码一样给你的链接和脚本标签添加类型的属性。<p>&lt;link rel=\"stylesheet\" href=\"path/to/stylesheet.css\" type=\"text/css\" /&gt; &lt;script type=\"text/javascript\" src=\"path/to/script.js\"&gt;&lt;/script&gt;<p>在HTML5中，这已经不再需要了。 意味着说这两个标签分别代表着样式和脚本。因此，我们可以将它们的类型属性都删除掉。代码如下：<p>&lt;link rel=\"stylesheet\" href=\"path/to/stylesheet.css\" /&gt; &lt;script src=\"path/to/script.js\"&gt;&lt;/script&gt;<p>5. 使用还是不使用引号<p>记住，HTML5与XHTML不同，如果你不喜欢的话你不必用引号将属性包裹起来。不过，要是你觉得用引号会让你觉得更加舒服的话，当然也不会有任何问题。<p>&lt;p class=myClass id=someId&gt; Start the reactor.&lt;/p&gt;<p>在这点上，你可以自己决定。如果你想要一个结构非常清楚的文档的话，坚持使用引号也挺好的。<p>6. 使你的内容可编辑<p><img src=\"/content/uploadfile/201205/4a47a0db6e60853dedfcfdf08a5ca24920120514041043.png\" alt=\"点击查看原图\" border=\"0\" /><p>HTML5其中一个非常强大的功能就是\"contenteditable\"，顾名思义它将允许用户编辑元素（包括他的子元素）内包含的任何文本内容。它的用途非常广，如，简单的任务清单或是基于wiki的站点也非常实用，此外，它还有一个优势就是利用了本地的存储。<p>&lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;untitled&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt; To-Do List &lt;/h2&gt; &lt;ul contenteditable=\"true\"&gt; &lt;li&gt; Break mechanical cab driver. &lt;/li&gt; &lt;li&gt; Drive to abandoned factory &lt;li&gt; Watch video of self &lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt;<p>或者，按照第五条技巧所说的，你也可以将第九行的代码写成这样（不用引号）：<p>&lt;ul contenteditable=true&gt;<p>7. 电子邮件输入<p>如果我们应用\"电子邮件\"类型来指定输入的形式，我们可以命令浏览器只允许符合有效电子邮件地址结构的字符串输入。虽然说内置的表单验证很快就会到来，但是我们也不能完全依靠这个。比较旧的浏览器不理解这种\"电子邮件\"类型，它们只会简单地返回到普通的文本框。<p>&lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;untitled&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=\"\" method=\"get\"&gt; &lt;label for=\"email\"&gt;Email:&lt;/label&gt; &lt;input id=\"email\" name=\"email\" type=\"email\" /&gt; &lt;button type=\"submit\"&gt; Submit Form &lt;/button&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt;<p><img src=\"/content/uploadfile/201205/fb5c81ed3a220004b71069645f11286720120514041043.png\" alt=\"点击查看原图\" border=\"0\" /><p>在说到浏览器所支持和不支持的元素以及属性时，你必需知道当前所有浏览器都不是那么可靠。例如，Opera只有在你指定name属性时才支持电子邮件验证。不过，它不支持占位符属性（下面即将要讲到的）。最后，虽然你可以使用这种形式的验证，不过不要过分依赖它。<p>8. 占位符<p>此前，我们需要使用JavaScript来创建文本框的占位符。你可以初步设定值属性来看是否合适，但是只要用户删除了该文本，输入的内容就会再次变成空的。占位符属性有效地弥补了这一点。<p>&lt;input name=\"email\" type=\"email\" placeholder=\"doug@givethesepeopleair.com\" /&gt;<p><img src=\"/content/uploadfile/201205/10fb15c77258a991b0028080a64fb42d20120514041043.png\" alt=\"点击查看原图\" border=\"0\" /> <p>9. 本地存储<p>多亏了HTML5的 local storage ，我们可以让高级浏览器\"记住\"我们输入的内容，就算后来浏览器关闭或者重新刷新也不受影响。尽管不是所有的浏览器都支持，但是最关键的 Internet Explorer 8, Safari 4, Firefox 3.5.都支持。<p><img src=\"/content/uploadfile/201205/thum-d0096ec6c83575373e3a21d129ff8fef20120514041044.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>10. 语义性的Header和Footer<p>&lt;div id=\"header\"&gt; ... &lt;/div&gt;  &lt;div id=\"footer\"&gt; ... &lt;/div&gt;<p>上面的代码一去不复返。Divs从根本上来说并没有任何语义结构，即使应用上了ID还是如此。而在HTML5中，我们可以使用&lt;header&gt;和&lt;footer&gt;元素，上面的代码就可以替换为：<p>&lt;header&gt; ... &lt;/header&gt;  &lt;footer&gt; ... &lt;/footer&gt;<p>不过注意不要将这两个元素与网站的头部和脚部混淆起来。它们只是代表它们的容器。<p>11. IE和HTML5<p>IE浏览器目前对HTML5的支持并不好，也是阻碍HTML5的更快普及的一大绊脚石，不过，IE9对HTML5的支持度还是很不错的。IE把HTML5新增的标签都解析成内联元素，而实际上它们是块级元素，所以有必要为它们定义一个样式：<p>header, footer, article, section, nav, menu, hgroup { display: block; }<p>尽管如此，IE还是不能解析这些新增的HTML5标签，这个时候就需要借助Javascript来解决这个问题：<p>document.createElement(\"article\"); document.createElement(\"footer\"); document.createElement(\"header\"); document.createElement(\"hgroup\"); document.createElement(\"nav\"); document.createElement(\"menu\");<p>你可以借助这一段Javascript代码来修复IE更好的解析HTML5<p>&lt;script mce_src=\"http://html5shim.googlecode.com/svn/trunk/html5.js\"&gt;&lt;/script&gt;<p>12. 群组标题（hgroup）<p>假设一个网站有名称、副标题分别用&lt;h1&gt;、&lt;h2&gt;标签来标记，在HTML4中还没有一种能够将两者之间的关系用很好的语义关系来描述的方法，此外，当使用h2在页面中显示其它标题时，在层级方面问题就更多。而使用群组标题hgroup元素，我们可以将这些标题聚集在一起，而不影响文档的整个纲要。<p>&lt;header&gt; &lt;hgroup&gt; &lt;h1&gt; Recall Fan Page &lt;/h1&gt; &lt;h2&gt; Only for people who want the memory of a lifetime. &lt;/h2&gt; &lt;/hgroup&gt; &lt;/header&gt;<p>13.必要（Required）属性<p>端人员肯定做过不少表单验证的项目，其中很重要的一点就是有些输入框的内容是必须填写的，这里就需要使用Javascript来检查。在HTML5中，新增了一个“必须填写”的属性：required。required属性有两种使用方法，第二种方法显得更有结构性，而第一种更简洁。<p>&lt;input type=\"text\" name=\"someInput\" required&gt;<p>或者，更严谨：<p>&lt;input type=\"text\" name=\"someInput\" required=\"required\"&gt;<p>上面两行代码都行得通。用了这行代码之后，并且浏览器支持required属性的话， 输入空白的表单就不会被提交。下面是一个简单的例子，同时我们也添加了占位符属性：<p>&lt;form method=\"post\" action=\"\"&gt; &lt;label for=\"someInput\"&gt; Your Name: &lt;/label&gt; &lt;input type=\"text\" id=\"someInput\" name=\"someInput\" placeholder=\"Douglas Quaid\" required&gt; &lt;button type=\"submit\"&gt;Go&lt;/button&gt; &lt;/form&gt;<p><img src=\"/content/uploadfile/201205/8266e4bfeda1bd42d8f9794eb4ea0a1320120514041044.png\" alt=\"点击查看原图\" border=\"0\" /> <p>如果输入是空的，表单将无法提交，突出显示文本框。<p>   14. 自动对焦（Autofocus）属性<p>同样地，有了HTML5就不再需要用JavaScript方案来解决自动对焦的问题。如果某个输入应该被\"选择\"或被聚焦，我们现在可以使用HTML的自动对焦autofocus属性。<p>&lt;input type=\"text\" name=\"someInput\" placeholder=\"Douglas Quaid\" required autofocus&gt;<p>15. 音频支持<p>我们再也不需要依靠第三方插件来提供音频了。HTML5提供了音频元素&lt;audio&gt;。目前，只有最新的浏览器支持HTML5音频。 此时，最好还是提供一些向后兼容性。<p>&lt;audio autoplay=\"autoplay\" controls=\"controls\"&gt; &lt;source src=\"file.ogg\" /&gt; &lt;source src=\"file.mp3\" /&gt; &lt;a href=\"file.mp3\"&gt;Download this file.&lt;/a&gt; &lt;/audio&gt;<p>为什么会有两种格式的音频文件？因为Firefox和Webkit浏览器所支持的格式存在差异，Firefox只能支持.ogg文件，而Webkit只支持.mp3的文件，解决的办法就是创建两个版本的音频文件，这样就可以兼容Firefox和Webkit的浏览器了，需要注意的是IE不支持该标签。<p>16. 视频支持<p>和&lt;audio&gt;标签一样，HTML5也提供了&lt;video&gt;标签对播放视频文件的支持。YouTube也宣布了一项新的HTML5的视频嵌入。不过有点遗憾，HTML5的规范并没有指定特定的视频解码器，而是让浏览器自己来决定。这就造成了个浏览器的兼容问题，虽然Safari和IE9都支持还H.264格式的视频( Flash 播放器可以可以播放)，Firefox和Opera则支持开源的Theora和Vorbis格式。因此，当显示HTML5视频的时候，也得准备2种格式。<p>&lt;video controls preload&gt;     &lt;source src=\"cohagenPhoneCall.ogv\" type=\"video/ogg\"; codecs=\'vorbis, theora\'\" /&gt;     &lt;source src=\"cohagenPhoneCall.mp4\" type=\"video/mp4; \'codecs=\'avc1.42E01E, mp4a.40.2\'\" /&gt;  &lt;div&gt; your browser is old. &lt;a href=\"cohagenPhoneCall.mp4\"&gt;download this video instead.&lt;/a&gt; &lt;/div&gt;   &lt;/video&gt;<p>17. 视频预先加载<p>你首先需要决定是否需要浏览器来预先加载视频。是否有需要？假设，一个访客进入某个专门用来显示视频的页面，那么就非常有必要预先加载这个页面节省一点等待的时间。你可以通过设置 preload=”preload”来预先加载视频，或者之间添加preload也可以。<p>&lt;video preload=\"preload\"&gt;  ... &lt;/video&gt;<p>18. 显示控件<p>你可能已经注意到，用上面的代码的话，视频将只会显示成一个图片，而没有任何可控制的元件。为了获取这些播放控件，我们必需在视频元素里指定这些控件属性。<p>&gt;&lt;video controls=\"controls\" preload=\"preload\"&gt; ... &lt;/video&gt;<p><img src=\"/content/uploadfile/201205/thum-18e2999891374a475d0687ca9f989d8320120514041044.jpg\" alt=\"点击查看原图\" border=\"0\" /> <p>19. 正则表达式<p>我们可以直接在代码中插入一个正则表达式。<p>&lt;form action=\"\" method=\"post\"&gt; &lt;label for=\"username\"&gt;Create a Username: &lt;/label&gt; &lt;input type=\"text\" name=\"username\" id=\"username\" placeholder=\"4 &lt;&gt; 10\" pattern=\"[A-Za-z]{4,10}\" autofocus required&gt; &lt;button type=\"submit\"&gt;Go &lt;/button&gt; &lt;/form&gt;<p>如果你比较熟悉正则表达式的话就会注意到这个新模式: [A-Za-z]{4,10}只接受大小写字母。这个字符串最少必需有四个字符，最多是十个字符。<p>20. 检测浏览器对属性的支持<p>前面提到过并非所有的浏览器都支持这些属性，那是否有什么方法能够判断浏览器是否能够识别它们呢？这个问题问得非常好，这里给大家介绍两种方式，第一个选择是使用Modernizr来检测，或者你也可以创建并剖析这些元素来看看浏览器都有什么能力。例如，在前面的例子里，如果我们要确定浏览器是否能够执行pattern属性，就可以在页面上添加JavaScript:<p>alert( \'pattern\' in document.createElement(\'input\') ) // boolean;<p>实际上，这是确定浏览器兼容性的一种非常常用的方法。jQuery库利用了这个技巧。上面的代码里，我们创建了一个新的输入元素，并确认pattern属性是否能够被识别。如果能够识别的话，浏览器就支持这个功能，否则就不支持。<p>&lt;script&gt; if (!\'pattern\' in document.createElement(\'input\') ) { // do client/server side validation } &lt;/script&gt;<p>记住，这将需要依靠 JavaScript来实现！<p>21. Mark元素<p>&lt;mark&gt; 元素的主要功能就是在页面中高亮显示那些需要在视觉上向用户突出其重要性的文字。包裹在此标签里的字符串必须与用户当前的行为相关。例如，如果我在一些博客中搜索\"Open your Mind\" ，我可以使用在&lt;mark&gt;标签里使用JavaScript 来包裹每一次动作。<p>&lt;h3&gt; Search Results &lt;/h3&gt; &lt;p&gt; They were interrupted, just after Quato said, &lt;mark&gt;\"Open your Mind\"&lt;/mark&gt;. &lt;/p&gt;<p>22. 何时使用&lt;div&gt;<p>是否还需要使用&lt;div&gt;标签呢？当然需要。例如，如果你想在一个元素里将一段代码包裹住，特别是为了内容的定位，&lt;div&gt; 将会是非常理想的选择。不过，如果不是上述情况而是要包裹博客文章、或者页脚的链接列表，建议你分别使用 &lt;article&gt;和&lt;nav&gt;元素。<p>本文章来源于：你需要知道的22个HTML5技巧<p>","description":"新一代的HTML5的发展也不停的带给我们新的惊喜，我们将通过这篇文章向大家介绍22个HTML5技巧，深入详细的了解HTML5新的特性。","category":"HTML","hot":"n"},{"id":36,"title":"首页设计的可用性和PET","date":1338802028,"content":"<p><img src=\"/content/uploadfile/201206/thum-f3ccdd27d2000e3f9255a7e3e2c4880020120604093127.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>网站的首页是一个让人头疼的东西。有时它看起来很简单：首页就是网站内容的整合，一个产品经理随便从网站里拿点东西出来，就能堆出一个看上去靠谱的首页。也正因此，它往往非常麻烦：很多人都可以发表自己的见解，而这时交互设计师的一些手段（比如流程图、概念图等），在面对首页设计时也难派上用场，以致最终陷入到无尽的争执中。所以，本文希望寻找一些实用的方法一定程度上帮助设计师来决策，也让大家在争执过程也有些共同的依据。<p>首页之所以难设计，我认为因为它不仅要解决用户“能做”的问题，更多时候要解决用户“想做”的问题。“能做”对应的是可用性，相对容易解决，专家评估、可用性测试可以很有效地帮助设计师；而“想做”对应的是PET(Persuation,Emotion,Trust，说服、情感、信任)，可能涉及到心理学，人种学，营销学等陌生的知识，交互设计师在这方面就不再是专家了，但一些经验和方法仍可以有效，下文中会讲到。<p>将可用性和PET分开考虑<p>浏览首页的用户基本分为两种：有目标的用户和无目标的用户。Alan Cooper的“目标导向”理念告诉我们，用户的目标驱动任务，有目标的用户直接开始“任务”，我们只要为他们解决可用性的问题。而那些无目标的用户，他们只是随便逛逛，需要首页的PET足够好，将此类用户“转化”成有目标的用户，尽量避免他们“流失”。<p><img src=\"/content/uploadfile/201206/thum-fb5c81ed3a220004b71069645f11286720120604093128.png\" alt=\"点击查看原图\" border=\"0\" /><p>所以我将浏览首页的用户分为这两类，针对两类用户不同的特点来进行设计，会让我们的思路变得清晰。<p><img src=\"/content/uploadfile/201206/thum-10fb15c77258a991b0028080a64fb42d20120604093128.png\" alt=\"点击查看原图\" border=\"0\" /><p>一些现实例子<p>谷歌首页<p>对于搜索型产品，所有用户都是有明确目标的，即便首页是多么“死板”，因为没有任何干扰，用户都可以迅速进入自己的任务。所以谷歌首页没有任何PET的内容<p><img src=\"/content/uploadfile/201206/thum-d0096ec6c83575373e3a21d129ff8fef20120604093129.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>赶集网(或58同城)<p>这类网站的设计也完全服务于“有目标的用户”，把“无目标用户”无情地抛弃，本人觉得这种设计并不是最高效的方式，因为毕竟浪费掉了大量用户。<p><img src=\"/content/uploadfile/201206/thum-032b2cc936860b03048302d991c3498f20120604093129.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>京东商城<p>对于电子商务网站，存在两种典型的用户情景：<p>· 理性消费者，想要找的东西很明确，或者挑选的范围很小，这就要求首页有很好的可用性，帮助他找到商品，如下图中的蓝色部分就是服务这类用户。<p>· 冲动型消费者，并不知道自己需要什么，只是随便看看有没有合适的或促销的东西可以买，这就要求首页有很好的PET，吸引用户点击，如下图中的红色部分就是服务于这类用户。<p><img src=\"/content/uploadfile/201206/thum-18e2999891374a475d0687ca9f989d8320120604093129.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>倘若京东商城不考虑无目标的用户，也许首页就会长成下面这样：<p>对于想找商品的用户，也许更方便直观了，而对于没有目标的用户，就只能离开了。<p><img src=\"/content/uploadfile/201206/thum-fe5df232cafa4c4e0f1a0294418e566020120604093130.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>人人网<p>对SNS类网站来说，用户大多数时间是在“随便看看大家都在干什么”，当然也有时，用户来到首页进行发表日志，上传照片等目标明确的操作。<p><img src=\"/content/uploadfile/201206/thum-8cda81fc7ad906927144235dda5fdf1520120604093130.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>讨论：“随便看看”是不是一种用户目标？<p>我觉得不是，“随便看看”不能直接驱动任务，故不能用来测试产品可用性；在可用性测试中的任务设计时，随便看看不能作为任务。“随便看看”的过程中，用户决定要做某件事了，这才是用户目标。<p>澄清一些可能存在的误解<p>服务无目标的用户的模块（如上面例子中的红色区域），并不是说不需要可用性，只是在设计的难度上，要把PET做好更难更需要思考，而可用性要求较容易满足。反之亦然。<p>比如京东商城中的促销模块设计，是很典型的服务于无目标用户的模块，PET要求能表现产品质量好，价格便宜，买的人多，存货不多等等难以表现的信息；而可用性只要求商品易浏览，可点击等，任何设计者都不会出错。<p>首页设计中如何协调可用性和PET<p>· 在设计之前，调查分析网站用户，是“有目标”的多，还是“无目标”的多，以确定页面上两类模块的比例。<p>· 一般网站同时兼顾两种用户。但“可用性“和“PET”这两点，存在天然矛盾，前者要求页面清晰，而从后者的角度来说，清晰意味着死板，后者要求页面丰富，而从前者的角度来说，丰富意味着杂乱。故在设计时要注意权衡。<p>· 为解决上述矛盾，那就要求“可用性模块”和“PET模块”要明确区分，可以识别，不能相互掺杂。让两类用户能第一时间关注到需要看的部分。<p>· 可用性是基础，一定要先做好，PET是更高要求，属于上层建筑，切不可为上层建筑放弃基础。<p>设计首页的可用性<p>· 应该尊重习惯用法的时候，不要擅自创新，如采用用户习惯的网站头，包括主导航，全局导航，搜索，LOGO。如下图。<p><img src=\"/content/uploadfile/201206/thum-7afbb1602613ec52b265d7a54ad2733020120604093131.png\" alt=\"点击查看原图\" border=\"0\" /><p>· 若有更多导航–如电子商务网站的商品分类–须在第一屏内出现，突出且易识别。导航中的信息架构，在需要时可用卡片分类法对导航内容进行分类。易迅网的商品分类导航，在左边第一屏最显眼处。<p><img src=\"/content/uploadfile/201206/thum-ae566253288191ce5d879e51dae1d8c320120604093131.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>· 首页整体布局规矩，使用网页栅格系统设计页面，允许页面有合理留白。<p>· 尽量保持页面架构简单，最好不出现两列和三列混排的设计。<p><img src=\"/content/uploadfile/201206/thum-62bf1edb36141f114521ec4bb417557920120604093132.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>· 首页的模块中使用尽可能简单的列表，简单列表更容易被理解和读懂，且设计运营开发成本低。当然，“非对称列表”也有优势，见下图，设计师应该根据用户类型和设计目标来灵活运用。<p><img src=\"/content/uploadfile/201206/thum-9eb60bc8bf2b004e4db7d1cc0d5f1d8c20120604093132.png\" alt=\"点击查看原图\" border=\"0\" /><p>设计首页的PET <p>1. 清晰表现品牌和产品服务类型。这首先实现PET中的Trust，只有用户第一时间了解网站品牌和服务(特别是一些大品牌)，才能 够立即建立用户的信任。但这个实践起来却相当有难度，特别是一些全新的服务，篇幅小了说不清，篇幅大了用户直接略过。这里只能介绍一种方法来验证此目的有没有达到：<p>5秒测试：<p>给一个新用户（目标用户）看首页设计5秒，让它说出：<p>这是什么网站？<p>这个网站提供什么服务？<p>首先吸引你的是什么内容？<p>这个网站和类似竞争对手有什么不一样吗？<p>你对这个网站和它的服务有没有兴趣？<p>然后让用户仔细浏览该首页，再纠正上面的答案。<p>2. 使用吸引人的图片和标题。说白了就是标题党，虽然这招定被广大设计师唾弃，但它的效果绝对不容小觑。<p>3. 使用非对称的设计，有主有次，展现丰富性。但注意，非对称设计会增加认知负担，降低可用性。见上文。<p>4. 利用好数字来说服用户，因为数字“不会说慌”。<p>4.1 电子商务网站中，限量限时促销。如下图中的易迅网首页的截图。<p><img src=\"/content/uploadfile/201206/thum-9414a8f5b810972c3c9a0e2860c0753220120604093133.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>4.2 电子商务网站中，突出价格和价格对比。如下图中团购网站的首页。<p><img src=\"/content/uploadfile/201206/thum-7b6fbd4c592d356e087a0f105375100720120604093133.png\" alt=\"点击查看原图\" border=\"0\" /><p>4.3 用数字来突显“丰富的概念”。如下图是网易爱拍首页的设计。<p><img src=\"/content/uploadfile/201206/thum-d642f8c3d2d6c1ab174d170d2dc8ed7820120604093127.png\" alt=\"点击查看原图\" border=\"0\" /><p>5. 在首页显示其他用户的活动来说服用户(其他用户购买记录，评价，晒单等)。调查显示，让用户信任一个站点的最有效途径，就是在线其他消费者的意见。<p>6. 另外，视觉设计上要符合产品和服务的定位，在情感上与用户拉近距离。<p>7. 页面更新频率，用户需要适时的刺激。太频繁的更新，不仅浪费资源和成本，用户也要不断适应，增加学习成本；而长时间不更新，也会让用户慢慢失去粘性，转化率降低。<p>本文章来源于：首页设计的可用性和PET<p>","description":"<img src=\"/content/uploadfile/201206/f3ccdd27d2000e3f9255a7e3e2c4880020120604093127.jpg\" alt=\"首页设计的可用性和PET\" border=\"0\" style=\"display:block;margin:0 auto 10px auto;\" />网站的首页是一个让人头疼的东西。有时它看起来很简单：首页就是网站内容的整合，一个产品经理随便从网站里拿点东西出来，就能堆出一个看上去靠谱的首页。也正因此，它往往非常麻烦：很多","category":"杂谈","hot":"n"},{"id":37,"title":"浅析：平面与网页设计的差异性","date":1338877624,"content":"<p><img src=\"/content/uploadfile/201206/thum-f3ccdd27d2000e3f9255a7e3e2c4880020120605063109.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>这段时间，一直在做印像派的商品设计，如照片书、台历之类。从网页产品设计转行过来的我，时常在想，平面设计和网页都是设计，但区别又是那么大，那不就与大自然中的猫和老虎一样嘛，它们都属于猫科动物，但又不是同一种生物，有着很大的差别。<p>现在就让我们来分析一下同样作为视觉传达设计，她们之间的差异性。<p>1.视觉元素 <p>在色彩方面平面设计与网页设计使用的色彩模式完全不同，平面设计因为后期的实现依赖于印刷，所以采用CMYK的色彩模式，而网页根据其显像方式使用RGB的色彩模式。平面设计时的色彩运用注重视觉的冲击力及视觉流的引导(在这点上与网页设计中的BANNER设计相类似)，而网页设计(产品类)更注重的是信息结构关系的梳理，如果将色彩运用的过多过强，很容易引起视觉的疲劳感。<p>我们平时在设计过程中，平面设计的字体选用更为自由一些，不用担心后期实现的问题，所有的文字最后都会输出为图形进行印刷，而网页设计就需要考虑的更为全面，并且在字体的选用范围上也很小，为了让输出的成品大小不对服务器造成压力，基于html的特性，所有字体都是根据用户操作系统内默认字体而定的，当然近年随着技术的沿革与发展，这个差距也逐步在缩小，目前通过html5的API可以实现个性化字体的使用而不需要将个性化的字体最终输出为图形，在不增加后端压力的同时，大大提升了用户体验，非常赞。<p>从图形使用上，平面设计比网页设计丰富，表现方式也多样化，特别是对于产品类的网页设计，模块化的设计思路更为明显，在视觉表现上也是如此，平面对于图形的表现是不需要考虑到后期的实现的，在一点上是有目共睹的。在来说一下咱们设计时使用的尺寸单位问题，平面设计在使用尺寸标注时都用的是物理尺寸的概念，比如英寸，厘米，毫米等，而网页使用的像素。<p>2.呈现方式<p><img src=\"/content/uploadfile/201206/thum-156005c5baf40ff51a327f1c34f2975b20120605063109.jpg\" alt=\"点击查看原图\" border=\"0\" /><p> <p>3.信息载体<p><img src=\"/content/uploadfile/201206/thum-799bad5a3b514f096e69bbc4a7896cd920120605063108.jpg\" alt=\"点击查看原图\" border=\"0\" /><p> <p>4.浏览方式<p>平面设计的属于渐进式的浏览方式，无法对整个浏览的过程进行多样化串联，网页设计拥有滚动条下拉、按钮链接跳转等多样化的浏览信息方式，在拥有同样一种信息架构的条件下，信息之间的串联性更为丰富，用户选择信息的自由度更大，但平面设计也自然有其优势所在，比如平时我在设计照片书这类产品的时候，就很明显的发现，这一类的产品在电脑显示器上进行翻阅，不如印刷成为一个真实的书本来翻阅感受要更好一些，并且更具有收藏及纪念意义。<p>5.信息传播<p>平面设计属于比较传统的信息媒介设计，一般会通过张贴、销售、邮寄派送等形式进行传播，这样传播的方式范围小且成本较高，相对而言在这方面网页设计的信息传播能力却非常的强，但依赖于第三方媒介的支持，平面设计却拥有更为广泛的受众人群，不同的年龄层对于纸张或书本的信息接受能力总是强于网络媒体的，毕竟网络信息获取的将会存在一个学习成本，在今后网络信息的不断普及以及终端媒介用户体验的不断提升，在受众人群方面在我看来差距会越来越小。<p>这两种设计形式拥有着不同的用户体验，我们应该根据不同设计内容，选择正确的设计形式提升用户体验，以上这些只是个人对平面与网页设计的一些粗浅认识，也作为抛砖引玉希望大家能分享出自己对于设计的想法，引用一段平面设计大师陈幼坚的一段话“做创意最重要就是定位清晰，如果定位清楚目标明确，很多创意就会自然创造出来。这就好像你想找一个喜欢的姑娘，就跑到酒吧去张望，这太麻烦了。要先确定你要找什么样的女孩子，到酒吧就指，哦，这个，那个。——多简单！”<p>本文章来源于：浅析·平面与网页设计的差异性<p>","description":"<img src=\"/content/uploadfile/201206/f3ccdd27d2000e3f9255a7e3e2c4880020120605063109.jpg\" alt=\"浅析：平面与网页设计的差异性\" border=\"0\" style=\"display:block;margin:0 auto 10px auto;\" />这段时间，一直在做印像派的商品设计，如照片书、台历之类。从网页产品设计转行过来的我，时常在想，平面设计和网页都是设计，但区别又是那么大，那不就与大自然中的猫和老虎一样嘛，","category":"杂谈","hot":"n"},{"id":39,"title":"一分钟即席演讲","date":1338950877,"content":"<p><img src=\"/content/uploadfile/201206/thum-f3ccdd27d2000e3f9255a7e3e2c4880020120606030746.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>随着我们的公司以及我们的团队的日益壮大，我们面对的交际场合也会是越来越多。但在这各色各样的交际场合里我们难免被人临时要求发言，例如：开会，集会，聚会等等一些在你没有任何心理准备的情况下被要求站起来讲两句。那么我们该如何让自己在这样的场合里成功的做一个即席演讲呢？如何让我们在这样的场合里不会有耳红面赤，心跳不已的怯场场景，脑子思维短路一片空白这样尴尬的情况呢？试问我们该如何才能改变这样的场景？避免这样的情况呢？下面和大家分享下自己的学习小积累。<p><img src=\"/content/uploadfile/201206/thum-156005c5baf40ff51a327f1c34f2975b20120606030746.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>无论什么样的场合 ，我们随时都有被要求说两句的“危险”。如果你同意我的观点，为什么不早早地做好站起来说话的准备呢？如果你正在参加一个会议，你为什么不想一想如果你站起来，应该发表什么样的意见以及怎么发表意见呢？<p>那么我们该如何去做这样的准备呢？ <p>一：参加某项集会或聚餐时，事先做好心理准备。<p>例如，在开会当中，不断地问自己，如果现在被请起来讲话，到底要讲些什么。这一次最适合讲述自己熟悉的题材里的哪个方面？对于眼前的其他人提出的那些建议，如何措辞以表示赞同或反对？<p>二：选择你生活背景中有意义的曾经教导过你的、有关人生内涵的经验。然后，把从这些经验中汲取来的思想、概念、感悟等汇集起来，进行符合你习惯的组织和安排，务必做到胸有成竹。<p> 三：考虑演讲时可能遇到的问题。<p>这些问题不仅包括与你演讲有关的，比如可能没有想到一个合适的词语；也包括会场上可能出现的各种情况；还有就是如果你忘记了接下来要讲什么或者你的演讲被陌生人打断你应该怎么办。只有考虑到这些问题并且想好解决的办法，才能称的上是充分的准备。<p>记住一点：所谓真正的准备，是对你将要演讲的题目的深思熟虑。你可以把你的思想写在纸上——寥寥数语即可。当你演讲的时候，这些片断可能有助于你的安排和组织。比如项目开会，或者其它一些什么会议，你都可以拿起手中的笔记录一些重要的信息，疑点或者你觉得对你有帮助的信息，千万不能吝啬你的笔头，俗话说：好记性不如烂笔头。当你记录了这些信息，等你遇到被突如其来的邀请，那么你讲不会出现非常尴尬的不知所措，至少这些信息能帮助到你整理你脑子里零碎的信息。记得有一次和小草聊天的时候他和我分享了一个海马记忆法，其中就有讲到，记忆分两种：一种是深层记忆，一种是浅层记忆。那么当你记录了这些东西之后你记忆即使被埋藏的很深，但是你看到了你所记录的零碎文字它就能帮助你激活深层记忆，让你能成功的做出回应。<p><img src=\"/content/uploadfile/201206/thum-799bad5a3b514f096e69bbc4a7896cd920120606030745.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>总结<p>一：加强心理意识。<p>二：随时准备发表演讲。不要等到被别人叫起来说话的时候，才开始想你的话题。成功的演讲需要精心的准备，有准备的演讲不一定能精彩顺利的进行，但是一个没有任何准备的演讲绝对不会精彩顺利。古训有云：台上一分钟，台下十年功，只有不断的准备不断的练习你才能做到临场被邀请能做到一鸣惊人的举动。<p>三：树立信心，勇于实践。私底下与人交流，对观点进行辩证。扩展知识面，积累有效观点。<p>附加提升演讲能力的说话游戏：<p>道格拉斯和卓别林以及玛丽福特三人，在连续两年间的每天晚上所玩的说话游戏。这并不是普通的消遗性游戏，而是一种所有演说里最困难的练习──站着思考。道格拉斯对游戏方法是这样描述的：<p>“我们三个人各取一张纸条，在每一张纸条上各写一个说话题目，然后把纸条叠好混在一起，三个人轮流抽取，抽到什么题目，就立即针对那个题目发表一分钟的演讲。两年中，我们从来没有重复过相同的题目。一天晚上，我必须针对‘灯罩’这个题目发表一分钟的即席演说。如果你认为这个问题简单，不妨试试看，我可是好不容易才把这一分钟打发过去。<p>长期玩这种游戏的结果，使我们三个人的反应异常敏捷，学会应付各种复杂题目的知识和技巧。更重要的是，面对任何场合，我们都能很快把自己心中的想法、知识整理起来，也就是说，我们已经学会了‘站起来思考’的方法。”<p>本文章来源于：一分钟即席演讲<p>","description":"<img src=\"/content/uploadfile/201206/f3ccdd27d2000e3f9255a7e3e2c4880020120606030746.jpg\" alt=\"一分钟即席演讲\" border=\"0\" style=\"display:block;margin:0 auto 10px auto;\" />随着我们的公司以及我们的团队的日益壮大，我们面对的交际场合也会是越来越多。但在这各色各样的交际场合里我们难免被人临时要求发言，例如：开会，集会，聚会等等一些在你没有任何心理准备的情况下","category":"杂谈","hot":"n"},{"id":40,"title":"用CSS画三角形","date":1338968020,"content":"<p>1、新建一个元素，随便什么元素，不过我习惯性的会用块元素来做。如果行内元素就display:block它。<p>&lt;div class=\"triangle\"&gt;&lt;/div&gt;<p>2、把它的宽高设置为height:0px; width:0px;<p>3、设置边框border属性，用来实现三角形。<p>首先要了解border具体是怎么样的，我写了一个这样的样式：<p>border:50px solid #000; border-color:#f00 #000 #f0f #00f;<p>在FF下面显示效果如下：<p><img src=\"/content/uploadfile/201206/f3ccdd27d2000e3f9255a7e3e2c4880020120606073821.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>出现4个三角形合并成一个正方形。到这里就很清晰了，只要把想要的保留，其它的设置为透明就可以达到三角形的效果，那么：<p>border:50px solid #000; border-color:#f00 transparent transparent transparent;<p>在FF就可以看到一个红色三角形如下：<p><img src=\"/content/uploadfile/201206/156005c5baf40ff51a327f1c34f2975b20120606073821.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>但是IE呢，尤其是坑爹的IE6会怎样？ 如图：<p><img src=\"/content/uploadfile/201206/799bad5a3b514f096e69bbc4a7896cd920120606073821.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>这是因为它不支持transparent，所以不会透明，那么可以这样：<p>border:50px solid #000; border-color:#f00 transparent transparent transparent; border-style:solid dashed dashed dashed;<p>在你想它透明的地方对应的把border-style设置为dashed，IE6就可以达到跟FF一样的效果了。<p> 那这样也就只是实现了4个方向的三角形，那如果要直角对着45斜线方向的呢？那么可以用两个正方向的三角形并在一起来实现，如下图：<p><img src=\"/content/uploadfile/201206/d0096ec6c83575373e3a21d129ff8fef20120606073821.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>代码：<p>border:50px solid #000; border-color:#f00 #000 transparent transparent; border-style:solid solid dashed dashed;<p>只要把颜色统一，就形成一个45斜线方向三角形，而在IE6却会是这样一种显示：<p><img src=\"/content/uploadfile/201206/032b2cc936860b03048302d991c3498f20120606073822.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>这是因为IE6有个行高撑开了，把行高设置为0就跟FF一样了：line-height:0px;<p>本文章来源于：用CSS画三角形<p>","description":"设置边框border属性，用来实现三角形。","category":"CSS","hot":"n"},{"id":42,"title":"HTML5的Canvas帮助手册","date":1339553484,"content":"<p>canvas.getContext(\"2d\") 是 CanvasRenderingContext2D 对象<p><p>CanvasRenderingContext2D 对象的属性<p><p>canvas 属性<p>这个环境可以绘制于其上的 Canvas 元素。<p>fillStyle 属性<p>用来填充路径的当前的颜色、模式或渐变。这个属性可以设置为一个字符串或者一个 CanvasGradient 对象 或 CanvasPattern 对象。当设置为一个字符串时，它被解析为一个 CSS 颜色值并且用来进行实心填充。当设置为一个 CanvasGradient 或 CanvasPattern 对象，通过使用指定的渐变或模式来完成填充。<p>globalAlpha 属性<p>指定在画布上绘制的内容的不透明度。这个值的范围在 0.0（完全透明）和 1.0（完全不透明）之间。默认值为 1.0。<p>globalCompositeOperation 属性<p>指定颜色如何与画布上已有的颜色组合（合成）。如需更多细节，请参阅 globalCompositeOperation 属性参考页。<p>lineCap 属性<p>指定线条的末端如何绘制。合法的值是 \"butt\"、\"round\" 和 \"square\"。默认值是 \"butt\"。如需更多细节，请参阅 lineCap 属性参考页。<p>lineJoin 属性<p>指定两条线条如何连接。合法的值是 \"round\"、\"bevel\" 和 \"miter\"。默认值是 \"miter\"。如需更多细节，请参阅 lineJoin 属性参考页。<p>lineWidth 属性<p>指定了画笔（绘制线条）操作的线条宽度。默认值是 1.0，并且这个属性必须大于 0.0。较宽的线条在路径上居中，每边有线条宽的一半。<p>miterLimit 属性<p>当 lineJoin 属性为 \"miter\" 的时候，这个属性指定了斜连接长度和线条宽度的最大比率。如需更多细节，请参阅 miterLimit 属性参考页。<p>shadowBlur 属性<p>指定羽化阴影的程度。默认值是 0。阴影效果得到 safari 的支持，但是并没有得到 FireFox 1.5 或 Opera 9 的支持。<p>shadowColor 属性<p>把阴影的颜色指定为一个 CSS 字符串或 Web 样式字符串，并且可以包含一个 alpha 部分来表示透明度。默认值是 black。阴影效果得到 Safari 的支持，但是并没有得到 FireFox 1.5 或 Opera 9 的支持。<p>shadowOffsetX, shadowOffsetY 属性&lt;/p&gt;<p>指定阴影的水平偏移和垂直偏移。较大的值使得阴影化的对象似乎漂浮在背景的较高位置上。默认值是 0。阴影效果得到 Safari 的支持，但是并没有得到 FireFox 1.5 或 Opera 9 的支持。<p>strokeStyle 属性<p>指定了用于画笔（绘制）路径的颜色、模式和渐变。这个属性可能是一个字符串，或者一个 CanvasGradient 对象 或 CanvasPattern 对象。如果是一个字符串，它被解析为一个 CSS 颜色值，并且画笔用所得的实色来绘制。如果这个属性的值是一个 CanvasGradient 对象或 CanvasPattern 对象，画笔使用这个渐变或模式来实现。<p><p>CanvasRenderingContext2D 对象的方法<p><p>         <p>       方法       描述     <p>     <p>       arc()       用一个中心点和半径，为一个画布的当前子路径添加一条弧线。     <p>     <p>       arcTo()       使用目标点和一个半径，为当前的子路径添加一条弧线。     <p>     <p>       beginPath()       开始一个画布中的一条新路径（或者子路径的一个集合）。     <p>     <p>       bezierCurveTo()       为当前的子路径添加一个三次贝塞尔曲线。     <p>     <p>       clearRect()       在一个画布的一个矩形区域中清除掉像素。     <p>     <p>       clip()       使用当前路径作为连续绘制操作的剪切区域。     <p>     <p>       closePath()       如果当前子路径是打开的，就关闭它。     <p>     <p>       createLinearGradient()       返回代表线性颜色渐变的一个 CanvasGradient 对象。     <p>     <p>       createPattern()       返回代表贴图图像的一个 CanvasPattern 对象。     <p>     <p>       createRadialGradient()       返回代表放射颜色渐变的一个 CanvasGradient 对象。     <p>     <p>       drawImage()       绘制一幅图像。     <p>     <p>       fill()       使用指定颜色、渐变或模式来绘制或填充当前路径的内部。     <p>     <p>       fillRect()       绘制或填充一个矩形。     <p>     <p>       lineTo()       为当前的子路径添加一条直线线段。     <p>     <p>       moveTo()       设置当前位置并开始一条新的子路径。     <p>     <p>       quadraticCurveTo()       为当前路径添加一条贝塞尔曲线。     <p>     <p>       rect()       为当前路径添加一条矩形子路径。     <p>     <p>       restore()       为画布重置为最近保存的图像状态。     <p>     <p>       rotate()       旋转画布。     <p>     <p>       save()       保存 CanvasRenderingContext2D 对象的属性、剪切区域和变换矩阵。     <p>     <p>       scale()       标注画布的用户坐标系统。     <p>     <p>       stroke()       沿着当前路径绘制或画一条直线。     <p>     <p>       strokeRect()       绘制（但不填充）一个矩形。     <p>     <p>       translate()       转换画布的用户坐标系统。     <p>     <p><p>arc()<p>方法使用一个中心点和半径，为一个画布的当前子路径添加一条弧。<p>语法：<p>arc(x, y, radius, startAngle, endAngle, counterclockwise)<p>参数：<p>         <p>       参数       描述     <p>     <p>       x, y       描述弧的圆形的圆心的坐标。     <p>     <p>       radius       描述弧的圆形的半径。     <p>     <p>       startAngle, endAngle       <p>沿着圆指定弧的开始点和结束点的一个角度。这个角度用弧度来衡量。<p>         <p>沿着 X 轴正半轴的三点钟方向的角度为 0，角度沿着逆时针方向而增加。<p>      <p>     <p>       counterclockwise       弧沿着圆周的逆时针方向（TRUE）还是顺时针方向（FALSE）遍历。     <p>     <p>描述：<p>这个方法的头 5 个参数指定了圆周的一个起始点和结束点。调用这个方法会在当前点和当前子路径的起始点之间添加一条直线。接下来，它沿着圆周，在子路径的起始点和结束点之间添加弧。<p>最后一个 counterclockwise 参数指定了圆应该沿着哪个方向遍历来连接起始点和结束点。这个方法将当前位置设置为弧的终点。<p><p>arcTo() <p>方法使用使用切点和一个半径，来为当前子路径添加一条圆弧。<p>语法：<p>arc(x1, y1, x2, y2, radius)<p>参数：<p>         <p>       参数       描述     <p>     <p>       x1, y1       点 P1 的坐标。     <p>     <p>       x2, y2       点 P2 的坐标。     <p>     <p>       radius       定义圆弧的圆的半径。     <p>     <p>描述：<p>这个方法为当前的子路径添加了一条圆弧，但是，它所描述的这条圆弧和 arc() 方法所描述的圆弧大不相同。添加给路径的圆弧是具有指定 radius 的圆的一部分。该圆弧有一个点与当前位置到 P1 的线段相切，还有一个点和从 P1 到 P2 的线段相切。这两个切点就是圆弧的起点和终点，圆弧绘制的方向就是连接这两个点的最短圆弧的方向。<p>在很多常见的应用中，圆弧开始于当前位置而结束于 P2，但情况并不总是这样。如果当前的位置和圆弧的起点不同，这个方法添加了一条从当前位置到圆弧起点的直线。这个方法总是将当前位置设置为圆弧的终点。<p>实例：<p>c.moveTo(10,10);       //在左上方开始 c.lineTo(90,10);       //到达圆角开始点的水平线 c.arcTo(100,10,100,20,10);    //圆角 c.lineTo(100,100);     //到达右下方的垂直线<p>可以用下面的代码绘制一个矩形的右上角（圆角）：<p><p>beginPath()<p>方法在一个画布中开始子路径的一个新的集合。<p>语法：<p>beginPath()<p>描述：<p>beginPath() 丢弃任何当前定义的路径并且开始一条新的路径。它把当前的点设置为 (0,0)。<p>当一个画布的环境第一次创建，beginPath() 方法会被显式地调用。<p>bezierCurveTo()<p>方法在一个画布中开始子路径的一个新的集合。<p>语法：<p>bezierCurveTo(cpX1, cpY1, cpX2, cpY2, x, y)<p>参数：<p>         <p>       参数       描述     <p>     <p>       cpX1, cpY1       和曲线的开始点（当前位置）相关联的控制点的坐标。     <p>     <p>       cpX2, cpY2       和曲线的结束点相关联的控制点的坐标。     <p>     <p>       x, y       曲线的结束点的坐标。     <p>     <p>描述：<p>bezierCurveTo() 为一个画布的当前子路径添加一条三次贝塞尔曲线。这条曲线的开始点是画布的当前点，而结束点是 (x, y)。两条贝塞尔曲线控制点 (cpX1, cpY1) 和 (cpX2, cpY2) 定义了曲线的形状。当这个方法返回的时候，当前的位置为 (x, y)。<p><p>clearRect()<p>方法删除一个画布的矩形区域。<p>语法：<p>clearRect(x, y, width, height)<p>参数：<p>         <p>       参数       描述     <p>     <p>       x, y       矩形的左上角的坐标。     <p>     <p>       width, height       矩形的尺寸。     <p>     <p>描述：<p>clearRect() 方法擦除了指定的矩形，并且用一个透明的颜色填充它。<p><p>clip()<p>方法设置一个画布的剪切路径。<p>语法：<p>clip()<p>描述：<p>clip() 方法用当前剪切路径来剪切当前路径，然后使用剪切后的路径作为新的剪切路径。注意，没有方法来扩大剪切路径。如果想要一个临时的剪切路径，应该先调用 save() 以便使用 restore() 恢复最初的剪切路径。一个画布的默认剪切路径就是画布的矩形自身。<p><p>closePath()<p>方法关闭一条打开的子路径。<p>语法：<p>closePath()<p>描述：<p>如果画布的子路径是打开的，closePath() 通过添加一条线条连接当前点和子路径起始点来关闭它。<p>如果子路径已经闭合了，这个方法不做任何事情。<p>一旦子路径闭合，就不能再为其添加更多的直线或曲线了。要继续向该路径添加，需要通过调用 moveTo() 开始一条新的子路径。<p>提示和注释<p>注释：不需要在勾勒或填充一条路径之前调用 closePath()。当填充的时候（并且当你调用 clip() 的时候），路径是隐式闭合的。<p><p>createLinearGradient()<p>方法创建一条线性颜色渐变。<p>语法：<p>createLinearGradient(xStart, yStart, xEnd, yEnd)<p>参数：<p>         <p>       参数       描述     <p>     <p>       xStart, yStart       渐变的起始点的坐标。     <p>     <p>       xEnd, yEnd       渐变的结束点的坐标。     <p>     <p>返回值：<p>表示一个线性颜色渐变的一个 CanvasGradient 对象。<p>描述：<p>这个方法创建并返回了一个新的 CanvasGradient 对象，它在指定的起始点和结束点之间线性地内插颜色值。注意，这个方法并没有为渐变指定任何颜色。使用返回对象的 addColorStop() 来做到这一点。要使用一个渐变来勾勒线条或填充区域，只需要把 CanvasGradient 对象赋给 strokeStyle 属性或 fillStyle 属性即可。<p><p>createPattern()<p>方法为贴图图像创建一个模式。<p>语法：<p>createPattern(image, repetitionStyle)<p>参数：<p>         <p>       参数       描述     <p>     <p>       image       <p>需要贴图的图像。<p>         <p>这个参数通常是一个 Image 对象，但是也可以使用一个 Canvas 元素。<p>      <p>     <p>       repetitionStyle       说明图像如何贴图。可能的值如下所示：<p>         \"repeat\" - 在各个方向上都对图像贴图。默认值。<p>         \"repeat-x\" - 只在 X 方向上贴图。<p>         \"repeat-y\" - 只在 Y 方向上贴图。<p>         \"no-repeat\" - 不贴图，只使用它一次。     <p>     <p>返回值：<p>表示模式的一个 CanvasPattern 对象。<p>描述：<p>createPattern() 方法创建并返回一个 CanvasPattern 对象，该对象表示一个贴图图像所定义的模式。要使用一个模式来勾勒线条或填充区域，可以把一个 CanvasPattern 对象用作 strokeStyle 属性或 fillStyle 属性的值。<p><p>createRadialGradient()<p>方法创建一条放射颜色渐变。<p>语法：<p>createLinearGradient(xStart, yStart, radiusStart, xEnd, yEnd, radiusEnd)<p>参数：<p>         <p>       参数       描述     <p>     <p>       xStart, yStart       开始圆的圆心的坐标。     <p>     <p>       radiusStart       开始圆的直径。     <p>     <p>       xEnd, yEnd       结束圆的圆心的坐标。     <p>     <p>       radiusEnd       结束圆的直径。     <p>     <p>返回值：<p>表示一个放射性颜色渐变的一个 CanvasGradient 对象。<p>描述：<p>这个方法创建并返回了一个新的 CanvasGradient 对象，该对象在两个指定圆的圆周之间放射性地插值颜色。注意，这个方法并没有指定任何用来渐变的颜色。使用返回对象的 addColorStop() 方法做到这一点。要使用一个渐变来勾勒线条或填充区域，只需要把 CanvasGradient 对象赋给 strokeStyle 属性或 fillStyle 属性即可。<p>放射性渐变的绘制方法：<p>使用第一个圆的圆周在偏移 0 处的颜色和第二个圆的圆周在偏移 1 处的颜色，在两个位置之间的圆上插入颜色值（红色、绿色、蓝色和 alpha）。<p><p>drawImage()<p>方法绘制一幅图像。<p>语法：<p>drawImage(image, x, y) drawImage(image, x, y, width, height) drawImage(image, sourceX, sourceY, sourceWidth, sourceHeight,           destX, destY, destWidth, destHeight)<p>参数：<p>         <p>       参数       描述     <p>     <p>       image       所要绘制的图像。这必须是表示 &lt;img&gt; 标记或者屏幕外图像的 Image 对象，或者是 Canvas 元素。     <p>     <p>       x, y       要绘制的图像的左上角的位置。     <p>     <p>       width, height       图像所应该绘制的尺寸。指定这些参数使得图像可以缩放。     <p>     <p>       sourceX, sourceY       图像将要被绘制的区域的左上角。这些整数参数用图像像素来度量。     <p>     <p>       sourceWidth, sourceHeight       图像所要绘制区域的大小，用图像像素表示。     <p>     <p>       destX, destY       所要绘制的图像区域的左上角的画布坐标。     <p>     <p>       destWidth, destHeight       图像区域所要绘制的画布大小。     <p>     <p>描述：<p>drawImage() 方法有 3 个变形。第一个变形把整个图像复制到画布，将其放置到指定点的左上角，并且将每个图像像素映射成画布坐标系统的一个单元。第二个变形也把整个图像复制到画布，但是允许您用画布单位来指定想要的图像的宽度和高度。第三个变形则是完全通用的，它允许您指定图像的任何矩形区域并复制它，对画布中的任何位置都可进行任何的缩放。<p>传递给 drawImage() 方法的图像必须是 Image 对象或 Canvas 元素。一个 Image 对象能够表示文档中的一个 &lt;img&gt; 标记或者使用 Image() 构造函数所创建的一个屏幕外图像。<p><p>fill()<p>方法填充路径。<p>语法：<p>fill()<p>描述：<p>fill() 方法使用 fillStyle 属性所指定的颜色、渐变和模式来填充当前路径。这一路径的每一条子路径都单独填充。任何未闭合的子路径都被填充，就好像已经对他么调用了 closePath() 方法一样（但是，注意，实际上没有这么让子路径成为闭合的）。<p>画布使用“非零匝数规则”来确定哪个点在路径的内部，而哪个点在路径的外部。这一规定的细节超出了本参考页的范围，但是，它们通常只和那些与自身相交的复杂路径相交。<p>填充一条路径并不会清除该路径。你可以在调用 fill() 之后再次调用 stroke()，而不需要重新定义该路径。<p><p>fillRect()<p>方法填充一个矩形。<p>语法：<p>fillRect(x, y, weight, height)<p>参数：<p>         <p>       参数       描述     <p>     <p>       x, y       矩形的左上角的坐标。     <p>     <p>       weight, height       矩形的大小。     <p>     <p>描述：<p>fillRect() 方法使用 fillStyle 属性所指定的颜色、渐变和模式来填充指定的矩形。<p>fillRect() 方法的当前实现还清除了路径，就好像 beginPath() 已经调用了。这一令人惊讶的行为可能不会标准化，因此不应该指望它。<p><p>lineTo()<p>方法为当前子路径添加一条直线。<p>语法：<p>lineTo(x, y)<p>参数：<p>         <p>       参数       描述     <p>     <p>       x, y       直线的终点的坐标。     <p>     <p>描述：<p>lineTo() 方法为当前子路径添加一条直线。这条直线从当前点开始，到 (x, y) 结束。当方法返回时，当前点是 (x,y)。<p><p>moveTo()<p>方法设置当前位置并开始一条新的子路径。<p>语法：<p>moveTo(x, y)<p>参数：<p>         <p>       参数       描述     <p>     <p>       x, y       新的当前点的坐标。     <p>     <p>描述：<p>moveTo() 方法将当前位置设置为 (x, y) 并用它作为第一点创建一条新的子路径。如果之前有一条子路径并且它包含刚才的那一点，那么从路径中删除该子路径。<p><p>quadraticCurveTo()<p>方法为当前路径添加一条贝塞尔曲线。<p>语法：<p>quadraticCurveTo(cpX, cpY, x, y)<p>参数：<p>         <p>       参数       描述     <p>     <p>       cpX, cpY       控制点的坐标。     <p>     <p>       x, y       曲线终点的坐标。     <p>     <p>描述：<p>quadraticCurveTo() 方法为当前的子路径添加一条贝塞尔曲线。这条曲线从当前点开始，到 (x,y) 结束。控制点 (cpX,cpY) 说明了这两个点之间的曲线的形状（贝塞尔曲线的数学原理超过了本参考页的范围）。<p>当 quadraticCurveTo() 方法返回时，当前位置是 (x,y)。<p><p>rect()<p>方法为当前路径添加一条矩形子路径。<p>语法：<p>quadraticCurveTo(x, y, width, height)<p>参数：<p>         <p>       参数       描述     <p>     <p>       x, y       矩形的左上角的坐标。     <p>     <p>       width, height       矩形的大小。     <p>     <p>描述：<p>rect() 方法为路径添加了一个矩形。这个矩形是路径的一个子路径并且没有和路径中的任何其他子路径相连。<p>当 rect() 方法返回时，当前位置是 (0,0)。<p><p>restore()<p>方法将绘图状态置为保存值。<p>语法：<p>restore()<p>描述：<p>restore() 方法从栈中弹出存储的图形状态并恢复 CanvasRenderingContext2D 对象的属性、剪切路径和变换矩阵的值。<p>请参阅 save() 方法了解更多信息。<p><p>rotate() <p>方法旋转画布的坐标系统。<p>语法：<p>rotate(angle)<p>参数：<p>         <p>       参数       描述     <p>     <p>       angle       旋转的量，用弧度表示。正值表示顺时针方向旋转，负值表示逆时针方向旋转。     <p>     <p>描述：<p>rotate() 方法通过指定一个角度，改变了画布坐标和 Web 浏览器中的 &lt;Canvas&gt; 元素的像素之间的映射，使得任意后续绘图在画布中都显示为旋转的。它并没有旋转 &lt;Canvas&gt; 元素本身。注意，这个角度是用弧度指定的。<p>提示：如需把角度转换为弧度，请乘以 Math.PI 并除以 180。<p><p>save()<p>方法保存当前图像状态的一份拷贝。<p>语法：<p>save()<p>描述：<p>save() 方法把当前状态的一份拷贝压入到一个保存图像状态的栈中。这就允许您临时地改变图像状态，然后，通过调用 restore() 来恢复以前的值。<p>一个画布的图形状态包含了 CanvasRenderingContext2D 对象的所有属性（除了只读的画布属性以外）。它还包含了一个变换矩阵，该矩阵是调用 rotate()、scale() 和 translate() 的结果。另外，它包含了剪切路径，该路径通过 clip() 方法指定。可是要注意，当前路径和当前位置并非图形状态的一部分，并且不会由这个方法保存。<p><p>scale()<p>方法标注画布的用户坐标系统。<p>语法：<p>scale(sx, sy)<p>参数：<p>         <p>       参数       描述     <p>     <p>       sx, sy       水平和垂直的缩放因子。     <p>     <p>描述：<p>scale() 方法为画布的当前变换矩阵添加一个缩放变换。缩放通过独立的水平和垂直缩放因子来完成。例如，传递一个值 2.0 和 0.5 将会导致绘图路径宽度变为原来的两倍，而高度变为原来的 1/2。指定一个负的 sx 值，会导致 X 坐标沿 Y 轴对折，而指定一个负的 sy 会导致 Y 坐标沿着 X 轴对折。<p><p>stroke()<p>方法绘制当前路径。<p>语法：<p>stroke()<p>描述：<p>stroke() 方法绘制当前路径的边框。路径定义的几何线条产生了，但线条的可视化取决于 strokeStyle、lineWidth、lineJoin、lineCap 和 miterLimit 等属性。<p>术语“勾勒”，指的是钢笔或笔刷的画笔。它意味着“画......轮廓”。和 stroke() 方法相对的是 fill()，该方法会填充路径的内部区域而不是勾勒出路径的边框。<p><p>strokeRect()<p> 方法用于在单选按钮上模拟一次鼠标点击：<p>语法：<p>strokeRect(x, y, width, height)<p>描述：<p>该方法按照指定的位置和大小绘制一个矩形的边框（但并不填充矩形的内部）。线条颜色和线条宽度由 strokeStyle 和 lineWidth 属性指定。矩形边角的形状由 lineJoin 属性指定。<p>strokeRect() 的当前实现会清晰化路径，就好像  已经调用过了。这一令人吃惊的行为可能不会标准化，所以不能指望它。<p><p>translate()<p> 方法转换画布的用户坐标系统。<p>语法：<p>translate(dx, dy)<p>参数：<p>         <p>       参数       描述     <p>     <p>       dx, dy       转换的量的 X 和 Y 大小。     <p>     <p>描述：<p>translate() 方法为画布的变换矩阵添加水平的和垂直的偏移。参数 dx 和 dy 添加给后续定义路径中的所有点。<p><p>本文章来源于：HTML5的Canvas帮助手册<p>","description":"canvas.getContext(\"2d\") 是 CanvasRenderingContext2D 对象","category":"HTML","hot":"y"},{"id":43,"title":"一个专业的前端开发人员是怎么修炼成的？","date":1341797011,"content":"<p>Web前端开发是从网页制作演变而来的，名称上有很明显的时代特征，现在网页上软件化的交互形式为用户提供了更好的使用体验，这些都是基于前端技术实现的。<p>以前会Photoshop和Dreamweaver就可以制作网页，现在只掌握这些已经远远不够了。无论是开发难度上，还是开发方式上，现在的网页制作都更接近传统的网站后台开发，所以现在不再叫网页制作，而是叫Web前端开发。Web前端开发在产品开发环节中的作用变得越来越重要。Web前端开发是一项很特殊的工作，涵盖的知识面非常广，既有具体的技术，又有抽象的理念。简单地说，它的主要职能就是把网站的界面更好地呈现给用户，把一流的web交互效果给展现出来，用户体验效果达到最好。<p>如何才能做得更好呢？<p>第一，必须掌握基本的Web前端开发技术，其中包括：CSS、HTML、DOM、BOM、Ajax、JavaScript等，在掌握这些技术的同时，还要清楚地了解它们在不同浏览器上的兼容情况、渲染原理和存在的Bug。<p>第二，在一名合格的前端工程师的知识结构中，网站性能优化、SEO和服务器端的基础知识也是必须掌握的。<p>第三，必须学会运用各种工具进行辅助开发。<p>第四，除了要掌握技术层面的知识，还要掌握理论层面的知识，包括代码的可维护性、组件的易用性、分层语义模板和浏览器分级支持，等等。<p>可见，看似简单的网页制作，如果要做的好也不简单。这就是前端开发的特点，也是让很多人困惑的原因。如此繁杂的知识体系让新手学习起来无从下手，对于老手来说，也时常不知道下一步该学什么。<p>代码质量是前端开发中应该重点考虑的问题之一。例如，实现一个网站界面可能会有无数种方案，但有些方案的维护成本会比较高，有些方案会存在性能问题，而有些方案则更易于维护，而且性能也比较好。这里的关键影响因素就是代码质量。CSS、HTML、JavaScript这三种前端开发语言的特点是不同的，对代码质量的要求也不同，但它们之间又有着千丝万缕的联系。编写高质量的代码，而不是垃圾的代码，让你的网站性能提到最高，维护成本最低，这样来权衡代码的质量。<p>以上主要介绍了，前端开发这个职位，无论你现在是专业的网页重构，网页制作人员，还是专业的前端开发专门JavaScript人员，以后发展要学的东西还会越来越多，要求越来越高。<p>本文章来源于：一个专业的前端开发人员是怎么制作成的？<p>","description":"Web前端开发是从网页制作演变而来的，名称上有很明显的时代特征，现在网页上软件化的交互形式为用户提供了更好的使用体验，这些都是基于前端技术实现的。","category":"杂谈","hot":"n"},{"id":44,"title":"职场面试的14个必知技巧","date":1341800125,"content":"<p>1.问候时最好点名道姓。<p>迈进会客室的门，你的第一句话可能是：“你好，见到你很高兴。”但这却不如说：“李经理，你好，见到你很高兴。”后者比前者要热情得多。<p>2.若对方没请你坐下，你最好站着。<p>坐下后不应掏烟，如对方请你抽烟，你应说：“谢谢。”把烟灰和火柴头弄到地板上，是很不得体的。<p>3.不要急于出示你随身带的资料、书信或礼物。<p>只有在你提及了这些东西，并已引起对方兴趣时，才是出示他们的最好时机。当对方询问你所携带资料中的有关问题时，你应给予详细的解释或说明。<p>4.主动开始谈话，珍惜会见时间。<p>尽管对方已经了解到你的一些情况和来访目的，你仍有必要主动开口。你可再次对某些问题进行强调和说明。也是礼貌的需要，也反映一个人的精神面貌。<p>5.保持相应的热情。<p>在谈话时，你若对某一问题没有倾注足够的热情，对方会马上失去谈这个问题的兴趣。<p>6.控制情绪，保持冷静。<p>当愤怒难以抑制时，愤怒会使你失去理解他人和控制自己的客观尺度。它不仅无助于问题的解决，反而会把事情搞得更糟，应提早结束会见。<p>7.学会听的艺术。<p>听有两个要求，首先要给对方留出讲话的时间，其次要听“听话听音”。如对方首先讲话，你不可打断对方。应做好准备，以便利用恰当的时机给对方以响应，鼓励对方讲下去。不能够认真聆听别人谈话的人，也就不能够“听话听音”，更不能机警、巧妙地回答对方的问题。记住：不论是社交场合，还是在工作中，善于听是一个人应有的素养。<p>8.避免不良的动作和姿态。<p>玩弄手中的小东西，用手不时地理头发、搅舌头，清牙齿，掏耳朵，盯视指甲、天花板或对方身后的字画等，这些动作都有失风度。<p>9.要诚实、坦率，又有节制。<p>若在一件小事上做假，很可能使你的整个努力付诸东流。对方一旦怀疑你不诚实，你的各种不同凡响的作为都将黯然失色。谁都不是十全十美的完人，因此，你可以坦率地谈起或承认自己的缺点或过失。在评论第三者时不应失去体量他人的气度。<p>10.要善于“理乱麻”，学会清楚地表达。<p>善于表达使人终生受益。讲话不会概括的人，常常引起人们的反感：叙事没有重点，思维头绪混乱的人，常常迫使人们尽量回避他。一般来说，你若从没有担心过别人会对你的话产生反感，就意味着你已引起他人的反感了。<p>11.作一次音色和语调的自我检查。<p>把自己要讲的话录音5分钟，听听是否清晰，喉音、鼻音是否太重？语速怎样？语调老成、平淡吗？如不满意，改进后再录一段听听。充满朝气的语调会使你显得年轻。此功重在平时留心多练。<p>12.注意衣着和发式。<p>第一次见面就给人一种不整洁的印象，往往会给你的自我表白投下阴影。平时不修边幅的企业家，在会见前应问问懂行的人，让他根据你的年龄、体形、职业及季节等因素设计一下你的衣着和发式。<p>13.做自我介绍应谨慎。<p>如果对方资历比你浅，学识比较低，你应格外留心自我优越感的外露。当你介绍了自己令人羡慕的学位职称等情况后，对方也得谈到他的相应情况。为了避免对方自愧不如，在介绍自己时你应该谨慎一些。对对方可以表示赞佩。过度的关心和说教应该避免，要表现出诚意和合作精神。<p>14.给人留下良好的印象。<p>会见结束时，不要忘记带走你的帽子、手套、公事包等东西。告别语应适当简练，克制自己不要在临出门时又引出新的话题，因为没有理由认为告别才是会见的高潮。<p>","description":"迈进会客室的门，你的第一句话可能是：“你好，见到你很高兴。”但这却不如说：“李经理，你好，见到你很高兴。”后者比前者要热情得多。","category":"杂谈","hot":"n"},{"id":45,"title":"职场蛮干不可取 10个万能谈话技巧","date":1341908919,"content":"<p>核心提示：才干加上超时加班固然很重要，但懂得在关键时刻说适当的话，那也是成功与否的决定性因素……<p>要是你以为单靠熟练的技能和辛勤的工作就能在职场上出人头地，那你就有点无知了。当然，才干加上超时加班固然很重要，但懂得在关键时刻说适当的话，那也是成功与否的决定性因素。卓越的说话技巧，譬如讨好重要人物、避免麻烦事落到自己身上、处理棘手的事务等等，不仅能让你的工作生涯加倍轻松，更能让你名利双收。牢记以下十个句型，并在适当时刻派上用场，加薪与升职必然离你不远。<p>1、以最婉约的方式传递坏消息句型：我们似乎碰到一些状况<p>你刚刚才得知，一件非常重要的案子出了问题，如果立刻冲到上司的办公室里报告这个坏消息，就算不干你的事，也只会让上司质疑你处理危机的能力，弄不好还惹来一顿骂，把气出在你头上。此时，你应该以不带情绪起伏的声调，从容不迫的说出本句型，千万别慌慌张张，也别使用问题或麻烦这一类的字眼；要让上司觉得事情并非无法解决，而我们听起来像是你将与上司站在同一阵线，并肩作战。<p>2、上司传唤时责无旁贷句型：我马上处理<p>冷静、迅速的做出这样的回答，会令上司直觉的认为你是名有效率、听话的好部属；相反，犹豫不决的态度只会惹得责任本就繁重的上司不快。夜里睡不好的时候，还可能迁怒到你头上呢！<p>3、表现出团队精神句型：安琪的主意真不错<p>安琪想出了一条连上司都赞赏的绝妙好计，你恨不得你的脑筋动得比人家快；与其拉长脸孔、暗自不爽，不如偷沾他的光。方法如下：趁着上司听得到的时刻说出本句型。在这个人人都想争着出头的社会里，一个不妒嫉同事的部属，会让上司觉得此人本性纯良、富有团队精神，因而另眼看待。<p>4、说服同事帮忙句型：这个报告没有你不行啦<p>有件棘手的工作，你无法独力完成，非得找个人帮忙不可；于是你找上了那个对这方面工作最拿手的同事。怎么开口才能让人家心甘情愿的助你一臂之力呢？送高帽、灌迷汤，并保证他日必定回报；而那位好心人为了不负自己在这方面的名声，通常会答应你的请求。不过，将来有功劳的时候别忘了记上人家一笔。<p>5、巧妙闪避你不知道的事句型：让我再认真的想一想，三点以前给您答复好吗<p>上司问了你某个与业务有关的问题，而你不知该如何做答，千万不可以说不知道。本句型不仅暂时为你解危。也让上司认为你在这件事情上头很用心，一时之间竟不知该如何启齿。不过，事后可得做足功课，按时交出你的答复。<p>6、智退性骚扰句型：这种话好像不大适合在办公室讲喔<p>如果有男同事的黄腔令你无法忍受，这句话保证让他们闭嘴。男人有时候确实喜欢开黄腔，但你很难判断他们是无心还是有意，这句话可以令无心的人明白，适可而止。如果他还没有闭嘴的意思，即构成了性骚扰，你可以向有关人士举发。<p>7、不着痕迹的减轻工作量句型：我了解这件事很重要；我们能不能先查一查手头上的工作，把最重要的排出个优先顺序<p>不如当下就推辞。首先，强调你明白这件任务的重要性，然后请求上司的指示，为新任务与原有工作排出优先顺序不着痕迹的让上司知道你的工作量其实很重，若非你不可的话，有些事就得延后处理或转交他人。<p>8、恰如其分的讨好句型：我很想知道您对某件案子的看法<p>许多时候，你与高层要人共处一室，而你不得不说点话以避免冷清尴尬的局面。不过，这也是一个让你能够赢得高层青睐的绝佳时机。但说些什么好呢?每天的例行公事，绝不适合在这个时候被搬出来讲，谈天气嘛，又根本不会让高层对你留下印象。此时，最恰当的莫过于一个跟公司前景有关，而又发人深省的话题。问一个大老板关心又熟知的问题，但他滔滔不绝的诉说心得的时候，你不仅获益良多，也会让他对你的求知上进之心刮目相看。<p>9、承认疏失但不引起上司不满句型：是我一时失察，不过幸好<p>犯错在所难免，但是你陈述过失的方式，却能影响上司心目中对你的看法。勇于承认自己的疏失非常重要，因为推卸责任只会让你看起来就像个讨人厌、软弱无能、不堪重用的人，不过这不表示你就得因此对每个人道歉，诀窍在于别让所有的矛头都指到自己身上，坦承却淡化你的过失，转移众人的焦点。<p>10、面对批评要表现冷静句型：谢谢你告诉我，我会仔细考虑你的建议<p>自己苦心的成果却遭人修正或批评时，的确是一件令人苦恼的事。不需要将不满的情绪写在脸上，但是却应该让批评你工作成果的人知道，你已接收到他传递的信息。不卑不亢的表现令你看起来更有自信、更值得人敬重，让人知道你并非一个刚愎自用、或是经不起挫折的人。<p>","description":"要是你以为单靠熟练的技能和辛勤的工作就能在职场上出人头地，那你就有点无知了。当  然，才干加上超时加班固然很重要，但懂得在关键时刻说适当的话，那也是成功与否的决定性  因素。卓越的说话技巧，譬如讨好重要人物、避免麻烦事落到自己身上、处理棘手的事务等等  ，不仅能让你的工作生涯加倍轻松，更能让你名利双收。牢记以下十个句型，并在适当时刻派  上用场，加薪与升职必然离你不远。","category":"杂谈","hot":"n"},{"id":46,"title":"寻找设计的动机和方向","date":1351152171,"content":"<p><img src=\"/content/uploadfile/201210/thum-f8d8153fb4f29d3af15276db22435d4820121025080950.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>做设计久了，有时会回头想一下，到底设计是什么？<p>在我理解，设计的核心即把握动机、实现需求，这两点做到位了的话，整个产品的架构也就自然而然形成，剩下的工作就只是完善和调整细节。<p>一. 理解动机<p>要把握动机，首先要理解动机。所谓动机，我认为有三种，而这三种动机就是产品最终形态的来源。如果其中一样没有把握好，就无法做出好的产品。<p>a. 产品（功能）开发的动机<p>以前对这方面不太关心，做不同的产品都是怀着一样的态度一样的标准去做，作为交互设计师，只想着怎样让产品好用。但这样做出来的设计不一定能达到产品的目标，不同的产品或功能有对应不同的设计对策，根据产品开发动机的不同，我将它们分为六大类：<p>保守型：这类产品也可以称为跟风型，它们的开发动机是\"别人有我们也来搞\"，看到这个产品有盈利可得，就来凑热闹分一杯羹，企业不会投入很多资源，产品也一般没有很大特色。如果碰到此类产品，设计师往往很无奈，如果无法与PM重新对产品进行定位，只能做些不痛不痒的东西，我们能做的就是通过设计进行细微的改善。<p>常规型：企业已有的长期产品，如QQ、腾讯网等。由于产品已经比较成熟，提升空间往往在细节的体验，无论对产品还是设计，抠细节很重要，而不是一味地去增加功能。另外，随着时间推移以及市场的变化，这些产品的功能以及定位可能会发生改变，设计思路也应随之转化。<p>竞争型：例如soso和电脑管家，其开发的动机并不是说一定要能打败百度和360，而是为了填补产品类型空洞，占有一部分市场，限制竞争对手的发展，像Tita也是此类产品。设计的时候要注意的是，在不损失基础功能的前提下要有一定的自我特色，差异化及一些小噱头是吸引用户的重要因素。<p>试水型：07年Windows Vista操作系统刚出现时大家都眼前一亮，较之Window XP，它的内核几乎全部重写，带来了大量的新功能，无论是视觉、交互还是功能都有很大的变革，让用户们眼前一亮！但过后不到一年里，各种各样的问题接踵而至，越来越多的用户开始抱怨Vista的繁冗拖沓和难用，甚至装回了XP系统。而两年后Windows7的成功想必就不必多说了，其实看Vista和Win7的界面风格差不多，但在功能上却相差甚远。Vista的生命周期非常短，它就像个炮灰，上线收集完用户的反馈后它的使命便完成。所以说没有Vista就没有Win7。我发现我们在做产品或做设计时，总是蹑手蹑脚的，怕这个用户不喜欢，怕那个市场接受不了，最后只能做出保守的方案。我想如果我们能大胆地做一些\"试水版\"， 直接上线让用户\"批斗\"，也许能更快获知用户真实的看法。<p>探索型：创新的产品人人都想做，但能够成功的是万里挑一。去年我们组尝试做两个APP，产品和设计都是我们来弄，结果都不理想。其实就是因为我们的产品知识太浅，对用户的动机把握不足，只是自己想当然地做出一些功能出来。这个产品有怎样的自身竞争力、目标人群是否真能获益、真实用户的数量是否足以形成有规模的市场、对产品未来发展的预测即产品是否能有一个较长甚至可循环的生命周期，等等…一个产品或者概念的筛选得考虑许多问题，对它的思考及分析需投入大量的资源，不是谁都能像Jobs那样拍脑袋想产品。<p>推广型：此类产品并不是为了直接赢取收益，而是为了树立企业形象，扩大品牌影响力，例如QQ星云、我们的CDC blog等，都是为了让别人知道我们在干什么。对这类产品来说，我认为内容的新意以及内容把握的度较为重要。<p>b. 用户使用的动机<p>现在没有什么公司敢不做一点用研就推出产品，通过用研我们能发现问题，却难以获知用户动机，因为我们看到的只是现象。<p>关于用户动机，我的一些感受是：<p>1）用户的需求不等于用户的动机，动机是需求的核心和本质；<p>2）不是所有的需求都是有价值的，但是所有的动机我们都应该考虑；<p>3）有人说用户是傻瓜，他们不知道自己想要什么样的产品。但我想说的是用户在使用产品的时候一点都不傻，好用和易用的产品很快就会被用户接受，而不好用的产品就会很快被淘汰；<p>4）我们所要做的是，做傻瓜用的产品，满足最精明的用户，占领普通人的市场！<p>要挖掘用户动机其实是非常困难的事情，所以说我们尽量不做自己不感兴趣的领域，如果自己不是这个产品的典型用户，基本上是很难做出好的产品的，但是在工作中我们往往就会遇到这种问题。其实每一个好的设计师都应该是一个好的演员，即在思考或设计的时候，能把自己的性格、爱好等等一切抛掉，变成目标客户，当你能入戏了，动机自然就出来了。<p>c. 设计的动机<p>所谓设计的动机，我认为就是实现自己的设计价值观。<p>之前在知乎看过一篇文章记录豆瓣面试资深产品经理的过程，帖子非常火，主要讲述的是面试官问面试者\"什么是成功产品的标准\"，可无论面试者如何回答，面试官都会绕回同一个问题：\"你认为这样的产品就算是好的产品吗\"，让面试者非常无奈和恼火。这样的面试看着貌似苛刻，但其实面试官是在考验他是否有判别事情的标准和方法。<p>有自己的判断标准（即价值观）很重要，因为对于一个问题，通常很多方法都是可行的，但不同的策略可能会引导产品到不同的走向。对于产品经理来说要有自己的产品价值观，对于设计师来说要有自己的设计价值观，不然只会被别人或者被市场牵着鼻子走，最后做出来的东西可能只是个\"四不像\"。而这种设计价值观应该是一个全面的合理的价值观，设计师切忌陷入自我意识之中，认为其他人不理解自己、不懂什么是设计，盲目的自我意识和价值观只会产生自己认为很好而其他人不认可的产品。<p>要做到有自己的设计价值观且保持它的合理和科学性，是一件不太容易的事情。除了对产品、对市场、对用户的了解不断积累，还需要不断地交流，交流对于设计而言很重要，去和不同的人、不同的角色交流，不要担心别人的质疑和不同想法，而且通过这样也能让你的产品更容易立足。另外，在具体做设计的时候，对每个设计要点必须先下好定义，确定这里是做什么的、要达到的产品目的和设计目的是什么，不然设计的过程中往往想着想着，因为别的一些因素或者想法而使得设计走远走偏。一切设计都要围绕定义展开。<p>二. 实现需求<p>实现需求的能力即设计能力。除了老生常谈的设计表现能力和设计沟通能力外，设计判断能力也尤其重要。<p>设计师们一般都会有这样的特质：<p>设计师都很爱恨分明，以致爱（恨）屋及乌，看不清细节的好坏；<p>设计师很容易站在批判的角度看待别人的东西；<p>设计师往往无法看清自己的设计是好是坏，并且会下意识地袒护自己的设计。<p>如果没有良好的判断能力，当自己的设计受到批判时，有的人会听不进去，有的人会变得迷失。而最可怕的情况是大家都觉得做得很好，等推出市场之后才发现非也。要形成好的判断能力非一朝一夕即可，多看书多看牛人的观点固然有助，但是直接从别人口中得到的知识难以进到自己的大脑，只有经自己大脑思考过的东西才能真正运用。我觉得在工作中形成好的判断能力有以下两种方法：<p>一是多与项目外的人或设计之外的人讨论，旁观者清。在讨论的时候，我个人经常喜欢站在相反的观点上争论，这并不是为了争个输赢，而是为了在辩论的过程中会激发大家的思维，挖掘出所有的论据，然后最终找到最重要、最站得住脚的理由。<p>二是多进行反思，反思这个词我们经常提，可是极少有在做，或者只是象征性地笼统地去\"总结\"一下。我们经常会发现，有很多设计或者点子我们刚做出来时很兴奋，但过后再看会发现其实有很多问题。在邮件里、在分享会上，我们往往只看到对成功项目的总结，对最终方案的陈述，而其实真正能学到东西的是那些错误的和失败的例子，只不过我们都不愿意也不想花功夫去展示这些失败的东西。其实在以后的分享会上，可以让大家讲讲自己不成熟的设计、没选上的方案、失败的项目等，这样其实更能让我们少走弯路。<p>三. 工作之外<p>a. 用心观察引发思考<p>上周去看演唱会，等待的时候无聊看周围的人玩手机，发现好几个女生的输入法都是卡通皮肤的，然后惊讶原来还有这样的东西，因为我们身边的人用的手机输入法都是素面朝天的。想起小龙说：做换肤是不自信的表现，但我认为其实只是目标用户和产品定位不同罢了。<p>有次看到toya查地图的方式，顿时震惊了。她会打开地图，然后鼠标一直双击地图放大，点了很多次才从中国地图一直放大到深圳的某个地方（我也是这才知道原来地图可以双击放大，我都是滚的=..=），而其实我们只要输入地名一下子就出来了，但她就是不想打字。我们都说人因为懒而发明创造，我却发现原来有一种懒能让用户以一种更累的方式去使用产品，而同时还觉得这样更方便！就像有时我们躺在床上，就因为懒得下床，而用一种很别扭很辛苦的姿势去拿东西一样。人的这种奇怪的惰性是难以改变的，设计的时候不能只是考虑如何提高操作效率，还要尽量顾及到这样一种人和这样一种心态。<p>b. 用文字促进思想的形成<p>自己一些想法和对事物的思考一定要写下来，主要不是为了记录，而是为了让自己进行更深入的思考。去年来的时候，每周要写周记挺累的，但这几天我才发现其实这项工作比我想象中很重要，因为只有逼自己去总结和思考，才会了解自己的所得所缺，不会不知道做了什么学了什么，一个月就过去了一年又过去了。写作不仅是促进人的思考，更重要是能够让我们形成自己的思想，因为当你要写成文时才会去整理思路、寻找论据、完善观点，而并不是一些模糊的碎片，那只能是想法而不是思想。<p>c. 感受生活沉淀细节体验<p>工作中我们会使用一些创新工具、用研方法、分析模型等，但只是在走以用户为中心的设计流程，往往结果还是消除不了用户的痛点。在工作中如果我们只去想产品的事情、设计的事情，可能最终只能做出风格化的东西出来，而不是真正的情感化。只有热爱生活的人才会发觉生活中的细节并将之用到设计中，只有认真去感受生活的人才能做出不仅好用、而更是打动人心的产品。<p>四. 自我感悟<p>在生活中有些时候扬长避短很重要，但在大部分时候，我们对不擅长的东西越要勇于去做。虽然人不需要面面俱到，但不能让自己有害怕的东西，要敢于挑战难度。<p>我是一个总会强迫自己的人，但怀着焦虑的心难以做好事情。正在努力不去强迫自己做事，但前提是不能没有计划，最后放松身心去打持久战。<p>有不少人问我为什么要读研，能学到什么，其实这个问题我也经常会问自己。有时候大家回头想一想，前面的一段工作时间里，自己除了专业技能提升了，对设计的一些感觉稍微准点了，还获得了什么？我们处在一个创意的行业，创意需要的是无数换代观点的迅速形成，这逼着我们要经常去看不同的东西；而研究需要的是瞄准一个目标进行无尽挖掘，要求我们沉下心去探讨，即使在创意行业也需要我们有研究的态度。读研阶段，我觉得自己最大的收获是，学习了如何去深入研究一样东西的方法以及耐心，而在工作期间能让我们静下心去研究某样东西真的不太可能。其实我是有点懒去思考也不太善于做研究的人，但是我努力去培养这种能力。<p>最后的话<p>两次来CDC实习，前后加起来也不过五个月的时间，但学到了很多，也思考了不少。在这里，我们拼搏，我们欢笑；我们做设计，我们玩生活。离开的日子，我会想你们，待重逢的那天，我们再一起疯狂。<p>本文章来源于：寻找设计的动机和方向<p>","description":"<img style=\"display:block;margin:0 auto 10px auto;\" alt=\"寻找设计的动机和方向\" src=\"/content/uploadfile/201210/f8d8153fb4f29d3af15276db22435d4820121025080950.jpg\" border=\"0\" />做设计久了，有时会回头想一下，到底设计是什么？在我理解，设计的核心即把握动机、实现需求，这两点做到位了的话，整个产品的架构也就自然而然形成，剩下的工作就只是完善和调整细节。","category":"杂谈","hot":"y"},{"id":47,"title":"跟我一起学写jQuery插件","date":1351240094,"content":"<p>jQuery如此流行，各式各样的jQuery插件也是满天飞。你有没有想过把自己的一些常用的JS功能也写成jQuery插件呢？如果你的答案是肯定的，那么来吧！和我一起学写jQuery插件吧！ <p>嗨，美女，这是我写的一个jQuery插件！<p>很多公司的前端设计开发人员都是女孩子，而这些女孩子很多JavaScript技能都不是很好。而前端开发过程中，JavaScript技能又是必不可少的。所以，如果前端小MM正在为某个JavaScript效果发愁的时候，你潇洒的过去，然后对她说：\"嗨，美女，用这个吧。这是我写的一个jQuery插件。\"我想基本上你的人生大事就能很快解决。<p>先想好做个什么功能<p>这是第一步，也是很重要的一步，鉴于咱们都是刚学习写jQuery插件，所以，这个功能一定要简单一些。不要想一口就吃个胖子，咱也吃不了。咱还是捡个瘦的下手吧。但是，这个功能也不能太无聊，如果无聊到几乎没用处，就算做好了也是扔到马桶里，不会持续更新，也便不会持续进步了。<p>我最终选择的是：美化表格，让表格的奇偶行颜色不同，然后鼠标移到某行上，某行可以高亮显示。功能简单又实用，不错，不错。呵呵～～<p>不急着写，先想想实现原理<p>还不急，先想想实现原理。必要的时候，先写出简单的实现的原型。<p>我的这个美化表格的例子，实现原理倒是简单，无非就是找到表格的奇偶行，然后添加不同的class，活动行高亮显示也很简单，只要判断mouseover事件，然后添加一个class，mouseout的时候，再去掉这个class即可。<p>一个通用的框架<p>在动手写自己的jQuery插件之前，自然是先研究一下别人写的插件了。其实写jQuery也基本有一个通用的框架。行，那咱也把这框架照搬过来吧。<p>(function($){     $.fn.yourName = function(options){         var defaults = {                 //各种属性、参数         }         var options = $.extend(defaults, options);         this.each(function(){         //插件实现代码         });     }; })(jQuery);<p>有了这个，咱就可以往里面套东西了。<p>名号、参数和属性<p>好不容易开始闯荡江湖了，一定要有一个响亮的名号才行，这样走在江湖上，才能够屌，够威风。不信，你听听人家\"中国牙防组\"！所以，咱这里一定要起个响亮的名号，一定要简单、明了、够权威。所以，决定了，就叫做\"tableUI\"了！<p>参数和属性也很简单，无非就是三个class的名称。就叫做：evenRowClass、oddRowClass和activeRowClass吧。<p>所以，上面的框架，咱就把上半身给填上了。<p>(function($){     $.fn.tableUI = function(options){         var defaults = {             evenRowClass:\"evenRow\",             oddRowClass:\"oddRow\",             activeRowClass:\"activeRow\"                     }         var options = $.extend(defaults, options);         this.each(function(){             //实现代码         });     }; })(jQuery);<p>这里重点说一下这一句：<p>var options = $.extend(defaults, options);<p>看上去很屌的一句，其实就是合并多个对象为一个。这里就是，如果你在调用的时候写了新的参数，就用你新的参数，如果没有写，就用默认的参数。想进一步了解的朋友，可以参考jquery的官方文档： http://api.jquery.com/jQuery.extend/<p>开始下半身吧<p>ok，上半身填补完了，咱就可以填补下半身吧。无非就是找到基数行和偶数行（感谢jQuery提供了类似tr:even这种写法，使其及其简单），然后添加上相应的class。然后再给所有的tr，绑定mouseover和mouseout事件即可。下半身代码如下：<p> (function($){   $.fn.tableUI = function(options){     var defaults = {       evenRowClass:\"evenRow\",       oddRowClass:\"oddRow\",       activeRowClass:\"activeRow\"                 }     var options = $.extend(defaults, options);     this.each(function(){       var thisTable=$(this);       //添加奇偶行颜色       $(thisTable).find(\"tr:even\").addClass(options.evenRowClass);       $(thisTable).find(\"tr:odd\").addClass(options.oddRowClass);       //添加活动行颜色       $(thisTable).find(\"tr\").bind(\"mouseover\",function(){           $(this).addClass(options.activeRowClass);       });       $(thisTable).find(\"tr\").bind(\"mouseout\",function(){           $(this).removeClass(options.activeRowClass);       });     });   }; })(jQuery);<p>最重要的一步！<p>也许有些朋友觉得这样就算是完成了。但是切切相反，我们还有最重要的一步没有完成，那就是一定要在插件上方，写上插件的名称、版本号、完成日期、作者，作者的联系方式、出生日期、三围……等等。因为只有这样才能显的这个插件够专业。<p> /*  * tableUI 0.1  * Copyright (c) 2009 JustinYoung  http://justinyoung.cnblogs.com/  * Date: 2010-03-30  * 使用tableUI可以方便地将表格提示使用体验。先提供的功能有奇偶行颜色交替，鼠标移上高亮显示  */ (function($){   $.fn.tableUI = function(options){     var defaults = {       evenRowClass:\"evenRow\",       oddRowClass:\"oddRow\",       activeRowClass:\"activeRow\"                 }     var options = $.extend(defaults, options);     this.each(function(){       var thisTable=$(this);       //添加奇偶行颜色       $(thisTable).find(\"tr:even\").addClass(options.evenRowClass);       $(thisTable).find(\"tr:odd\").addClass(options.oddRowClass);       //添加活动行颜色       $(thisTable).find(\"tr\").bind(\"mouseover\",function(){           $(this).addClass(options.activeRowClass);       });       $(thisTable).find(\"tr\").bind(\"mouseout\",function(){           $(this).removeClass(options.activeRowClass);       });     });   }; })(jQuery);<p>另外一例：<p>/* * tableUI 0.2 * 就不写版权了吧，呵呵 * Date: 4/1/2010 * 使用tableUI可以方便地将表格提示使用体验。先提供的功能有奇偶行颜色交替，鼠标移上高亮显示 * 0.2版结合25个小贴士对\"政委\"的那个做了些优化，学习之用，还请指正。 */ (function($) {   $.fn.tableUI = function(options) {     //默认参数     var defaults = {         evenRowClass: \"evenRow\",         oddRowClass: \"oddRow\",         activeRowClass: \"activeRow\"     };     //用传入参数覆盖了默认值     options = $.extend(defaults, options);     //表对象     var thisTable = $(this);     //添加奇偶行颜色     thisTable.find(\"tr:even\").addClass(options.evenRowClass);     thisTable.find(\"tr:odd\").addClass(options.oddRowClass);     //绑定鼠标移动事件，不必对每行都绑定事件。     thisTable.live(\"mouseover\", function(e) {         //获取鼠标所指目标对象父级tr         $(e.target).parent().addClass(options.activeRowClass);         //阻止事件冒泡         return false;     }).live(\"mouseout\", function(e) {         $(e.target).parent().removeClass(options.activeRowClass);         return false;     });   }; })(jQuery);<p>本文章来源于：跟我一起学写jQuery插件（附完整实例及下载）<p>","description":"jQuery如此流行，各式各样的jQuery插件也是满天飞。你有没有想过把自己的一些常用的JS功能也写成jQuery插件呢？如果你的答案是肯定的，那么来吧！和我一起学写jQuery插件吧！","category":"JavaScript","hot":"y"},{"id":48,"title":"swfupload在chrome中点击上传图片按钮无反应的解决办法","date":1351483155,"content":"<p>chrome 22.0.XXXXXdev版上传图片按钮点击无反应原因:是GOOGLE的内建FlashPPAPI外挂所导致的。<p>问题原因：<p>由于Google浏览器(Chrome)，在最新测试版22.0.1207.1 dev-m更改了有关Flash项目的机制，新增了Flash PPAPI外挂，造成上传图片按钮失效，也就是按下去没反应。这是google浏览器的问题！<p>如果遇到按下上传按钮没有反应可以尝试以下解决方法：<p>解决方法如下：<p>在Chrome浏览器网址列上输入：chrome://plugins/<p>然后在画面右上角打开了详细资讯<p>之後找到 flash項目內的 类型：PPAPI ，然後按下PPAPI下一行的停用即可<p>本文章来源于：swfupload chrome 22.0.XXXXX dev版上传图片按钮点击无返应解决办法<p>","description":"由于Google浏览器(Chrome)，在最新测试版22.0.1207.1 dev-m更改了有关Flash项目的机制，新增了Flash PPAPI外挂，造成上传图片按钮失效，也就是按下去没反应。这是google浏览器的问题！","category":"HTML","hot":"n"},{"id":49,"title":"体验jQuery强大的链式操作","date":1351503264,"content":"<p>jQuery强大的链式操作，简单说就是允许将所有操作连接在一起，以链条的形式写出来，这是jQuery最令人称道、最方便的特点。它的原理在于每一步的jQuery操作，返回的都是一个jQuery对象，所以不同操作可以连在一起。很符合jQuery的宗旨，write less, do more. 写更少的代码，做更多的事情！<p>以下2个简单的例子来自《锋利的jQuery》：<p>实现有二级导航栏功能的链式操作：<p>$(\"has_children\").click(function(){     $(this).addClass(\"highlight\").children(\"a\").show().end()     .siblings().removeClass(\"highlight\").children(\"a\").hide(); });<p>siblings() 获得匹配集合中每个元素的同胞，通过选择器进行筛选是可选的。<p>end() 方法结束当前链条中的最近的筛选操作，并将匹配元素集还原为之前的状态。在链式操作中起到很大作用，使得结果集可以后退一步。<p>id为table的表格\"tbody\"中，如果每行最后一个列表中的checkbook没有被禁用，则把这一行的背景色设为红色。<p>$(\"#table&gt;tbody&gt;tr:has(td:last:has(:checkbox:enabled))\") .css(\"background\",\"red\");<p>has() 将匹配元素集合缩减为拥有匹配指定选择器或 DOM 元素的后代的子集。<p>再看一个关于展开隐藏的demo的例子：<p>文章jquery设计思想-选择器的 Demo 中对按钮的2个操作的例子<p>$(\".unfold\").css(\"background\",\"#aaa\").end() .find(\".unfold\").text(\"显示推荐\");<p>find() 方法获得当前元素集合中每个元素的后代，通过选择器、jQuery 对象或元素来筛选。<p>修改日志<p>2012.03.22<p>增加一个一次绑定多个事件类型的写法<p>$(function(){     $(\"div\").bind(\"mouseover mouseout\", function(){         $(this).toggleClass(\"test\");  }); });<p>","description":"jQuery强大的链式操作，简单说就是允许将所有操作连接在一起，以链条的形式写出来，这是jQuery最令人称道、最方便的特点。它的原理在于每一步的jQuery操作，返回的都是一个jQuery对象，所以不同操作可以连在一起。很符合jQuery的宗旨，write less, do more. 写更少的代码，做更多的事情！","category":"JavaScript","hot":"n"},{"id":50,"title":"jquery要怎么写才能速度最快？","date":1352346625,"content":"<p>1.使用最新版本的jQuery<p>jQuery的版本更新很快，你应该总是使用最新的版本。因为新版本会改进性能，还有很多新功能。<p>下面就来看看，不同版本的jQuery性能差异有多大。这里是三条最常见的jQuery选择语句：<p>$(\'.elem\') $(\'.elem\', context) context.find(\'.elem\')<p>我们用1.4.2、1.4.4、1.6.2三个版本的jQuery测试，看看浏览器在1秒内能够执行多少次。结果如下：<p><img src=\"/content/uploadfile/201211/thum-2bc19dde4a7cef0ef166e3d765f9805e20121108060521.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>可以看到，1.6.2版本的运行次数，远远超过两个老版本。尤其是第一条语句，性能有数倍的提高。<p>其他语句的测试，比如.attr(\"value\")和.val()，也是新版本的jQuery表现好于老版本。<p>2.用对选择器<p>在jquery中，你可以用多种选择器，选择同一个网页元素。每种选择器的性能是不一样的，你应该了解它们的性能差异。<p>（1）最快的选择器：id选择器和元素标签选择器<p>举例来说，下面的语句性能最佳：<p>$(\'#id\') $(\'form\') $(\'input\')<p>遇到这些选择器的时候，jQuery内部会自动调用浏览器的原生方法（比如getElementById()），所以它们的执行速度快。<p>（2）较慢的选择器：class选择器<p>$(\'.className\')的性能，取决于不同的浏览器。<p>Firefox、Safari、Chrome、Opera浏览器，都有原生方法getElementByClassName()，所以速度并不慢。但是，IE5-IE8都没有部署这个方法，所以这个选择器在IE中会相当慢。<p>（3）最慢的选择器：伪类选择器和属性选择器<p>先来看例子。找出网页中所有的隐藏元素，就要用到伪类选择器：<p>$(\':hidden\')<p>属性选择器的例子则是：<p>$(\'[attribute=value]\')<p>这两种语句是最慢的，因为浏览器没有针对它们的原生方法。但是，一些浏览器的新版本，增加了querySelector()和querySelectorAll()方法，因此会使这类选择器的性能有大幅提高。<p>最后是不同选择器的性能比较图。<p><img src=\"/content/uploadfile/201211/thum-ed6f8a894489559d064db170fa33017720121108060521.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>可以看到，ID选择器遥遥领先，然后是标签选择器，第三是Class选择器，其他选择器都非常慢。<p>3.理解子元素和父元素的关系<p>下面六个选择器，都是从父元素中选择子元素。你知道哪个速度最快，哪个速度最慢吗？<p>$(\'.child\', $parent) $parent.find(\'.child\') $parent.children(\'.child\') $(\'#parent &gt; .child\') $(\'#parent .child\') $(\'.child\', $(\'#parent\'))<p>我们一句句来看。<p>(1)$(\'.child\', $parent)<p>这条语句的意思是，给定一个DOM对象，然后从中选择一个子元素。jQuery会自动把这条语句转成$.parent.find(\'child\')，这会导致一定的性能损失。它比最快的形式慢了5%-10%。<p>(2)$parent.find(\'.child\')<p>这条是最快的语句。.find()方法会调用浏览器的原生方法（getElementById，getElementByName，getElementByTagName等等），所以速度较快。<p>(3)$parent.children(\'.child\')<p>这条语句在jQuery内部，会使用$.sibling()和javascript的nextSibling()方法，一个个遍历节点。它比最快的形式大约慢50%。<p>(4)$(\'#parent &gt; .child\')<p>jQuery内部使用Sizzle引擎，处理各种选择器。Sizzle引擎的选择顺序是从右到左，所以这条语句是先选.child，然后再一个个过滤出父元素#parent，这导致它比最快的形式大约慢70%。<p>(5)$(\'#parent .child\')<p>这条语句与上一条是同样的情况。但是，上一条只选择直接的子元素，这一条可以于选择多级子元素，所以它的速度更慢，大概比最快的形式慢了77%。<p>(6)$(\'.child\', $(\'#parent\'))<p>jQuery内部会将这条语句转成$(\'#parent\').find(\'.child\')，比最快的形式慢了23%。<p>所以，最佳选择是$parent.find(\'.child\')。而且，由于$parent往往在前面的操作已经生成，jQuery会进行缓存，所以进一步加快了执行速度。<p>4.不要过度使用jquery<p>jQuery速度再快，也无法与原生的javascript方法相比。所以有原生方法可以使用的场合，尽量避免使用jQuery。<p>请看下面的例子，为a元素绑定一个处理点击事件的函数：<p>$(\'a\').click(function(){ 　　　　alert($(this).attr(\'id\')); 　　});<p>这段代码的意思是，点击a元素后，弹出该元素的id属性。为了获取这个属性，必须连续两次调用jQuery，第一次是$(this)，第二次是attr(\'id\')。<p>事实上，这种处理完全不必要。更正确的写法是，直接采用javascript原生方法，调用this.id：<p>$(\'a\').click(function(){ 　　　　alert(this.id); 　　});<p>根据测试，this.id的速度比$(this).attr(\'id\')快了20多倍。<p>5.做好缓存<p>选中某一个网页元素，是开销很大的步骤。所以，使用选择器的次数应该越少越好，并且尽可能缓存选中的结果，便于以后反复使用。<p>比如，下面这样的写法就是糟糕的写法：<p>jQuery(\'#top\').find(\'p.classA\'); jQuery(\'#top\').find(\'p.classB\');<p>更好的写法是：<p>varcached = jQuery(\'#top\'); cached.find(\'p.classA\'); cached.find(\'p.classB\');<p>根据测试，缓存比不缓存，快了2-3倍。<p>6.使用链式写法<p>jQuery的一大特点，就是允许使用链式写法。<p>$(\'div\').find(\'h3\').eq(2).html(\'Hello\');<p>采用链式写法时，jQuery自动缓存每一步的结果，因此比非链式写法要快。根据测试，链式写法比（不使用缓存的）非链式写法，大约快了25%。<p>7.事件的委托处理（EventDelegation）<p>javascript的事件模型，采用\"冒泡\"模式，也就是说，子元素的事件会逐级向上\"冒泡\"，成为父元素的事件。<p>利用这一点，可以大大简化事件的绑定。比如，有一个表格（table元素），里面有100个格子（td元素），现在要求在每个格子上面绑定一个点击事件（click），请问是否需要将下面的命令执行100次？<p>$(\"td\").bind(\"click\", function(){ 　　　　$(this).toggleClass(\"click\"); 　　});<p>回答是不需要，我们只要把这个事件绑定在table元素上面就可以了，因为td元素发生点击事件之后，这个事件会\"冒泡\"到父元素table上面，从而被监听到。<p>因此，这个事件只需要在父元素绑定1次即可，而不需要在子元素上绑定100次，从而大大提高性能。这就叫事件的\"委托处理\"，也就是子元素\"委托\"父元素处理这个事件。<p>具体的写法有两种。第一种是采用.delegate()方法：<p>$(\"table\").delegate(\"td\",\"click\", function(){ 　　　　$(this).toggleClass(\"click\"); 　　});<p>第二种是采用.live()方法：<p>$(\"table\").each(function(){ 　　　　$(\"td\", this).live(\"click\",function(){ 　　　　　　$(this).toggleClass(\"click\"); 　　　　}); 　　});<p>这两种写法基本等价。唯一的区别在于，.delegate()是当事件冒泡到指定的父元素时触发，.live()则是当事件冒泡到文档的根元素后触 发，因此.delegate()比.live()稍快一点。此外，这两种方法相比传统的.bind()方法还有一个好处，那就是对动态插入的元素也有效，.bind()只对已经存在的DOM元素有效，对动态插入的元素无效。<p>根据测试，委托处理比不委托处理，快了几十倍。在委托处理的情况下，.delegate()又比.live()大约快26%。<p>8.少改动DOM结构<p>（1）改动DOM结构开销很大，因此不要频繁使用.append()、.insertBefore()和.insetAfter()这样的方法。<p>如果要插入多个元素，就先把它们合并，然后再一次性插入。根据测试，合并插入比不合并插入，快了将近10倍。<p>（2）如果你要对一个DOM元素进行大量处理，应该先用.detach()方法，把这个元素从DOM中取出来，处理完毕以后，再重新插回文档。根据测试，使用.detach()方法比不使用时，快了60%。<p>（3）如果你要在DOM元素上储存数据，不要写成下面这样：<p>var elem = $(\'#elem\'); elem.data(key,value);<p>而要写成<p>var elem = $(\'#elem\'); $.data(elem,key,value);<p>根据测试， 后一种写法要比前一种写法，快了将近10倍。因为elem.data()方法是定义在jQuery函数的prototype对象上面的， 而$.data()方法是定义jQuery函数上面的，调用的时候不从复杂的jQuery对象上调用，所以速度快得多。（此处可以参阅下面第10点。）<p>9.正确处理循环<p>循环总是一种比较耗时的操作，如果可以使用复杂的选择器直接选中元素，就不要使用循环，去一个个辨认元素。<p>javascript原生循环方法for和while，要比jQuery的.each()方法快，应该优先使用原生方法。<p>10.尽量少生成jquery对象<p>每当你使用一次选择器（比如$(\'#id\')），就会生成一个jQuery对象。jQuery对象是一个很庞大的对象，带有很多属性和方法，会占用不少资源。所以，尽量少生成jQuery对象。<p>举例来说，许多jQuery方法都有两个版本，一个是供jQuery对象使用的版本，另一个是供jQuery函数使用的版本。下面两个例子，都是取出一个元素的文本，使用的都是text()方法。你既可以使用针对jquery对象的版本：<p>var $text = $(\"#text\"); var$ts = $text.text();<p>也可以使用针对jQuery函数的版本：<p>var $text = $(\"#text\"); var$ts = $.text($text);<p>由于后一种针对jquery函数的版本不通过jQuery对象操作，所以相对开销较小，速度比较快。<p>本文章来源于：jquery要怎么写才能速度最快？<p>","description":"jQuery的版本更新很快，你应该总是使用最新的版本。因为新版本会改进性能，还有很多新功能。","category":"JavaScript","hot":"n"},{"id":51,"title":"jQuery.validate使用手册详解","date":1352450641,"content":"<p>jQuery.validate是一款非常不错的表单验证工具，简单易上手，而且能达到很好的体验效果，虽然说在项目中早已用过，但看到这篇文章写得还是不错的，转载下与大家共同分享。<p>一、用前必备<p>官方网站：http://bassistance.de/jquery-plugins/jquery-plugin-validation/（注意下载最新版）<p>API: http://jquery.bassistance.de/api-browser/plugins.html当前版本：1.5.5<p>需要JQuery版本：1.2.6+，兼容 1.3.2<p>&lt;script src=\"../js/jquery.js\" type=\"text/javascript\"&gt;&lt;/script&gt; &lt;script src=\"../js/jquery.validate.js\" type=\"text/javascript\"&gt;&lt;/script&gt;<p>二、默认校验规则<p>(1)required:true //必输字段<p>(2)remote:\"check.php\" //使用ajax方法调用check.php验证输入值<p>(3)email:true //必须输入正确格式的电子邮件<p>(4)url:true //必须输入正确格式的网址<p>(5)date:true //必须输入正确格式的日期<p>(6)dateISO:true //必须输入正确格式的日期(ISO)，例如：2009-06-23，1998/01/22 只验证格式，不验证有效性<p>(7)number:true //必须输入合法的数字(负数，小数)<p>(8)digits:true //必须输入整数<p>(9)creditcard: //必须输入合法的信用卡号<p>(10)equalTo:\"#field\" //输入值必须和#field相同<p>(11)accept: //输入拥有合法后缀名的字符串（上传文件的后缀）<p>(12)maxlength:5 //输入长度最多是5的字符串(汉字算一个字符)<p>(13)minlength:10 //输入长度最小是10的字符串(汉字算一个字符)<p>(14)rangelength:[5,10] //输入长度必须介于 5 和 10 之间的字符串\")(汉字算一个字符)<p>(15)range:[5,10] //输入值必须介于 5 和 10 之间<p>(16)max:5 //输入值不能大于5<p>(17)min:10 //输入值不能小于10<p>三、默认的提示<p>messages: {   required: \"This field is required.\",   remote: \"Please fix this field.\",   email: \"Please enter a valid email address.\",   url: \"Please enter a valid URL.\",   date: \"Please enter a valid date.\",   dateISO: \"Please enter a valid date (ISO).\",   dateDE: \"Bitte geben Sie ein gültiges Datum ein.\",   number: \"Please enter a valid number.\",   numberDE: \"Bitte geben Sie eine Nummer ein.\",   digits: \"Please enter only digits\",   creditcard: \"Please enter a valid credit card number.\",   equalTo: \"Please enter the same value again.\",   accept: \"Please enter a value with a valid extension.\",   maxlength: $.validator.format(\"Please enter no more than {0} characters.\"),   minlength: $.validator.format(\"Please enter at least {0} characters.\"),   rangelength: $.validator.format(\"Please enter a value between {0} and {1} characters long.\"),   range: $.validator.format(\"Please enter a value between {0} and {1}.\"),   max: $.validator.format(\"Please enter a value less than or equal to {0}.\"),   min: $.validator.format(\"Please enter a value greater than or equal to {0}.\") },<p>如需要修改，可在js代码中加入：<p>jQuery.extend(jQuery.validator.messages, {   required: \"必选字段\",   remote: \"请修正该字段\",   email: \"请输入正确格式的电子邮件\",   url: \"请输入合法的网址\",   date: \"请输入合法的日期\",   dateISO: \"请输入合法的日期 (ISO).\",   number: \"请输入合法的数字\",   digits: \"只能输入整数\",   creditcard: \"请输入合法的信用卡号\",   equalTo: \"请再次输入相同的值\",   accept: \"请输入拥有合法后缀名的字符串\",   maxlength: jQuery.validator.format(\"请输入一个长度最多是 {0} 的字符串\"),   minlength: jQuery.validator.format(\"请输入一个长度最少是 {0} 的字符串\"),   rangelength: jQuery.validator.format(\"请输入一个长度介于 {0} 和 {1} 之间的字符串\"),   range: jQuery.validator.format(\"请输入一个介于 {0} 和 {1} 之间的值\"),   max: jQuery.validator.format(\"请输入一个最大为 {0} 的值\"),   min: jQuery.validator.format(\"请输入一个最小为 {0} 的值\") });<p>推荐做法，将此文件放入messages_cn.js中，在页面中引入<p>&lt;script src=\"../js/messages_cn.js\" type=\"text/javascript\"&gt;&lt;/script&gt;<p>四、使用方式<p>1.将校验规则写到控件中<p>&lt;script src=\"../js/jquery.js\" type=\"text/javascript\"&gt;&lt;/script&gt; &lt;script src=\"../js/jquery.validate.js\" type=\"text/javascript\"&gt;&lt;/script&gt; &lt;script src=\"./js/jquery.metadata.js\" type=\"text/javascript\"&gt;&lt;/script&gt; $().ready(function() {   $(\"#signupForm\").validate(); }); &lt;form id=\"signupForm\" method=\"get\" action=\"\"&gt; &lt;p&gt;&lt;label for=\"firstname\"&gt;Firstname&lt;/label&gt; &lt;input id=\"firstname\" name=\"firstname\" class=\"required\" /&gt; &lt;/p&gt; &lt;p&gt;&lt;label for=\"email\"&gt;E-Mail&lt;/label&gt; &lt;input id=\"email\" name=\"email\" class=\"required email\" /&gt; &lt;/p&gt; &lt;p&gt;&lt;label for=\"password\"&gt;Password&lt;/label&gt; &lt;input id=\"password\" name=\"password\"  type=\"password\" class=\"{required:true,minlength:5}\" /&gt; &lt;/p&gt; &lt;p&gt;&lt;label for=\"confirm_password\"&gt;确认密码&lt;/label&gt; &lt;input id=\"confirm_password\" name=\"confirm_password\"  type=\"password\" class=\"{required:true,minlength:5,equalTo:\'#password\'}\" /&gt; &lt;/p&gt; &lt;p&gt;&lt;input class=\"submit\" type=\"submit\" value=\"Submit\"/&gt; &lt;/p&gt; &lt;/form&gt;<p>使用class=\"{}\"的方式，必须引入包：jquery.metadata.js可以使用如下的方法，修改提示内容：<p>class=\"{required:true,minlength:5,messages:{required:\'请输入内容\'}}\"<p>在使用equalTo关键字时，后面的内容必须加上引号，如下代码：<p>class=\"{required:true,minlength:5,equalTo:\'#password\'}\"<p>另外一个方式，使用关键字：meta（为了元数据使用其他插件，你要包装你的验证规则，在他们自己的项目中可以用这个特殊的选项）<p>Tell the validation plugin to look inside a validate-property in metadata for validation rules.<p>例如：<p>meta: \"validate\"  &lt;input id=\"password\" name=\"password\" type=\"password\" class=\"{validate:{required:true,minlength:5}}\" /&gt;<p>再有一种方式：<p>$.metadata.setType(\"attr\", \"validate\");<p>这样可以使用validate=\"{required:true}\"的方式，或者class=\"required\"，但class=\"{required:true,minlength:5}\"将不起作用<p>2.将校验规则写到代码中<p>$().ready(function() {   $(\"#unionRegForm\").validate({     rules: {       username:{ required:true, rangelength:[6,15] },       email:{ required:true, email:true},       password:{ required:true, rangelength:[6,15]},       password2:{ required:true, rangelength:[6,15], equalTo: \"#password\"}     },     messages: {       username:{ required:\"请输入用户名\", rangelength:\"用户名长度在6-15位之间\"},       email:{ required:\"请输入Email地址\", email:\"请输入正确的email地址\"},       password:{ required:\"请输入密码\", rangelength:\"密码长度在6-15位之间\"},       password2:{ required:\"请输入确认密码\", rangelength:\"确认密码不能小于6个字符\", equalTo:\"两次输入密码不一致不一致\"}     }   }); });<p>//messages处，如果某个控件没有message，将调用默认的信息<p>&lt;form id=\"signupForm\" method=\"get\" action=\"\"&gt; &lt;p&gt;&lt;label for=\"firstname\"&gt;Firstname&lt;/label&gt; &lt;input id=\"firstname\" name=\"firstname\" /&gt; &lt;/p&gt; &lt;p&gt;&lt;label for=\"email\"&gt;E-Mail&lt;/label&gt; &lt;input id=\"email\" name=\"email\" /&gt; &lt;/p&gt; &lt;p&gt;&lt;label for=\"password\"&gt;Password&lt;/label&gt; &lt;input id=\"password\" name=\"password\" type=\"password\" /&gt; &lt;/p&gt; &lt;p&gt;&lt;label for=\"confirm_password\"&gt;确认密码&lt;/label&gt; &lt;input id=\"confirm_password\" name=\"confirm_password\" type=\"password\" /&gt; &lt;/p&gt; &lt;p&gt;&lt;input class=\"submit\" type=\"submit\" value=\"Submit\"/&gt; &lt;/p&gt; &lt;/form&gt;<p>required:true 必须有值 required:\"#aa:checked\"表达式的值为真，则需要验证 required:function(){}返回为真，表时需要验证<p>后边两种常用于，表单中需要同时填或不填的元素<p>五、常用方法及注意问题<p>1.用其他方式替代默认的submit<p>$().ready(function(){   $(\"#signupForm\").validate({     submitHandler:function(form){       alert(\"submitted\");          form.submit();     }   }); });<p>可以设置validate的默认值，写法如下：<p>$.validator.setDefaults({  submitHandler: function(form) { alert(\"submitted!\");form.submit(); } });<p>如果想提交表单，需要使用form.submit()而不要使用$(form).submit()<p>2.debug，如果这个参数为true，那么表单不会提交，只进行检查，调试时十分方便<p>$().ready(function() {   $(\"#signupForm\").validate({       debug:true   }); });<p>如果一个页面中有多个表单，用<p>$.validator.setDefaults({    debug: true })<p>3.ignore：忽略某些元素不验证<p>ignore: \".ignore\"<p>4.errorPlacement：Callback Default: 把错误信息放在验证的元素后面<p>指明错误放置的位置，默认情况是：error.appendTo(element.parent());即把错误信息放在验证的元素后面<p>errorPlacement: function(error, element) {      error.appendTo(element.parent());  }<p>//示例<p>&lt;tr&gt;     &lt;td class=\"label\"&gt;&lt;label id=\"lfirstname\" for=\"firstname\"&gt;First Name&lt;/label&gt;&lt;/td&gt;     &lt;td class=\"field\"&gt;&lt;input id=\"firstname\" name=\"firstname\" type=\"text\" value=\"\" maxlength=\"100\" /&gt;&lt;/td&gt;     &lt;td class=\"status\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;     &lt;td style=\"padding-right: 5px;\"&gt;         &lt;input id=\"dateformat_eu\" name=\"dateformat\" type=\"radio\" value=\"0\" /&gt;         &lt;label id=\"ldateformat_eu\" for=\"dateformat_eu\"&gt;14/02/07&lt;/label&gt;     &lt;/td&gt;     &lt;td style=\"padding-left: 5px;\"&gt;         &lt;input id=\"dateformat_am\" name=\"dateformat\" type=\"radio\" value=\"1\"  /&gt;         &lt;label id=\"ldateformat_am\" for=\"dateformat_am\"&gt;02/14/07&lt;/label&gt;     &lt;/td&gt;     &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;     &lt;td class=\"label\"&gt;&lt;/td&gt;     &lt;td class=\"field\" colspan=\"2\"&gt;         &lt;div id=\"termswrap\"&gt;             &lt;input id=\"terms\" type=\"checkbox\" name=\"terms\" /&gt;             &lt;label id=\"lterms\" for=\"terms\"&gt;I have read and accept the Terms of Use.&lt;/label&gt;         &lt;/div&gt;     &lt;/td&gt; &lt;/tr&gt;<p>errorPlacement: function(error, element) {     if ( element.is(\":radio\") )         error.appendTo( element.parent().next().next() );     else if ( element.is(\":checkbox\") )         error.appendTo ( element.next() );     else         error.appendTo( element.parent().next() ); }<p>代码的作用是：一般情况下把错误信息显示在&lt;td class=\"status\"&gt;&lt;/td&gt;中，如果是radio显示在&lt;td&gt;&lt;/td&gt;中，如果是 checkbox显示在内容的后面<p>errorClass：String  Default: \"error\"<p> //指定错误提示的css类名，可以自定义错误提示的样式<p>errorElement:String  Default: \"label\"<p> //用什么标签标记错误，默认的是label你可以改成em<p>errorContainer:Selector<p> //显示或者隐藏验证信息，可以自动实现有错误信息出现时把容器属性变为显示，无错误时隐藏，用处不大<p> errorContainer: \"#messageBox1, #messageBox2\"<p>errorLabelContainer:Selector<p> //把错误信息统一放在一个容器里面。<p>wrapper:String<p> //用什么标签再把上边的errorELement包起来<p>一般这三个属性同时使用，实现在一个容器内显示所有错误提示的功能，并且没有信息时自动隐藏<p>errorContainer: \"div.error\", errorLabelContainer: $(\"#signupForm div.error\"), wrapper: \"li\"<p>5.更改错误信息显示的样式<p>设置错误提示的样式，可以增加图标显示，在该系统中已经建立了一个validation.css专门用于维护校验文件的样式<p>input.error { border: 1px solid red; } label.error {   background:url(\"./demo/images/unchecked.gif\") no-repeat 0px 0px;   padding-left: 16px;   padding-bottom: 2px;   font-weight: bold;   color: #EA5200; } label.checked {   background:url(\"./demo/images/checked.gif\") no-repeat 0px 0px; }<p>6.每个字段验证通过执行函数<p>success：String,Callback<p>要验证的元素通过验证后的动作，如果跟一个字符串，会当做一个css类，也可跟一个函数<p>success: function(label) {     // set  as text for IE     label.html(\"\").addClass(\"checked\");     //label.addClass(\"valid\").text(\"Ok!\") }<p>添加\"valid\" 到验证元素, 在CSS中定义的样式&lt;style&gt;label.valid {}&lt;/style&gt;<p>success: \"valid\"<p>7.验证的触发方式修改<p>下面的虽然是boolean型的，但建议除非要改为false,否则别乱添加。<p>onsubmit:Boolean  Default: true<p> 提交时验证. 设置唯false就用其他方法去验证<p>onfocusout:Boolean  Default: true<p> 失去焦点是验证(不包括checkboxes/radio buttons)<p>onkeyup:Boolean  Default: true<p> 在keyup时验证.<p>onclick:Boolean  Default: true<p> 在checkboxes 和 radio 点击时验证<p>focusInvalid:Boolean  Default: true<p> 提交表单后，未通过验证的表单(第一个或提交之前获得焦点的未通过验证的表单)会获得焦点<p>focusCleanup:Boolean  Default: false<p> 如果是true那么当未通过验证的元素获得焦点时，移除错误提示。避免和 focusInvalid 一起用<p>// 重置表单 $().ready(function() {  var validator = $(\"#signupForm\").validate({         submitHandler:function(form){             alert(\"submitted\");               form.submit();         }        });     $(\"#reset\").click(function() {         validator.resetForm();     }); });<p>8.异步验证<p>remote：URL<p>使用ajax方式进行验证，默认会提交当前验证的值到远程地址，如果需要提交其他的值，可以使用data选项<p>remote: \"check-email.php\" remote: {     url: \"check-email.php\",     //后台处理程序     type: \"post\",               //数据发送方式     dataType: \"json\",           //接受数据格式       data: {                     //要传递的数据         username: function() {             return $(\"#username\").val();         }} }<p>远程地址只能输出 \"true\" 或 \"false\"，不能有其它输出<p>9.添加自定义校验<p>addMethod：name, method, message<p> 自定义验证方法<p>// 中文字两个字节 jQuery.validator.addMethod(\"byteRangeLength\", function(value, element, param) {     var length = value.length;     for(var i = 0; i &lt; value.length; i++){         if(value.charCodeAt(i) &gt; 127){             length++;         }     }   return this.optional(element) || ( length &gt;= param[0] &amp;&amp; length &lt;= param[1] );   }, $.validator.format(\"请确保输入的值在{0}-{1}个字节之间(一个中文字算2个字节)\"));<p>// 邮政编码验证   jQuery.validator.addMethod(\"isZipCode\", function(value, element) {       var tel = /^[0-9]{6}$/;     return this.optional(element) || (tel.test(value)); }, \"请正确填写您的邮政编码\");<p>1.要在additional-methods.js文件中添加或者在jquery.validate.js添加，建议一般写在additional-methods.js文件中<p>2.在messages_cn.js文件添加：isZipCode: \"只能包括中文字、英文字母、数字和下划线\"，调用前要添加对additional-methods.js文件的引用。<p>10.radio和checkbox、select的验证<p>1.radio的required表示必须选中一个<p>&lt;input  type=\"radio\" id=\"gender_male\" value=\"m\" name=\"gender\" class=\"{required:true}\" /&gt; &lt;input  type=\"radio\" id=\"gender_female\" value=\"f\" name=\"gender\"/&gt;<p>2.checkbox的required表示必须选中<p>&lt;input type=\"checkbox\" class=\"checkbox\" id=\"agree\" name=\"agree\" class=\"{required:true}\" /&gt;<p>checkbox的minlength表示必须选中的最小个数,maxlength表示最大的选中个数,rangelength:[2,3]表 示选中个数区间<p>&lt;input type=\"checkbox\" class=\"checkbox\" id=\"spam_email\" value=\"email\" name=\"spam[]\" class=\"{required:true, minlength:2}\" /&gt; &lt;input type=\"checkbox\" class=\"checkbox\" id=\"spam_phone\" value=\"phone\" name=\"spam[]\" /&gt; &lt;input type=\"checkbox\" class=\"checkbox\" id=\"spam_mail\" value=\"mail\" name=\"spam[]\" /&gt;<p>3.select的required表示选中的value不能为空<p>&lt;select id=\"jungle\" name=\"jungle\" title=\"Please select something!\" class=\"{required:true}\"&gt;     &lt;option value=\"\"&gt;&lt;/option&gt;     &lt;option value=\"1\"&gt;Buga&lt;/option&gt;     &lt;option value=\"2\"&gt;Baga&lt;/option&gt;     &lt;option value=\"3\"&gt;Oi&lt;/option&gt; &lt;/select&gt;<p>select的minlength表示选中的最小个数（可多选的select）,maxlength表示最大的选中个数,rangelength:[2,3]表示选中个数区间<p>&lt;select id=\"fruit\" name=\"fruit\" title=\"Please select at least two fruits\" class=\"{required:true, minlength:2}\" multiple=\"multiple\"&gt;     &lt;option value=\"b\"&gt;Banana&lt;/option&gt;     &lt;option value=\"a\"&gt;Apple&lt;/option&gt;     &lt;option value=\"p\"&gt;Peach&lt;/option&gt;     &lt;option value=\"t\"&gt;Turtle&lt;/option&gt; &lt;/select&gt;<p>本文章来源于：jQuery验证控件jquery.validate.js使用说明+中文API<p>","description":"jQuery.validate是一款非常不错的表单验证工具，简单易上手，而且能达到很好的体验效果，虽然说在项目中早已用过，但看到这篇文章写得还是不错的，转载下与大家共同分享。","category":"JavaScript","hot":"n"},{"id":52,"title":"网站性能最佳体验的34条黄金守则-内容篇","date":1352699910,"content":"<p>Yahoo!的Exceptional Performance团队为改善Web性能带来最佳实践。他们为此进行了一系列的实验、开发了各种工具、写了大量的文章和博客并在各种会议上参与探讨。最佳实践的核心就是旨在提高网站性能。 Excetional Performance团队总结出了一系列可以提高网站速度的方法。可以分为7大类34条。包括内容、服务器、cookie、CSS、JavaScript、图片、移动应用等七部分。<p>其中内容部分一共十条建议：<p>一、内容部分<p>尽量减少HTTP请求<p>减少DNS查找<p>避免跳转<p>缓存Ajxa<p>推迟加载<p>提前加载<p>减少DOM元素数量<p>用域名划分页面内容<p>使frame数量最少<p>避免404错误<p>1、尽量减少HTTP请求次数<p>终端用户响应的时间中，有80%用于下载各项内容。这部分时间包括下载页面中的图像、样式表、脚本、Flash等。通过减少页面中的元素可以减少HTTP请求的次数。这是提高网页速度的关键步骤。<p>减少页面组件的方法其实就是简化页面设计。那么有没有一种方法既能保持页面内容的丰富性又能达到加快响应时间的目的呢？这里有几条减少HTTP请求次数同时又可能保持页面内容丰富的技术。<p>合并文件是通过把所有的脚本放到一个文件中来减少HTTP请求的方法，如可以简单地把所有的CSS文件都放入一个样式表中。当脚本或者样式表在不同页面中使用时需要做不同的修改，这可能会相对麻烦点，但即便如此也要把这个方法作为改善页面性能的重要一步。<p>CSS Sprites是减少图像请求的有效方法。把所有的背景图像都放到一个图片文件中，然后通过CSS的background-image和background-position属性来显示图片的不同部分；<p>图片地图是把多张图片整合到一张图片中。虽然文件的总体大小不会改变，但是可以减少HTTP请求次数。图片地图只有在 图片的所有组成部分在页面中是紧挨在一起的时候才能使用，如导航栏。确定图片的坐标和可能会比较繁琐且容易出错，同时使用图片地图导航也不具有可读性，因 此不推荐这种方法；<p>内联图像是使用data:URL scheme的方法把图像数据加载页面中。这可能会增加页面的大小。把内联图像放到样式表（可缓存）中可以减少HTTP请求同时又避免增加页面文件的大小。但是内联图像现在还没有得到主流浏览器的支持。<p>减少页面的HTTP请求次数是你首先要做的一步。这是改进首次访问用户等待时间的最重要的方法。如同Tenni Theurer的他的博客Browser Cahe Usage - Exposed!中所说，HTTP请求在无缓存情况下占去了40%到60%的响应时间。让那些初次访问你网站的人获得更加快速的体验吧！<p>2、减少DNS查找次数<p>域名系统（DNS）提供了域名和IP的对应关系，就像电话本中人名和他们的电话号码的关系一样。当你在浏览器地址栏中输入www.newshunyi.cn时，DNS解析服务器就会返回这个域名对应的IP地址。DNS解析的过程同样也是需要时间的。一般情况下返回给定域名对应的IP地址会花费20到120毫秒的时间。而且在这个过程中浏览器什么都不会做直到DNS查找完毕。<p>缓存DNS查找可以改善页面性能。这种缓存需要一个特定的缓存服务器，这种服务器一般属于用户的ISP提供商或者本地局域网控制，但是它同样会在用户使用 的计算机上产生缓存。DNS信息会保留在操作系统的DNS缓存中（微软Windows系统中DNS Client Service）。大多数浏览器有独立于操作系统以外的自己的缓存。由于浏览器有自己的缓存记录，因此在一次请求中它不会受到操作系统的影响。<p>Internet Explorer默认情况下对DNS查找记录的缓存时间为30分钟，它在注册表中的键值为DnsCacheTimeout。Firefox对DNS的查找 记录缓存时间为1分钟，它在配置文件中的选项为network.dnsCacheExpiration（Fasterfox把这个选项改为了1小时）。<p>当客户端中的DNS缓存都为空时（浏览器和操作系统都为空），DNS查找的次数和页面中主机名的数量相同。这其中包括页面中URL、图片、脚本文件、样式表、Flash对象等包含的主机名。减少主机名的数量可以减少DNS查找次数。<p>减少主机名的数量还可以减少页面中并行下载的数量。减少DNS查找次数可以节省响应时间，但是减少并行下载却会增加响应时间。我的指导原则是把这些页面中 的内容分割成至少两部分但不超过四部分。这种结果就是在减少DNS查找次数和保持较高程度并行下载两者之间的权衡了。<p><srong style=\"font-weight:bold;\">3、避免跳转</srong><p>跳转是使用301和302代码实现的。下面是一个响应代码为301的HTTP头：<p>HTTP/1.1 301 Moved Permanently<p>Location: http://example.com/newuri<p>Content-Type: text/html<p>浏览器会把用户指向到Location中指定的URL。头文件中的所有信息在一次跳转中都是必需的，内容部分可以为空。不管他们的名称，301和302响 应都不会被缓存除非增加一个额外的头选项，如Expires或者Cache-Control来指定它缓存。&lt;meat /&gt;元素的刷新标签和JavaScript也可以实现URL的跳转，但是如果你必须要跳转的时候，最好的方法就是使用标准的3XXHTTP状态代 码，这主要是为了确保“后退”按钮可以正确地使用。<p>但是要记住跳转会降低用户体验。在用户和HTML文档中间增加一个跳转，会拖延页面中所有元素的显示，因为在HTML文件被加载前任何文件（图像、Flash等）都不会被下载。<p>有一种经常被网页开发者忽略却往往十分浪费响应时间的跳转现象。这种现象发生在当URL本该有斜杠（/）却被忽略掉时。例如，当我们要访问http: //astrology.yahoo.com/astrology 时，实际上返回的是一个包含301代码的跳转，它指向的是http://astrology.yahoo.com/astrology/ （注意末尾的斜杠）。在Apache服务器中可以使用Alias 或者 mod_rewrite或者the DirectorySlash来避免。<p>连接新网站和旧网站是跳转功能经常被用到的另一种情况。这种情况下往往要连接网站的不同内容然后根据用户的不同类型（如浏览器类型、用户账号所属类型）来 进行跳转。使用跳转来实现两个网站的切换十分简单，需要的代码量也不多。尽管使用这种方法对于开发者来说可以降低复杂程度，但是它同样降低用户体验。一个 可替代方法就是如果两者在同一台服务器上时使用Alias和mod_rewrite和实现。如果是因为域名的不同而采用跳转，那么可以通过使用Alias 或者mod_rewirte建立CNAME（保存一个域名和另外一个域名之间关系的DNS记录）来替代。<p>4、可缓存的AJAX<p>Ajax经常被提及的一个好处就是由于其从后台服务器传输信息的异步性而为用户带来的反馈的即时性。但是，使用Ajax并不能保证用户不会在等待异步的 JavaScript和XML响应上花费时间。在很多应用中，用户是否需要等待响应取决于Ajax如何来使用。例如，在一个基于Web的Email客户端 中，用户必须等待Ajax返回符合他们条件的邮件查询结果。记住一点，“异步”并不异味着“即时”，这很重要。<p>为了提高性能，优化Ajax响应是很重要的。提高Ajxa性能的措施中最重要的方法就是使响应具有可缓存性，具体的讨论可以查看Add an Expires or a Cache-Control Header。其它的几条规则也同样适用于Ajax：<p>Gizp压缩文件<p>减少DNS查找次数<p>精简JavaScript<p>避免跳转<p>配置ETags<p>让我们来看一个例子：一个Web2.0的Email客户端会使用Ajax来自动完成对用户地址薄的下载。如果用户在上次使用过Email web应用程序后没有对地址薄作任何的修改，而且Ajax响应通过Expire或者Cacke-Control头来实现缓存，那么就可以直接从上一次的缓 存中读取地址薄了。必须告知浏览器是使用缓存中的地址薄还是发送一个新的请求。这可以通过为读取地址薄的Ajax URL增加一个含有上次编辑时间的时间戳来实现，例如，&amp;t=11900241612等。如果地址薄在上次下载后没有被编辑过，时间戳就不变，则 从浏览器的缓存中加载从而减少了一次HTTP请求过程。如果用户修改过地址薄，时间戳就会用来确定新的URL和缓存响应并不匹配，浏览器就会重要请求更新 地址薄。<p>即使你的Ajxa响应是动态生成的，哪怕它只适用于一个用户，那么它也应该被缓存起来。这样做可以使你的Web2.0应用程序更加快捷。<p>5、推迟加载内容<p>你可以仔细看一下你的网页，问问自己“哪些内容是页面呈现时所必需首先加载的？哪些内容和结构可以稍后再加载？<p>把整个过程按照onload事件分隔成两部分，JavaScript是一个理想的选择。例如，如果你有用于实现拖放和动画的JavaScript，那么它 就以等待稍后加载，因为页面上的拖放元素是在初始化呈现之后才发生的。其它的例如隐藏部分的内容（用户操作之后才显现的内容）和处于折叠部分的图像也可以 推迟加载<p>工具可以节省你的工作量：YUI Image Loader可以帮你推迟加载折叠部分的图片，YUI Get utility是包含JS和 CSS的便捷方法。比如你可以打开Firebug的Net选项卡看一下Yahoo的首页。<p>当性能目标和其它网站开发实践一致时就会相得益彰。这种情况下，通过程序提高网站性能的方法告诉我们，在支持JavaScript的情况下，可以先去除用 户体验，不过这要保证你的网站在没有JavaScript也可以正常运行。在确定页面运行正常后，再加载脚本来实现如拖放和动画等更加花哨的效果。<p>6、预加载<p>预加载和后加载看起来似乎恰恰相反，但实际上预加载是为了实现另外一种目标。预加载是在浏览器空闲时请求将来可能会用到的页面内容（如图像、样式表和脚 本）。使用这种方法，当用户要访问下一个页面时，页面中的内容大部分已经加载到缓存中了，因此可以大大改善访问速度。<p>下面提供了几种预加载方法：<p>无条件加载：触发onload事件时，直接加载额外的页面内容。以Google.com为例，你可以看一下它的spirit image图像是怎样在onload中加载的。这个spirit image图像在google.com主页中是不需要的，但是却可以在搜索结果页面中用到它。<p>有条件加载：根据用户的操作来有根据地判断用户下面可能去往的页面并相应的预加载页面内容。在search.yahoo.com中你可以看到如何在你输入内容时加载额外的页面内容。<p>有预期的加载：载入重新设计过的页面时使用预加载。这种情况经常出现在页面经过重新设计后用户抱怨“新的页面看起来很 酷，但是却比以前慢”。问题可能出在用户对于你的旧站点建立了完整的缓存，而对于新站点却没有任何缓存内容。因此你可以在访问新站之前就加载一部内容来避 免这种结果的出现。在你的旧站中利用浏览器的空余时间加载新站中用到的图像的和脚本来提高访问速度。<p>7、减少DOM元素数量<p>一个复杂的页面意味着需要下载更多数据，同时也意味着JavaScript遍历DOM的效率越慢。比如当你增加一个事件句柄时在500和5000个DOM元素中循环效果肯定是不一样的。<p>大量的DOM元素的存在意味着页面中有可以不用移除内容只需要替换元素标签就可以精简的部分。你在页面布局中使用表格了吗？你有没有仅仅为了布局而引入更多的&lt;div&gt;元素呢？也许会存在一个适合或者在语意是更贴切的标签可以供你使用。<p>YUI CSS utilities可以给你的布局带来巨大帮助：grids.css可以帮你实现整体布局，font.css和reset.css可以帮助你移除浏览器默 认格式。它提供了一个重新审视你页面中标签的机会，比如只有在语意上有意义时才使用，而不是因为它具有换行效果才使用它。<p>DOM元素数量很容易计算出来，只需要在Firebug的控制台内输入：<p>document.getElementsByTagName(\'*\').length<p>那么多少个DOM元素算是多呢？这可以对照有很好标记使用的类似页面。比如Yahoo!主页是一个内容非常多的页面，但是它只使用了700个元素（HTML标签）。<p>8、根据域名划分页面内容<p>把页面内容划分成若干部分可以使你最大限度地实现平行下载。由于DNS查找带来的影响你首先要确保你使用的域名数量在2个到4个之间。例如，你可以把用到 的HTML内容和动态内容放在www.example.org上，而把页面各种组件（图片、脚本、CSS)分别存放在 statics1.example.org和statics.example.org上。<p>你可在Tenni Theurer和Patty Chi合写的文章Maximizing Parallel Downloads in the Carpool Lane找到更多相关信息。<p>9、使iframe的数量最小<p>ifrmae元素可以在父文档中插入一个新的HTML文档。了解iframe的工作理然后才能更加有效地使用它，这一点很重要。<p>&lt;iframe&gt;优点：<p>解决加载缓慢的第三方内容如图标和广告等的加载问题<p>Security sandbox<p>并行加载脚本<p>&lt;iframe&gt;的缺点：<p>即时内容为空，加载也需要时间<p>会阻止页面加载<p>没有语意<p>10、不要出现404错误<p>HTTP请求时间消耗是很大的，因此使用HTTP请求来获得一个没有用处的响应（例如404没有找到页面）是完全没有必要的，它只会降低用户体验而不会有一点好处。<p>有些站点把404错误响应页面改为“你是不是要找***”，这虽然改进了用户体验但是同样也会浪费服务器资源（如数据库等）。最糟糕的情况是指向外部JavaScript的链接出现问题并返回404代码。首先，这种加载会破坏并行加载；其次浏览器会把试图在返回的404响应内容中找到可能有用的部分当 作JavaScript代码来执行。<p>本文章来源于：Yahoo!网站性能最佳体验的34条黄金守则-内容<p>","description":"Yahoo!的Exceptional Performance团队为改善Web性能带来最佳实践。他们为此进行了一系列的实验、开发了各种工具、写了大量的文章和博客并在各种会议上参与探讨。最佳实践的核心就是旨在提高网站性能。 Excetional Performance团队总结出了一系列可以提高网站速度的方法。可以分为7大类34条。包括内容、服务器、cookie、CSS、JavaScript、图片、移动应用等七部分。","category":"杂谈","hot":"n"},{"id":53,"title":"网站性能最佳体验的34条黄金守则-服务器篇","date":1352704484,"content":"<p>Yahoo!的Exceptional Performance团队为改善Web性能带来最佳实践。他们为此进行了一系列的实验、开发了各种工具、写了大量的文章和博客并在各种会议上参与探讨。最佳实践的核心就是旨在提高网站性能。 Excetional Performance团队总结出了一系列可以提高网站速度的方法。可以分为7大类34条。包括内容、服务器、cookie、CSS、JavaScript、图片、移动应用等七部分。<p>其中服务器部分一共六条建议：<p>二、服务器部分<p>使用内容分发网络<p>为文件头指定Expires或Cache-Control<p>Gzip压缩文件内容<p>配置ETag<p>尽早刷新输出缓冲<p>使用GET来完成AJAX请求<p>11、使用内容分发网络<p>用户与你网站服务器的接近程度会影响响应时间的长短。把你的网站内容分散到多个、处于不同地域位置的服务器上可以加快下载速度。但是首先我们应该做些什么呢？<p>按地域布置网站内容的第一步并不是要尝试重新架构你的网站让他们在分发服务器上正常运行。根据应用的需求来改变网站结构，这可能会包括一些比较复杂的任 务，如在服务器间同步Session状态和合并数据库更新等。要想缩短用户和内容服务器的距离，这些架构步骤可能是不可避免的。<p>要记住，在终端用户的响应时间中有80%到90%的响应时间用于下载图像、样式表、脚本、Flash等页面内容。这就是网站性能黄金守则。和重新设计你的 应用程序架构这样比较困难的任务相比，首先来分布静态内容会更好一点。这不仅会缩短响应时间，而且对于内容分发网络来说它更容易实现。<p>内容分发网络（Content Delivery Network，CDN）是由一系列分散到各个不同地理位置上的Web服务器组成的，它提高了网站内容的传输速度。用于向用户传输内容的服务器主要是根据 和用户在网络上的靠近程度来指定的。例如，拥有最少网络跳数（network hops）和响应速度最快的服务器会被选定。<p>一些大型的网络公司拥有自己的CDN，但是使用像Akamai Technologies，Mirror Image Internet， 或者Limelight Networks这 样的CDN服务成本却非常高。对于刚刚起步的企业和个人网站来说，可能没有使用CDN的成本预算，但是随着目标用户群的不断扩大和更加全球化，CDN就是 实现快速响应所必需的了。以Yahoo来说，他们转移到CDN上的网站程序静态内容节省了终端用户20%以上的响应时间。使用CDN是一个只需要相对简单 地修改代码实现显著改善网站访问速度的方法。<p>12、为文件头指定Expires或Cache-Control<p>这条守则包括两方面的内容：<p>对于静态内容：设置文件头过期时间Expires的值为“Never expire”（永不过期） 对于动态内容：使用恰当的Cache-Control文件头来帮助浏览器进行有条件的请求<p>网页内容设计现在越来越丰富，这就意味着页面中要包含更多的脚本、样式表、图片和Flash。第一次访问你页面的用户就意味着进行多次的HTTP请求，但 是通过使用Expires文件头就可以使这样内容具有缓存性。它避免了接下来的页面访问中不必要的HTTP请求。Expires文件头经常用于图像文件， 但是应该在所有的内容都使用他，包括脚本、样式表和Flash等。<p>浏览器（和代理）使用缓存来减少HTTP请求的大小和次数以加快页面访问速度。Web服务器在HTTP响应中使用Expires文件头来告诉客户端内容需 要缓存多长时间。下面这个例子是一个较长时间的Expires文件头，它告诉浏览器这个响应直到2010年4月15日才过期。<p>Expires: Thu, 15 Apr 2010 20:00:00 GMT<p>如果你使用的是Apache服务器，可以使用ExpiresDefault来设定相对当前日期的过期时间。下面这个例子是使用ExpiresDefault来设定请求时间后10年过期的文件头：<p>ExpiresDefault \"access plus 10 years\" 要切记，如果使用了Expires文件头，当页面内容改变时就必须改变内容的文件名。依Yahoo!来说我们经常使用这样的步骤：在内容的文件名中加上版本号，如yahoo_2.0.6.js。<p>使用Expires文件头只有会在用户已经访问过你的网站后才会起作用。当用户首次访问你的网站时这对减少HTTP请求次数来说是无效的，因为浏览器的缓 存是空的。因此这种方法对于你网站性能的改进情况要依据他们“预缓存”存在时对你页面的点击频率（“预缓存”中已经包含了页面中的所有内容）。Yahoo!建立了一套测量方法，我们发现所有的页面浏览量中有75~85%都有“预缓存”。通过使用Expires文件头，增加了缓存在浏览器中内容的数量，并且可以在用户接下来的请求中再次使用这些内容，这甚至都不需要通过用户发送一个字节的请求。<p>13、Gzip压缩文件内容<p> 网络传输中的HTTP请求和应答时间可以通过前端机制得到显著改善。的确，终端用户的带宽、互联网提供者、与对等交换点的靠近程度等都不是网站开发者所能决定的。但是还有其他因素影响着响应时间。通过减小HTTP响应的大小可以节省HTTP响应时间。 从HTTP/1.1开始，web客户端都默认支持HTTP请求中有Accept-Encoding文件头的压缩格式：<p><p>Accept-Encoding: gzip, deflate<p>如果web服务器在请求的文件头中检测到上面的代码，就会以客户端列出的方式压缩响应内容。Web服务器把压缩方式通过响应文件头中的Content-Encoding来返回给浏览器。<p>Content-Encoding: gzip<p>Gzip是目前最流行也是最有效的压缩方式。这是由GNU项目开发并通过RFC 1952来标准化的。另外仅有的一个压缩格式是deflate，但是它的使用范围有限效果也稍稍逊色。<p>Gzip大概可以减少70%的响应规模。目前大约有90%通过浏览器传输的互联网交换支持gzip格式。如果你使用的是Apache，gzip模块配置和你的版本有关：Apache 1.3使用mod_zip，而Apache 2.x使用moflate。<p>浏览器和代理都会存在这样的问题：浏览器期望收到的和实际接收到的内容会存在不匹配的现象。幸好，这种特殊情况随着旧式浏览器使用量的减少在减少。Apache模块会通过自动添加适当的Vary响应文件头来避免这种状况的出现。<p>服务器根据文件类型来选择需要进行gzip压缩的文件，但是这过于限制了可压缩的文件。大多数web服务器会压缩HTML文档。对脚本和样式表进行压缩同 样也是值得做的事情，但是很多web服务器都没有这个功能。实际上，压缩任何一个文本类型的响应，包括XML和JSON，都值得的。图像和PDF文件由于 已经压缩过了所以不能再进行gzip压缩。如果试图gizp压缩这些文件的话不但会浪费CPU资源还会增加文件的大小。<p>Gzip压缩所有可能的文件类型是减少文件体积增加用户体验的简单方法。<p>14、配置ETag<p>Entity tags（ETags）（实体标签）是web服务器和浏览器用于判断浏览器缓存中的内容和服务器中的原始内容是否匹配的一种机制（“实体”就是所说的“内 容”，包括图片、脚本、样式表等）。增加ETag为实体的验证提供了一个比使用“last-modified date（上次编辑时间）”更加灵活的机制。Etag是一个识别内容版本号的唯一字符串。唯一的格式限制就是它必须包含在双引号内。原始服务器通过含有 ETag文件头的响应指定页面内容的ETag。<p>HTTP/1.1 200 OK<p>Last-Modified: Tue, 12 Dec 2006 03:03:59 GMT<p>ETag: \"10c24bc-4ab-457e1c1f\"<p>Content-Length: 12195<p>稍后，如果浏览器要验证一个文件，它会使用If-None-Match文件头来把ETag传回给原始服务器。在这个例子中，如果ETag匹配，就会返回一 个304状态码，这就节省了12195字节的响应。GET /i/yahoo.gif HTTP/1.1<p>Host: us.yimg.com<p>If-Modified-Since: Tue, 12 Dec 2006 03:03:59 GMT<p>If-None-Match: \"10c24bc-4ab-457e1c1f\"<p>HTTP/1.1 304 Not Modified<p>ETag的问题在于，它是根据可以辨别网站所在的服务器的具有唯一性的属性来生成的。当浏览器从一台服务器上获得页面内容后到另外一台服务器上进行验证时 ETag就会不匹配，这种情况对于使用服务器组和处理请求的网站来说是非常常见的。默认情况下，Apache和IIS都会把数据嵌入ETag中，这会显著 减少多服务器间的文件验证冲突。<p>Apache 1.3和2.x中的ETag格式为inode-size-timestamp。即使某个文件在不同的服务器上会处于相同的目录下，文件大小、权限、时间戳等都完全相同，但是在不同服务器上他们的内码也是不同的。<p>IIS 5.0和IIS 6.0处理ETag的机制相似。IIS中的ETag格式为Filetimestamp:ChangeNumber。用ChangeNumber来跟踪 IIS配置的改变。网站所用的不同IIS服务器间ChangeNumber也不相同。 不同的服务器上的Apache和IIS即使对于完全相同的内容产生的ETag在也不相同，用户并不会接收到一个小而快的304响应；相反他们会接收一个正 常的200响应并下载全部内容。如果你的网站只放在一台服务器上，就不会存在这个问题。但是如果你的网站是架设在多个服务器上，并且使用Apache和 IIS产生默认的ETag配置，你的用户获得页面就会相对慢一点，服务器会传输更多的内容，占用更多的带宽，代理也不会有效地缓存你的网站内容。即使你的 内容拥有Expires文件头，无论用户什么时候点击“刷新”或者“重载”按钮都会发送相应的GET请求。<p>如果你没有使用ETag提供的灵活的验证模式，那么干脆把所有的ETag都去掉会更好。Last-Modified文件头验证是基于内容的时间戳的。去掉ETag文件头会减少响应和下次请求中文件的大小。微软的这篇支持文稿讲述了如何去掉ETag。在Apache中，只需要在配置文件中简单添加下面一行代码就可以了：<p>FileETag none<p>15、尽早刷新输出缓冲<p>当用户请求一个页面时，无论如何都会花费200到500毫秒用于后台组织HTML文件。在这期间，浏览器会一直空闲等待数据返回。在PHP中，你可以使用 flush()方法，它允许你把已经编译的好的部分HTML响应文件先发送给浏览器，这时浏览器就会可以下载文件中的内容（脚本等）而后台同时处理剩余的 HTML页面。这样做的效果会在后台烦恼或者前台较空闲时更加明显。<p>输出缓冲应用最好的一个地方就是紧跟在&lt;head /&gt;之后，因为HTML的头部分容易生成而且头部往往包含CSS和JavaScript文件，这样浏览器就可以在后台编译剩余HTML的同时并行下载它们。 例子：<p>... &lt;!-- css, js --&gt;<p><p>&lt;/head&gt;<p> ,p&gt;&lt;?php<p><p>flush(); ?&gt;<p>&lt;body&gt;<p>... &lt;!-- content --&gt;<p>为了证明使用这项技术的好处，Yahoo!搜索率先研究并完成了用户测试。<p>16、使用GET来完成AJAX请求<p>Yahoo!Mail团队发现，当使用XMLHttpRequest时，浏览器中的POST方法是一个“两步走”的过程：首先发送文件头，然后才发送数据。因此使用GET最为恰当，因为它只需发送一个TCP包（除非你有很多cookie）。IE中URL的最大长度为2K，因此如果你要发送一个超过2K的数据时就不能使用GET 了。<p>一个有趣的不同就是POST并不像GET那样实际发送数据。根据HTTP规范，GET意味着“获取”数据，因此当你仅仅获取数据时使用GET更加有意义（从语意上讲也是如此），相反，发送并在服务端保存数据时使用POST。<p>本文章来源于：Yahoo!网站性能最佳体验的34条黄金守则-内容<p>","description":"Yahoo!的Exceptional Performance团队为改善Web性能带来最佳实践。他们为此进行了一系列的实验、开发了各种工具、写了大量的文章和博客并在各种会议上参与探讨。最佳实践的核心就是旨在提高网站性能。 Excetional Performance团队总结出了一系列可以提高网站速度的方法。可以分为7大类34条。包括内容、服务器、cookie、CSS、JavaScript、图片、移动应用等七部分。","category":"杂谈","hot":"n"},{"id":54,"title":"网站性能最佳体验的34条黄金守则-JavaScript和CSS","date":1352706463,"content":"<p>Yahoo!的Exceptional Performance团队为改善Web性能带来最佳实践。他们为此进行了一系列的实验、开发了各种工具、写了大量的文章和博客并在各种会议上参与探讨。最佳实践的核心就是旨在提高网站性能。 Excetional Performance团队总结出了一系列可以提高网站速度的方法。可以分为7大类34条。包括内容、服务器、cookie、CSS、JavaScript、图片、移动应用等七部分。<p>其中JavaScript和CSS部分一共十条建议：<p>三、JavaScript和CSS部分<p>CSS：<p>把样式表置于顶部<p>避免使用CSS表达式（Expression）<p>使用外部JavaScript和CSS<p>削减JavaScript和CSS<p>用<link>代替@import<p>避免使用滤镜<p>JavaScript：<p>把脚本置于页面底部<p>使用外部JavaScript和CSS<p>削减JavaScript和CSS<p>剔除重复脚本<p>减少DOM访问<p>开发智能事件处理程序<p>17、把样式表置于顶部<p>在研究Yahoo!的性能表现时，我们发现把样式表放到文档的&lt;head /&gt;内部似乎会加快页面的下载速度。这是因为把样式表放到&lt;head /&gt;内会使页面有步骤的加载显示。<p>注重性能的前端服务器往往希望页面有秩序地加载。同时，我们也希望浏览器把已经接收到内容尽可能显示出来。这对于拥有较多内容的页面和网速较慢的用户来说特别重要。向用户返回可视化的反馈，比如进程指针，已经有了较好的研究并形成了正式文档。在我们的研究中HTML页面就是进程指针。当浏览器有序地加载文件头、导航栏、顶部的logo等对于等待页面加载的用户来说都可以作为可视化的反馈。这从整体上改善了用户体验。<p>把样式表放在文档底部的问题是在包括Internet Explorer在内的很多浏览器中这会中止内容的有序呈现。浏览器中止呈现是为了避免样式改变引起的页面元素重绘。用户不得不面对一个空白页面。<p>HTML规范清 楚指出样式表要放包含在页面的&lt;head /&gt;区域内：“和&lt;a /&gt;不同，&lt;link /&gt;只能出现在文档的&lt;head /&gt;区域内，尽管它可以多次使用它”。无论是引起白屏还是出现没有样式化的内容都不值得去尝试。最好的方案就是按照HTML规范在文档&lt; head /&gt;内加载你的样式表。<p>18、避免使用CSS表达式（Expression）<p>CSS表达式是动态设置CSS属性的强大（但危险）方法。Internet Explorer从第5个版本开始支持CSS表达式。下面的例子中，使用CSS表达式可以实现隔一个小时切换一次背景颜色：<p>background-color: expression( (new Date()).getHours()%2 ? \"#B8D4FF\" : \"#F08A00\" );<p>如上所示，expression中使用了JavaScript表达式。CSS属性根据JavaScript表达式的计算结果来设置。expression方法在其它浏览器中不起作用，因此在跨浏览器的设计中单独针对Internet Explorer设置时会比较有用。<p>表达式的问题就在于它的计算频率要比我们想象的多。不仅仅是在页面显示和缩放时，就是在页面滚动、乃至移动鼠标时都会要重新计算一次。给CSS表达式增加一个计数器可以跟踪表达式的计算频率。在页面中随便移动鼠标都可以轻松达到10000次以上的计算量。<p>一个减少CSS表达式计算次数的方法就是使用一次性的表达式，它在第一次运行时将结果赋给指定的样式属性，并用这个属性来代替CSS表达式。如果样式属性 必须在页面周期内动态地改变，使用事件句柄来代替CSS表达式是一个可行办法。如果必须使用CSS表达式，一定要记住它们要计算成千上万次并且可能会对你 页面的性能产生影响。<p>19、使用外部JavaScript和CSS<p>很多性能规则都是关于如何处理外部文件的。但是，在你采取这些措施前你可能会问到一个更基本的问题：JavaScript和CSS是应该放在外部文件中呢还是把它们放在页面本身之内呢？<p>在实际应用中使用外部文件可以提高页面速度，因为JavaScript和CSS文件都能在浏览器中产生缓存。内置在HTML文档中的JavaScript 和CSS则会在每次请求中随HTML文档重新下载。这虽然减少了HTTP请求的次数，却增加了HTML文档的大小。从另一方面来说，如果外部文件中的 JavaScript和CSS被浏览器缓存，在没有增加HTTP请求次数的同时可以减少HTML文档的大小。<p>关键问题是，外部JavaScript和CSS文件缓存的频率和请求HTML文档的次数有关。虽然有一定的难度，但是仍然有一些指标可以一测量它。如果一个会话中用户会浏览你网站中的多个页面，并且这些页面中会重复使用相同的脚本和样式表，缓存外部文件就会带来更大的益处。<p>许多网站没有功能建立这些指标。对于这些网站来说，最好的坚决方法就是把JavaScript和CSS作为外部文件引用。比较适合使用内置代码的例外就是网站的主页，如Yahoo!主页和My Yahoo!。主页在一次会话中拥有较少（可能只有一次）的浏览量，你可以发现内置JavaScript和CSS对于终端用户来说会加快响应时间。<p>对于拥有较大浏览量的首页来说，有一种技术可以平衡内置代码带来的HTTP请求减少与通过使用外部文件进行缓存带来的好处。其中一个就是在首页中内置 JavaScript和CSS，但是在页面下载完成后动态下载外部文件，在子页面中使用到这些文件时，它们已经缓存到浏览器了。<p>20、削减JavaScript和CSS<p>精简是指从去除代码不必要的字符减少文件大小从而节省下载时间。消减代码时，所有的注释、不需要的空白字符（空格、换行、tab缩进）等都要去掉。在 JavaScript中，由于需要下载的文件体积变小了从而节省了响应时间。精简JavaScript中目前用到的最广泛的两个工具是JSMin和YUI Compressor。YUI Compressor还可用于精简CSS。<p>混淆是另外一种可用于源代码优化的方法。这种方法要比精简复杂一些并且在混淆的过程更易产生问题。在对美国前10大网站的调查中发现，精简也可以缩小原来 代码体积的21%，而混淆可以达到25%。尽管混淆法可以更好地缩减代码，但是对于JavaScript来说精简的风险更小。<p>除消减外部的脚本和样式表文件外，&lt;script&gt;和&lt;style&gt;代码块也可以并且应该进行消减。即使你用Gzip压缩过脚本 和样式表，精简这些文件仍然可以节省5%以上的空间。由于JavaScript和CSS的功能和体积的增加，消减代码将会获得益处。<p>21、用<link>代替@import<p>前面的最佳实现中提到CSS应该放置在顶端以利于有序加载呈现。<p>在IE中，页面底部@import和使用<link>作用是一样的，因此最好不要使用它。<p>22、避免使用滤镜<p>IE独有属性AlphaImageLoader用于修正7.0以下版本中显示PNG图片的半透明效果。这个滤镜的问题在于浏览器加载图片时它会终止内容的 呈现并且冻结浏览器。在每一个元素（不仅仅是图片）它都会运算一次，增加了内存开支，因此它的问题是多方面的。<p>完全避免使用AlphaImageLoader的最好方法就是使用PNG8格式来代替，这种格式能在IE中很好地工作。如果你确实需要使用AlphaImageLoader，请使用下划线_filter又使之对IE7以上版本的用户无效。<p>23、把脚本置于页面底部<p>脚本带来的问题就是它阻止了页面的平行下载。HTTP/1.1 规范建议，浏览器每个主机名的并行下载内容不超过两个。如果你的图片放在多个主机名上，你可以在每个并行下载中同时下载2个以上的文件。但是当下载脚本时，浏览器就不会同时下载其它文件了，即便是主机名不相同。<p>在某些情况下把脚本移到页面底部可能不太容易。比如说，如果脚本中使用了document.write来插入页面内容，它就不能被往下移动了。这里可能还会有作用域的问题。很多情况下，都会遇到这方面的问题。<p>一个经常用到的替代方法就是使用延迟脚本。DEFER属性表明脚本中没有包含document.write，它告诉浏览器继续显示。不幸的是， Firefox并不支持DEFER属性。在Internet Explorer中，脚本可能会被延迟但效果也不会像我们所期望的那样。如果脚本可以被延迟，那么它就可以移到页面的底部。这会让你的页面加载的快一点。<p>24、剔除重复脚本<p>在同一个页面中重复引用JavaScript文件会影响页面的性能。你可能会认为这种情况并不多见。对于美国前10大网站的调查显示其中有两家存在重复引 用脚本的情况。有两种主要因素导致一个脚本被重复引用的奇怪现象发生：团队规模和脚本数量。如果真的存在这种情况，重复脚本会引起不必要的HTTP请求和 无用的JavaScript运算，这降低了网站性能。<p>在Internet Explorer中会产生不必要的HTTP请求，而在Firefox却不会。在Internet Explorer中，如果一个脚本被引用两次而且它又不可缓存，它就会在页面加载过程中产生两次HTTP请求。即时脚本可以缓存，当用户重载页面时也会产 生额外的HTTP请求。<p>除增加额外的HTTP请求外，多次运算脚本也会浪费时间。在Internet Explorer和Firefox中不管脚本是否可缓存，它们都存在重复运算JavaScript的问题。<p>一个避免偶尔发生的两次引用同一脚本的方法是在模板中使用脚本管理模块引用脚本。在HTML页面中使用&lt;script /&gt;标签引用脚本的最常见方法就是：<p>&lt;script type=\"text/javascript\" src=\"menu_1.0.17.js\"&gt;&lt;/script&gt;<p>在PHP中可以通过创建名为insertScript的方法来替代：<p>&lt;?php insertScript(\"menu.js\") ?&gt;<p>为了防止多次重复引用脚本，这个方法中还应该使用其它机制来处理脚本，如检查所属目录和为脚本文件名中增加版本号以用于Expire文件头等。<p>25、减少DOM访问<p>使用JavaScript访问DOM元素比较慢，因此为了获得更多的应该页面，应该做到：<p>缓存已经访问过的有关元素<p>线下更新完节点之后再将它们添加到文档树中<p>避免使用JavaScript来修改页面布局<p>26、开发智能事件处理程序<p>有时候我们会感觉到页面反应迟钝，这是因为DOM树元素中附加了过多的事件句柄并且些事件句病被频繁地触发。这就是为什么说使用event delegation（事件代理）是一种好方法了。如果你在一个div中有10个按钮，你只需要在div上附加一次事件句柄就可以了，而不用去为每一个按 钮增加一个句柄。事件冒泡时你可以捕捉到事件并判断出是哪个事件发出的。<p>你同样也不用为了操作DOM树而等待onload事件的发生。你需要做的就是等待树结构中你要访问的元素出现。你也不用等待所有图像都加载完毕。<p>你可能会希望用DOMContentLoaded事件来代替onload，但是在所有浏览器都支持它之前你可使用YUI 事件应用程序中的onAvailable方法。<p>本文章来源于：Yahoo!网站性能最佳体验的34条黄金守则-JavaScript和CSS<p>","description":"Yahoo!的Exceptional Performance团队为改善Web性能带来最佳实践。他们为此进行了一系列的实验、开发了各种工具、写了大量的文章和博客并在各种会议上参与探讨。最佳实践的核心就是旨在提高网站性能。 Excetional Performance团队总结出了一系列可以提高网站速度的方法。可以分为7大类34条。包括内容、服务器、cookie、CSS、JavaScript、图片、移动应用等七部分。","category":"杂谈","hot":"y"},{"id":55,"title":"网站性能最佳体验的34条黄金守则-图片、Coockie与移动应用","date":1352708419,"content":"<p>Yahoo!的Exceptional Performance团队为改善Web性能带来最佳实践。他们为此进行了一系列的实验、开发了各种工具、写了大量的文章和博客并在各种会议上参与探讨。最佳实践的核心就是旨在提高网站性能。 Excetional Performance团队总结出了一系列可以提高网站速度的方法。可以分为7大类34条。包括内容、服务器、cookie、CSS、JavaScript、图片、移动应用等七部分。<p>其中图片、Coockie与移动应用部分一共八条建议：<p>四、图片、Coockie与移动应用部分<p>Coockie:<p>减小Cookie体积<p>对于页面内容使用无coockie域名<p>图片：<p>优化图像<p>优化CSS Spirite<p>不要在HTML中缩放图像<p>favicon.ico要小而且可缓存<p>移动应用：<p>保持单个内容小于25K<p>打包组件成复合文本<p>27、减小Cookie体积<p><p>HTTP coockie可以用于权限验证和个性化身份等多种用途。coockie内的有关信息是通过HTTP文件头来在web服务器和浏览器之间进行交流的。因此保持coockie尽可能的小以减少用户的响应时间十分重要。<p>研究中主要包括：<p>去除不必要的coockie<p>使coockie体积尽量小以减少对用户响应的影响<p>注意在适应级别的域名上设置coockie以便使子域名不受影响<p>设置合理的过期时间。较早地Expire时间和不要过早去清除coockie，都会改善用户的响应时间。<p>28、对于页面内容使用无coockie域名<p><p>当浏览器在请求中同时请求一张静态的图片和发送coockie时，服务器对于这些coockie不会做任何地使用。因此他们只是因为某些负面因素而创建的 网络传输。所有你应该确定对于静态内容的请求是无coockie的请求。创建一个子域名并用他来存放所有静态内容。<p>如果你的域名是www.example.org，你可以在static.example.org上存在静态内容。但是，如果你不是在 www.example.org上而是在顶级域名example.org设置了coockie，那么所有对于static.example.org的请求 都包含coockie。在这种情况下，你可以再重新购买一个新的域名来存在静态内容，并且要保持这个域名是无coockie的。Yahoo!使用的是 ymig.com，YouTube使用的是ytimg.com，Amazon使用的是images-anazon.com等等。<p>使用无coockie域名存在静态内容的另外一个好处就是一些代理（服务器）可能会拒绝对coockie的内容请求进行缓存。一个相关的建议就是，如果你 想确定应该使用example.org还是www.example.org作为你的一主页，你要考虑到coockie带来的影响。忽略掉www会使你除了 把coockie设置到*.example.org（*是泛域名解析，代表了所有子域名译者dudo注）外没有其它选择，因此出于性能方面的考虑最好是使用带有www的子域名并且在它上面设置coockie。<p>29、优化图像<p>设计人员完成对页面的设计之后，不要急于将它们上传到web服务器，这里还需要做几件事：<p>你可以检查一下你的GIF图片中图像颜色的数量是否和调色板规格一致。 使用imagemagick中下面的命令行很容易检查：<p>identify -verbose image.gif<p>如果你发现图片中只用到了4种颜色，而在调色板的中显示的256色的颜色槽，那么这张图片就还有压缩的空间。<p>尝试把GIF格式转换成PNG格式，看看是否节省空间。大多数情况下是可以压缩的。由于浏览器支持有限，设计者们往往不太乐意使用PNG格式的图片，不过这 都是过去的事情了。现在只有一个问题就是在真彩PNG格式中的alpha通道半透明问题，不过同样的，GIF也不是真彩格式也不支持半透明。因此GIF能 做到的，PNG（PNG8）同样也能做到（除了动画）。下面这条简单的命令可以安全地把GIF格式转换为PNG格式：<p>convert image.gif image.png<p>“我们要说的是：给PNG一个施展身手的机会吧！”<p>在所有的PNG图片上运行pngcrush（或者其它PNG优化工具）。例如：<p>pngcrush image.png -rem alla -reduce -brute result.png<p>在所有的JPEG图片上运行jpegtran。这个工具可以对图片中的出现的锯齿等做无损操作，同时它还可以用于优化和清除图片中的注释以及其它无用信息（如EXIF信息）：<p>jpegtran -copy none -optimize -perfect src.jpg dest.jpg<p>30、优化CSS Spirite<p>在Spirite中水平排列你的图片，垂直排列会稍稍增加文件大小；<p>Spirite中把颜色较近的组合在一起可以降低颜色数，理想状况是低于256色以便适用PNG8格式；<p>便于移动，不要在Spirite的图像中间留有较大空隙。这虽然不大会增加文件大小但对于用户代理来说它需要更少的内存来把图片解压为像素地图。100x100的图片为1万像素，而1000x1000就是100万像素。<p>31、不要在HTML中缩放图像<p>不要为了在HTML中设置长宽而使用比实际需要大的图片。如果你需要：<p>&lt;img width=\"100\" height=\"100\" src=\"mycat.jpg\" alt=\"My Cat\" /&gt;<p>那么你的图片（mycat.jpg）就应该是100x100像素而不是把一个500x500像素的图片缩小使用。<p>32、favicon.ico要小而且可缓存<p>favicon.ico是位于服务器根目录下的一个图片文件。它是必定存在的，因为即使你不关心它是否有用，浏览器也会对它发出请求，因此最好不要返回一个404 Not Found的响应。由于是在同一台服务器上，它每被请求一次coockie就会被发送一次。这个图片文件还会影响下载顺序，例如在IE中当你在 onload中请求额外的文件时，favicon会在这些额外内容被加载前下载。<p>因此，为了减少favicon.ico带来的弊端，要做到：<p>文件尽量地小，最好小于1K<p>在适当的时候（也就是你不要打算再换favicon.ico的时候，因为更换新文件时不能对它进行重命名）为它设置Expires文件头。你可以很安全地把Expires文件头设置为未来的几个月。你可以通过核对当前favicon.ico的上次编辑时间来作出判断。<p>Imagemagick可以帮你创建小巧的favicon。<p>33、保持单个内容小于25K<p>这条限制主要是因为iPhone不能缓存大于25K的文件。注意这里指的是解压缩后的大小。由于单纯gizp压缩可能达不要求，因此精简文件就显得十分重要。<p>34、打包组件成复合文本<p>把页面内容打包成复合文本就如同带有多附件的Email，它能够使你在一个HTTP请求中取得多个组件（切记：HTTP请求是很奢侈的）。当你使用这条规则时，首先要确定用户代理是否支持（iPhone就不支持）。<p>本文章来源于：Yahoo!网站性能最佳体验的34条黄金守则-图片、Coockie与移动应用<p>","description":"Yahoo!的Exceptional Performance团队为改善Web性能带来最佳实践。他们为此进行了一系列的实验、开发了各种工具、写了大量的文章和博客并在各种会议上参与探讨。最佳实践的核心就是旨在提高网站性能。 Excetional Performance团队总结出了一系列可以提高网站速度的方法。可以分为7大类34条。包括内容、服务器、cookie、CSS、JavaScript、图片、移动应用等七部分。","category":"杂谈","hot":"n"},{"id":56,"title":"非响应式设计的viewport","date":1352876551,"content":"<p>大家已经非常熟悉响应式网页设计了吧，但是我们通常会忽略很多旧的没有采用响应式设计的网站，其实这类网站在移动终端的用户体验更为关键——因为它们没有对移动设备做任何优化。<p>通用viewport<p>对于响应式网站，大家通常都会这样定义：<p>&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;<p>非响应式网站<p>但是你或许会知道，iPhone（包括android）通常会把网站默认以980px的宽度来渲染，这就是说，如果你没有定义viewport，如果你的网站的宽度大于980或者小于980，iPhone会把它默认以980px的窗口来缩放和渲染，这样就会有各种问题。<p>比如：<p><img src=\"/content/uploadfile/201211/thum-f3ccdd27d2000e3f9255a7e3e2c4880020121114070735.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>前面图片是没有设置viewport的情况，页面宽度大于980px的部分会被截断，后面的是设置了实际宽度(1024)以后的表现，嗯，只是简单的把页面的viewport设置成实际宽度：<p>&lt;meta name=\"viewport\" content=\"width=1024\"&gt;<p>页面实际宽度过小的时候也会有问题：<p><img src=\"/content/uploadfile/201211/thum-fb5c81ed3a220004b71069645f11286720121114071020.png\" alt=\"点击查看原图\" border=\"0\" /><p>容器的宽度是700px，所以会默认留白，而设置了viewport之后，页面就看起来舒服多了：<p>&lt;meta name=\"viewport\" content=\"width=720\"&gt;<p>常见错误<p>&lt;meta name=\"viewport\" content=\"initial-scale=1, maximum-scale=1, user-scalable=no\"&gt;<p>一个很常见的错误是，很多人常常使用initial-scale=1到非响应式网站上，这会让网站以100%宽度渲染而不会自动缩放，用户需要手动移动页面或者缩放。最差的是和initial-scale=1同时使用user-scalable=no或maximum-scale=1，这将使你的网站不能被缩放——用户不能放大/缩小网页来看到全部的内容。所以，请记住：如果你的网站不是响应式的，请不要使用initial-scale或者禁用缩放。<p>本文章来源于：非响应式设计的viewport<p>","description":"大家已经非常熟悉响应式网页设计了吧，但是我们通常会忽略很多旧的没有采用响应式设计的网站，其实这类网站在移动终端的用户体验更为关键——因为它们没有对移动设备做任何优化。","category":"HTML","hot":"y"},{"id":57,"title":"CSS在 Internet Explorer 6, 7 和8中的差别","date":1352885775,"content":"<p>关于浏览器的最离奇的统计结果之一就是Internet Explorer 版本6，7和8共存。截至本文，Internet Explorer各个版本总共占据了大约65%的市场份额。在网站开发社区，这个数字要小很多，统计显示大概只有40%。<p><img src=\"/content/uploadfile/201211/thum-06a8e5f59fd1625e6a99e44fb5293e9720121115021200.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>这些统计中比较有趣的部分是，IE6、IE7、IE8之间的数值很接近，这防止了单个Microsoft的浏览器占居统治地位——与过去的情况相反。根据这些令人遗憾的统计结果，在为客户开发网站的时候开发人员对所有当前使用的IE浏览器做全面的测试是必要的，而且这样在个人项目上也可以拉拢更多的用户。<p>多谢那些JavaScript库(框架)，跨浏览器的Javascript的测试已经像当前形势所允许的那样接近完美了。但在CSS开发中还不是这样，特别是关系到IE目前存在的三个版本。<p>本文尝试为希望了解CSS对IE6、IE7、IE8的支持的不同的开发者提供一份详细的、易用的参考。<p>本参考包含以下情况的概述和兼容情况：<p>· 三个浏览器中的一个支持而另外两个不支持的条目<p>· 三个浏览器中的两个支持而另外一个不支持的条目<p>本文不讨论：<p>· 三个浏览器都不支持的条目<p>· 私有属性<p>因此，本文的中心是三个浏览器中的不同，而不是必要的支持缺陷。<p>该列表被分为以下五个部分：<p>· 选择器与继承<p>· 伪类与伪元素<p>· 属性支持<p>· 其它各种技术<p>· 重要bug和不兼容问题<p> <p>选择器与继承<p>子选择器<p>示例：<p>body &gt; p {color: #fff;}<p>描述：<p>子选择器选择一个特定父级元素的所有直接子级元素，在上面的例子中，body是父元素，p是子元素。<p>支持情况：<p>IE6:No;IE7:Yes;IE8:Yes<p>Bugs：<p>IE7中，如果在父级标签和子级标签之间有一个HTML注释，子选择器将不会工作。<p> <p>链类<p>示例：<p>.class1.class2.class3 {background: #fff;}<p>描述：<p>链类用于送一个HTML元素有多个class声明的情况，就像这样：<p>&lt;div class=\"class1 class2 class3\"&gt;   &lt;p&gt;Content here.&lt;/p&gt; &lt;/div&gt;<p>支持情况：<p>IE6:No;IE7:Yes;IE8:Yes<p>Bugs：<p>IE6好像支持这种情况，因为它能匹配链中的最后一个class到使用该class的元素上，然而，它并不能限制一个使用链中所有class的元素。<p> <p>属性选择器<p>示例：<p>a[href] {color: #0f0;}<p>描述：<p>该选择器允许一个元素被定位只要它有指定的属性。在上面的例子中，所有的带有href属性的a标签都会被限定，而没有href属性的a标签不会被限定。<p>支持情况：<p>IE6:No;IE7:Yes;IE8:Yes<p> <p>临近兄弟选择器<p>示例：<p>h1+p {color: #f00;}<p>描述：<p>该选择器定位临近到指定元素的兄弟标签。上面的例子将会限定p标签，但是他必须是h1标签的兄弟而且要直接尾随在h1标签的后面。比如：<p>&lt;h1&gt;heading&lt;/h1&gt; &lt;p&gt;Content here.&lt;/p&gt; &lt;p&gt;Content here.&lt;/p&gt;<p>支持情况：<p>IE6:No;IE7:Yes;IE8:Yes<p>Bugs：<p>在IE7中，如果在兄弟之间有一个HTML注释，临近兄弟选择器将无效。<p> <p>普通兄弟选择器<p>示例：<p>h1~p {color: #f00;}<p>描述：<p>该选择器定位一个指定元素后面的所有兄弟元素。将此选择器应用到上面的那个例子，将会对两个p标签都有效。当然，如果有一个p元素出现在h1之前，那个p元素不会被匹配。<p>支持情况：<p>IE6:No;IE7:Yes;IE8:Yes<p> <p>伪类和伪元素<p>:hover后面的后代选择器<p>示例：<p>a:hover span {color: #0f0;}<p>描述：<p>一个元素可以被:hover伪类后面的选择器定位，就像后代选择器一样。上面的例子，在鼠标悬停的时候，将会改变a元素内的span元素中的文字的颜色。<p>支持情况：<p>IE6:No;IE7:Yes;IE8:Yes<p> <p>链伪类<p>示例：<p>a:first-child:hover {color: #0f0;}<p>描述：<p>伪类可以链起来以缩小元素选择。上面的例子会定位每一个父级元素下的第一个a标签，并将hover伪类P应用到它上。<p>支持情况：<p>IE6:No;IE7:Yes;IE8:Yes<p> <p>非锚点元素中的:hover<p>示例：<p>div:hover {color: #f00;}<p>描述：<p>:hover伪类可以应用到任何元素的悬停状态，而不只是a标签。<p>支持情况：<p>IE6:No;IE7:Yes;IE8:Yes<p> <p>:first-child伪类<p>示例：<p>div li:first-child {background: blue;}<p>描述：<p>改伪类定位每一个指定的元素的父级元素的第一个子元素。<p>支持情况：<p>IE6:No;IE7:Yes;IE8:Yes<p>Bugs：<p>IE7中，如果要定位的第一个子元素之前有HTML注释，first-child伪类将会无效。<p> <p>:focus伪类<p>示例：<p>a:focus {border: 1px solid red;}<p>描述：<p>该伪类定位有键盘焦点的所有元素。<p>支持情况：<p>IE6:No;IE7:No;IE8:Yes<p> <p>:before 和:after 伪类<p>示例：<p>#box:before {content: \"本段文字在盒子前面\";} #box:after {content: \"本段文字在盒子后面\";}<p>描述：<p>这两个伪元素分别在指定元素的前面和后面添加生成的内容，结合content属性一起使用。<p>支持情况：<p>IE6:No;IE7:No;IE8:Yes<p> <p>属性支持<p>由position产生的实际大小<p>示例：<p>#box {    position: absolute;     top: 0;     right: 100px;   left: 0;    bottom: 200px;  background: blue; }<p>描述：<p>定义top, right, bottom, 和left 值到绝对定位的元素上将给这个元素实际的大小(宽度和高度)，虽然并没有设定使宽度和高度值。<p>支持情况：<p>IE6:No;IE7:Yes;IE8:Yes<p> <p>Min-Height 与 Min-Width<p>示例：<p>#box {min-height: 500px;min-width: 300px;}<p>描述：<p>这两个属性分别指定元素的宽和高的最小值，允许一个盒子可以比指定的最小值更大，但是不能更小。它们两个可以一起使用，也可以分开来用。<p>支持情况：<p>IE6:No;IE7:Yes;IE8:Yes<p> <p>Max-Height 和Max-Width<p>示例：<p>#box {max-height: 500px;max-width: 300px;}<p>描述：<p>这两个属性分别指定元素的高和宽的最大值，允许一个盒子比这个指定的最大值小，但是不能更大。它们也可以同时使用或者单独使用。<p>支持情况：<p>IE6:No;IE7:Yes;IE8:Yes<p> <p>透明边框颜色<p>示例：<p>#box {border: solid 1px transparent;}<p>描述：<p>一个透明的边框色允许一个边框和边框色可见(或者不透明)时占用一样的空间。<p>支持情况：<p>IE6:No;IE7:Yes;IE8:Yes<p> <p>固定位置元素<p>示例：<p>#box {position: fixed;}<p>描述：<p>position属性的这个值允许一个元素绝对的相对于窗口定位。<p>支持情况：<p>IE6:No;IE7:Yes;IE8:Yes<p> <p>固定位置的背景图<p>示例：<p>#box {  background-image: url(images/bg.jpg);   background-position: 0 0;   background-attachment: fixed; }<p>描述：<p>background-attachment属性的值为fixed允许一个背景图片绝对地相对于窗口定位。<p>支持情况：<p>IE6:No;IE7:Yes;IE8:Yes<p>Bugs：<p>就像position:fixed一样，IE6同样不支持background-positon的fixed值 。然而，在IE6中只有在这个值用于根元素的时候才有效。<p> <p>属性值“inherit”<p>示例：<p>#box {display: inherit;}<p>描述：<p>将值inherit 应用到一个属性那个允许一个元素从它的包含元素继承计算的值。<p>支持情况：<p>IE6:No;IE7:No;IE8:Yes<p>Bugs：<p>IE6 和IE7 不支持inherit 值除了direction 和visibility 属性。<p> <p>表格单元的边框空白<p>示例：<p>table {border-spacing: 3px;}<p>描述：<p>该属性设置相邻的表格单元的边框之间的空白。<p>支持情况：<p>IE6:No;IE7:No;IE8:Yes<p> <p>在表格中渲染空单元格<p>示例：<p>table {empty-cells: show;}<p>描述：<p>该属性，只应用于元素的display属性被设置为 table-cell的元素，允许空单元格渲染他们的边框和背景。否则，它们将不可见。<p>支持情况：<p>IE6:No;IE7:No;IE8:Yes<p> <p>表格标题的水平位置<p>示例：<p>table {caption-side: bottom;}<p>描述：<p>这个属性允许将一个表格的标题放到表格的底部——默认是头部。<p>支持情况：<p>IE6:No;IE7:No;IE8:Yes<p> <p>修剪区域<p>示例：<p>#box {clip:rect(20px, 300px, 200px, 100px);}<p>描述：<p>该属性指定一个盒子的一个区域可见，剩下的部分修剪掉，或者不可见。<p>支持情况：<p>IE6:No;IE7:No;IE8:Yes<p>Bugs：<p>有趣的是，该如果不使用隔开各个值的逗号，IE6和IE7也可以用这个属性。(比如，使用空格隔开剪切的值。)<p> <p>打印页面中的orphanes和widows<p>示例：<p>p {orphans: 4;} p {widows: 4;}<p>描述：<p>orphans属性设定在打印页面底部显示的最少行数。而widows 属性用来设定打印页面头部至少显示的段落的行数。<p>支持情况：<p>IE6:No;IE7:No;IE8:Yes<p> <p>盒子内的页面分割<p>示例：<p>#box {page-break-inside: avoid;}<p>描述：<p>该属性设定分页是否发生在一个指定元素内。<p>支持情况：<p>IE6:No;IE7:No;IE8:Yes<p> <p>Outline 属性<p>示例：<p>#box {outline: solid 1px red;}<p>描述：<p>outline 是outline-style, outline-width, 和outline-color的缩写。该属性要优于border属性，因为它不会影响文档流，因而u更有助于调试布局问题。<p>支持情况：<p>IE6:No;IE7:No;IE8:Yes<p> <p>display属性的替代值<p>示例：<p>#box {display: inline-block;}<p>描述：<p>display 属性通常设置为block, inline, 或none。替代值包括：<p>· inline-block<p>· inline-table<p>· list-item<p>· run-in<p>· table<p>· table-caption<p>· table-cell<p>· table-column<p>· table-column-group<p>· table-footer-group<p>· table-header-group<p>· table-row<p>· table-row-group<p>支持情况：<p>IE6:No;IE7:No;IE8:Yes<p> <p>处理可折叠空白<p>示例：<p>p {white-space: pre-line;} div {white-space: pre-wrap;}<p>描述：<p>white-space属性的pre-line值设定将多个空白元素折叠为一个空白，同时允许明确的设置断行。white-space 属性的pre-wrap 值不会将多个空白折叠为一个，不过也允许明确的设置断行。<p>支持情况：<p>IE6:No;IE7:No;IE8:Yes<p> <p>其它各种技术<p>@import的媒体类型<p>示例：<p>@import url(\"styles.css\") screen;<p>描述：<p>就像上面的例子那样，引入的样式表文件的媒体类型声明在文件地址的后面。在该例子中，媒体类型是”screen”。<p>支持情况：<p>IE6:No;IE7:No;IE8:Yes<p>Bugs：<p>尽管IE6 和IE7 支持 @import，它们在媒体类型被指定的时候会无效，甚至会引起正@import规则无效。<p> <p>计数递增<p>示例：<p>h2 {counter-increment: headers;} h2:before {content: counter(headers) \". \";}<p>描述：<p>该CSS 技术允许你自动增加出现在指定元素前面的编号，结合before伪元素一起使用。<p>支持情况：<p>IE6:No;IE7:No;IE8:Yes<p> <p>生成内容的引用字符<p>示例：<p>q {quotes: \"\'\" \"\'\";} q:before {content: open-quote;} q:after {content: close-quote;}<p>描述：<p>指定用于生成内容的引用呼号，用于q标签。<p>支持情况：<p>IE6:No;IE7:No;IE8:Yes<p> <p>重要bug和不兼容性问题<p>下面是在上文中没有提到的IE6和IE7的众多bug。当然这个列表不包括在这三个浏览器中都不支持的条目。<p>IE6 Bugs：<p>· 不支持用样式设置&lt;abbr&gt; 元素&lt;/abbr&gt;<p>· 不支持以连字符和下划线开头的class和ID名<p>· &lt;select&gt; 元素总是出现在堆叠最上面，而无视z-index值<p>· 如果锚点的伪类没有使用正确的顺序(:link, :visited, :hover)，:hover 伪类将无效<p>· 一个属性的!important 声明会被同一规则中同一属性的没有使用!important的第二个声明覆盖。<p>· height 表现类似于min-height<p>· width 表现类似于min-width<p>· 左右margin双倍<p>· 圆点边框(dotted)看起来像虚线边框(dashed)<p>· text-decoration的 line-through 值在文字上看起来比别的浏览器要高一些<p>· 有序列表如果有一个固定结构(haslayout为true，不能设置li的高度/宽度/zoom等激活haslayout的值)，序号就不会增加，而是保持为1<p>· 列表元素不支持list-style-type的所有可用的值<p>· 如果列表条目浮动，指定的list-style-image 将不会显示<p>· 不完全支持 @font-face<p>· 某些选择器会错误的匹配注释和文档声明<p>· 如果一个ID 选择器结合一个类选择器不匹配，同样的ID选择器结合不同的类选择器也将被当作不匹配。<p> <p>IE7 Bugs：<p>· 有序列表如果有一个固定结构(haslayout为true，不能设置li的高度/宽度/zoom等激活haslayout的值)，序号就不会增加，而是保持为1<p>· 列表元素不支持list-style-type的所有可用的值<p>· 如果列表条目浮动，指定的list-style-image 将不会显示<p>· 不完全支持 @font-face<p>· 某些选择器会错误的匹配注释和文档声明<p>一些在这里没有提到的IE bug只会在特定环境发生，而且没有指定到特定的CSS属性或值。<p>本文章来源于：CSS在Internet Explorer 6, 7 和8中的差别<p>","description":"关于浏览器的最离奇的统计结果之一就是Internet Explorer 版本6，7和8共存。截至本文，Internet Explorer各个版本总共占据了大约65%的市场份额。在网站开发社区，这个数字要小很多，统计显示大概只有40%。","category":"CSS","hot":"n"},{"id":58,"title":"让我们一起黑了ie","date":1352965098,"content":"<p>老外好无聊，又整了一个网站，来推动大家消灭旧版本的IE浏览器，不过与以往不同的是，这次行动建议在10月26日那天统一进行，只上线一天。这有点儿像之前的CSS 裸奔日活动。<p>其实现在笼统的说IE好还是坏是很不客观的，IE的最新版本一直还算比较给力的，所以IE的最大问题是IE6做的太好了。<p>我们一直在推动IE版本的新陈代谢，微软自己也在推动，不过似乎效果并不好——前端观察甚至用”买不到火车票”来诅咒IE6用户，所以现在已经很少有人用IE6访问前端观察了。。。<p>这种中国特色的奇葩现象，通过这两年和很多人聊，好像也不难解释——用户根本就不知道什么叫浏览器，甚至，很多很多的人，没有hao123就不知道怎么上网。<p>这是因为中国人的学习能力太弱还是上学时老师教的太搓了？<p>好吧，不吐槽了，我知道大家毕业后基本上都不看书学习的。。。<p>回到正题<p>http://godarkforie.org/网站主导了这次活动，建议通过提供一个蒙板图片来让用户升级浏览器，表现就是黑色的IE的LOGO。<p><img src=\"/content/uploadfile/201211/thum-f9fbf5b17fdddc093cca1bea282c18fa20121115075558.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>嗯，好吧，老外的目的是黑掉IE9以下的IE浏览器版本——我们能消灭IE6就感谢郭嘉了。。。<p>具体做法可以用条件注释，或者js判断，没什么技术难度，大家自由发挥。。。<p>&lt;!--[if lt IE 9]&gt;&lt;div style=\"position:fixed;top:0;left:0;right:0;bottom:0;background:black;z-index:999999999;text-align:center;\"&gt;&lt;a href=\"http://godarkforie.org/upgrade?lang=zh-cn\"&gt;&lt;img src=\"http://godarkforie.org/splash/zh-cn.jpg\" alt=\"您正在使用旧版本的Internet Explorer浏览器\" /&gt;&lt;/a&gt;&lt;/div&gt;&lt;![endif]--&gt;<p>本文章来源于：10月26日，让我们一起黑了ie<p>","description":"老外好无聊，又整了一个网站，来推动大家消灭旧版本的IE浏览器，不过与以往不同的是，这次行动建议在10月26日那天统一进行，只上线一天。这有点儿像之前的CSS 裸奔日活动。","category":"HTML","hot":"n"},{"id":59,"title":"W3C携google、firefox等公司共推Web Platform","date":1352969196,"content":"<p>W3C一直致力于互联网技术标准的制定和推广，这一次直接和互联网巨头一起，推行WebPlatform.org网站，建设一个标准化社区来推广标准。<p>WebPlatform的最大意义在于文档的撰写和更新，这是个体力活儿，即便之前有MDN的文档，也不能保证完全的全面和及时——虽然目前规范/文档写的最好的也就MDN和apple的Safari文档。<p>网站发布后即收到了广泛的关注，第一天就有8.6万访客和72万pv，新增200多个编辑人员。<p>嗯，这是又一个我们可以查资料的地方，也是一个我们可以和国际上的前端开发工程师一起交流的地方。<p>据说，W3C的Doug Scheper在大约1年前牵头了这件事情，各大浏览器厂商和pc厂商加盟参与，目标却是要建设一个“中立”的社区，从而更好的推广W3C标准。<p>嗯，有兴趣的同学也参与进去吧~~<p>本文章来源于：W3C携google、firefox等公司共推Web Platform<p>","description":"W3C一直致力于互联网技术标准的制定和推广，这一次直接和互联网巨头一起，推行WebPlatform.org网站，建设一个标准化社区来推广标准。","category":"杂谈","hot":"n"},{"id":60,"title":"标签？ID还是CLASS？","date":1354071319,"content":"<p>想谈一下几个基本的HTML问题，都是围绕着应该怎样使用HTML。<p>1. 多用有语义的标签，少用div和span，避免使用没有class的div和span。 <p>设想一下HTML的世界最初只有div和span这两个标签，其实网页依然可以写得出来。更多标签的出现，其实是为了替代利用率高但不好书写的 <code>&lt;div class=\"{tagname}\"&gt;</code> 和 <code>&lt;span class=\"{tagname}\"&gt;</code> 来的。<p>想再接着多说一句的是，在HTML5里越来越多常见的div class组合或div id组合被直接命名为了新的标签。理由也是相同的，像header/footer/aside/nav/section/article都是我之前经常使用的class或id。我甚至觉得w3c创造新html标签的工作很简单，定期统计一下最常用的class和id，然后取前几名作为新的标签名就行了。<p>上周还有人在微博上感慨那个\"史上最牛的HTML代码\"：<p>&lt;div class=\"mod\"&gt;     &lt;div class=\"hd\"&gt;&lt;/div&gt;     &lt;div class=\"bd\"&gt;&lt;/div&gt; &lt;/div&gt;<p>再过几年它真的也许会消失的。<p>反过来思考也可以，尽量使用有语义的标签名，实在想不出来合适的标签名了，再用div然后起个class或id。这样的思路也不错。<p>2. 不要滥用class而回避id，该出手时就出手。<p>和问题1同理，设想一下HTML的世界最初只有class没有id，其实网页依然可以写得出来，语义依然表达得出来。无非就是会出现很多特殊的class呗。因此，我们也很好理解，id的出现，就是可以和class一起协作，使某些语义即使没有现成的标签可以表示它，但依然可以把一般性和唯一性完美的结合在一起。<p>这里驳斥一个观点：\"尽量都使用class，因为控制样式的时候class的优先级是同级的，id的优先级更高，它的出现会破坏样式优先级的平衡\"。首先我觉得这是一个假命题，所谓的\"平衡\"是不存在的，也没有必要去刻意维护，通过id来表示的内容一定是相对特殊的，优先级自然高一些，这样的优先级设计是如此的自然。我能够接受的全部是class的适用范围仅是一些底层的css基础样式，如oocss里的基础样式，或很多网站都会有common.css文件或general.css文件，里面的东西尽量用class没问题。<p>另一个更重要的理由是，在HTML5里，除了id和class这两个特性可以控制样式之外，还可以通过特性选择器来定义样式，类似E[attr=\"...\"]的写法。我们会发现可以控制样式的方式越来越灵活，选择越来越多。这是Web发展的必然趋势。当其他人已经在用id/class/data-*/tagname对样式展开多重维度攻势的时候，我们实在没有必要把自己还关在class的世界里。<p>3. 尽量给每个表示布局的class或id换一个站在内容角度的合理的名字。<p>比如两列布局的左右侧多半是正文和辅助信息的关系，那么就不建议用class=\"left\"和class=\"right\"而是倾向于class=\"main-content\"和class=\"sidebar\"，或者直接用article和aside。<p>在自适应Web设计(responsive web design)如火如荼的今天，页面上的某个元素处在网页什么位置更像是个变量，所以通过位置来定义一个元素显然是会承受很多额外的维护成本和扩展成本。当改变发生的那一天，你发现自己的HTML代码变得文不对题。曾经的left跑到最上面去了，right变成了底部通栏，这都是很正常的变化。<p>实在没什么语义的，比如为了给IE加圆角而增设的标签，或清除浮动用的额外的标签，再或者是基础样式的，和具体内容无关的，再用div加表象的class来描述。<p>4. 尽量避免表示纯样式的class或id。<p>比如class=\"f14 red\"。印象中网上有很多拙劣的例子，也有很多深刻批判这种用法的文章，我想说的是，如果你非要这样改样式，那不如直接写内联style来得直观。<p>最后想说的是……<p>互联网是一个快速发展的领域，它的快速发展甚至让人们忘却了很多传统领域的停滞不前。在这样的领域里工作，勇敢尝试，关注新技术，把握新趋势是如此的重要。不要拒绝新事物，不要被不思进取的人拖累，不要对大千世界失去好奇心和求知欲，方可永葆青春。<p>本文章来源于：标签？ID？还是CLASS？<p>","description":"想谈一下几个基本的HTML问题，都是围绕着应该怎样使用HTML。","category":"HTML","hot":"n"},{"id":61,"title":"不可错过的10个超棒jQuery表单操作代码片段","date":1354073073,"content":"<p>jQuery绝对是一个伟大的开源javascript类库，是帮助我们快速和高效开发前端应用的利器。可能大家在日常的开发过程中常常会处理表单相关的javascript，在今天这篇代码片段分享文章中，这里收集了10个超棒超实用的jQuery表单处理代码，希望能够在大家的开发过程中帮助大家更好更快的处理表单相关问题，希望大家喜欢！如果你也有相关的代码，请大家积极分享！<p> <p>代码片段1: 在表单中禁用\"回车键\"<p>大家可能在表单的操作中需要防止用户意外的提交表单，那么下面这段代码肯定非常有帮助：<p>$(\"#form\").keypress(function(e) {   if (e.which == 13) {     return false;   } });<p> <p>代码片段2: 清除所有的表单数据<p>可能针对不同的表单形式，你需要调用不同类型的清楚方法，不过使用下面这个现成方法，绝对能让你省不少功夫。<p>function clearForm(form) {   // iterate over all of the inputs for the form   // element that was passed in   $(\':input\', form).each(function() {     var type = this.type;     var tag = this.tagName.toLowerCase(); // normalize case     // it\'s ok to reset the value attr of text inputs,     // password inputs, and textareas     if (type == \'text\' || type == \'password\' || tag == \'textarea\')       this.value = \"\";     // checkboxes and radios need to have their checked state cleared     // but should *not* have their \'value\' changed     else if (type == \'checkbox\' || type == \'radio\')       this.checked = false;     // select elements need to have their \'selectedIndex\' property set to -1     // (this works for both single and multiple select elements)     else if (tag == \'select\')       this.selectedIndex = -1;   }); };<p> <p>代码片段3: 将表单中的按钮禁用<p>下面的代码对于ajax操作非常有用，你可以有效的避免用户多次提交数据，个人也经常使用：<p>禁用按钮：<p>$(\"#somebutton\").attr(\"disabled\", true);<p>启动按钮：<p>$(\"#submit-button\").removeAttr(\"disabled\");<p>可能大家往往会使用.attr(\'disabled\',false);，不过这是不正确的调用。<p> <p>代码片段4: 输入内容后启用递交按钮<p>这个代码和上面类似，都属于帮助用户控制表单递交按钮。使用这段代码后，递交按钮只有在用户输入指定内容后才可以启动。<p>$(\'#username\').keyup(function() {     $(\'#submit\').attr(\'disabled\', !$(\'#username\').val());  });<p> <p>代码片段5: 禁止多次递交表单<p>多次递交表单对于web应用来说是个比较头疼的问题，下面的代码能够很好的帮助你解决这个问题：<p>$(document).ready(function() {   $(\'form\').submit(function() {     if(typeof jQuery.data(this, \"disabledOnSubmit\") == \'undefined\') {       jQuery.data(this, \"disabledOnSubmit\", { submited: true });       $(\'input[type=submit], input[type=button]\', this).each(function() {         $(this).attr(\"disabled\", \"disabled\");       });       return true;     }     else     {       return false;     }   }); });<p> <p>代码片段6: 高亮显示目前聚焦的输入框标示<p>有时候你需要提示用户目前操作的输入框，你可以使用下面代码高亮显示标示：<p>$(\"form :input\").focus(function() {   $(\"label[for=\'\" + this.id + \"\']\").addClass(\"labelfocus\"); }).blur(function() {   $(\"label\").removeClass(\"labelfocus\"); });<p> <p>代码片段7: 动态方式添加表单元素<p>这个方法可以帮助你动态的添加表单中的元素，比如，input等：<p>//change event on password1 field to prompt new input $(\'#password1\').change(function() {         //dynamically create new input and insert after password1         $(\"#password1\").append(\"&lt;input type=\'text\' name=\'password2\' id=\'password2\' /&gt;\"); });<p> <p>代码片段8: 自动将数据导入selectbox中<p>下面代码能够使用ajax数据自动生成选择框的内容<p>$(function(){   $(\"select#ctlJob\").change(function(){     $.getJSON(\"/select.php\",{id: $(this).val(), ajax: \'true\'}, function(j){       var options = \'\';       for (var i = 0; i &lt; j.length; i++) {         options += \'&lt;option value=\"\' + j[i].optionValue + \'\"&gt;\' + j[i].optionDisplay + \'&lt;/option&gt;\';       }       $(\"select#ctlPerson\").html(options);     })   }) })<p> <p>代码片段9: 判断一个复选框是否被选中<p>代码很简单，如下：<p>$(\'#checkBox\').attr(\'checked\');<p> <p>代码片段10: 使用代码来递交表单<p>代码很简单，如下：<p>$(\"#myform\").submit();<p> <p>希望大家觉得这些jQuery代码会对你的开发有帮助，如果你也有类似的代码，请和我们分享！<p>本文章来源于：不可错过的10个超棒jQuery表单操作代码片段<p>","description":"jQuery绝对是一个伟大的开源javascript类库，是帮助我们快速和高效开发前端应用的利器。可能大家在日常的开发过程中常常会处理表单相关的javascript，在今天这篇代码片段分享文章中，这里收集了10个超棒超实用的jQuery表单处理代码，希望能够在大家的开发过程中帮助大家更好更快的处理表单相关问题，希望大家喜欢！如果你也有相关的代码，请大家积极分享！","category":"JavaScript","hot":"y"},{"id":62,"title":"IE BUG相关文章集合","date":1355885672,"content":"<p>Haslayout<p>· IE Haslayout 详解<p>· haslayout<p>· \"HasLayout\" Overview<p>· 你了解IE的haslayout（拥有布局）吗？<p>· 详说 IE hasLayout<p>Block formatting contexts<p>· Block formatting<p>· Block Formatting Contexts(块级格式化上下文)<p>· 详说 Block Formatting Contexts (块级格式化上下文)<p>IE bug<p>· The CSS Box Model<p>· css盒子模型（box model）<p>· margin加倍bug<p>· 3px bug<p>· 文字溢出bug(注释bug)<p>· IE下图片空隙BUG<p>CSS背景图片重复加载BUG<p>· 设置比较小的（1px/2px）高度bug<p>ie6的!important<p>· 奇偶数bug<p>· ie6不支持position:fixed<p>· Z-index层级bug<p>· overflow bug<p>· 父级使用padding后子元素绝对定位的BUG<p>· 最小/大宽/高<p>· Ie6,7表单按钮元素两边留白<p>· a:hover bug<p>· ie6 png透明终极解决方案<p>· div遮盖select的解决方案<p>· IE6 resize bug<p>· the guillotine bug<p>· 清除子元素的浮动<p>BUG集合<p>· 浏览器兼容之旅的第三站:IE常见Bug——part1<p>· 浏览器兼容之旅的第四站:IE常见Bug——part2<p>· 浏览器兼容之旅的第五站:IE常见Bug——part3<p>· IE浏览器常见的9个css Bug以及解决办法<p>· IE6疯狂系列<p>· 使用CSS修正一切：20多个常见Bug及其修正方法（中文版）<p>· 打败 IE 的葵花宝典：CSS Bug Table（中文版）<p>· Internet Explorer Bugs<p>· Ultimate IE6 Cheatsheet: How To Fix 25+ Internet Explorer 6 Bugs<p>· 修正IE6的bug的10个技巧<p>· hack速查表<p>其他文章<p>· 说说标准系列目录<p>· 浏览器兼容性问题目录<p>本文章来源于：IE BUG相关文章集合<p>","description":"IE BUG相关文章集合","category":"CSS","hot":"n"},{"id":63,"title":"学习JavaScript的最佳方法","date":1361264532,"content":"<p><img src=\"/content/uploadfile/201302/f3ccdd27d2000e3f9255a7e3e2c4880020130219101038.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>学习新的东西是件可怕的事。对我来说，掌握一项新技能最大的问题是，我不知道自己懂什么。鉴于此，定个计划，学习你感兴趣的东西应该会有用。这篇文章的主旨就是：你为学习JavaScript制定的蓝图、路线、行动计划！你不必担心找不到最好的资源，先整理些不好的资源，再确定下一步该学什么。遵循它，一步一步来。<p>任务0：了解什么是JavaScript<p>在你真正开始学习JavaScript 之前，花一分钟了解一下什么是JavaScript，它有哪些功能。<p>JavaScript不是jQuery、Flash或Java。与它们不同，它是一种独立的编程语言。<p>JavaScript 是浏览器语言（尽管现在不完全是）。主要目的是给静态页面增加交互性。在浏览器里，它不会为你更换PHP或Ruby，也不会更改你的HTML或CSS；你可以把它们串在一起使用。另外，它没有你想的那么难学。<p>补充说明：你应该听过jQuery，它可能是被使用最广泛的JavaScript库。也许你还听说过其他比较流行的JavaScript 框架，比如Mootools,，YUI，Dojo等等。可以将它们统一看做JavaScript辅助工具集；当你使用它们的时候，你还在写JavaScript，但都是些很抽象的JavaScript。它会让你事半功倍。<p>”你甚至可能听到有人说，你应该先学jQuery（或其他库）再学JavaScript。我很尊重他们但完全不同意这种说法。先把JavaScript 学好再用其他库，你会发现你会做的更好；结果就是，你会编写更好的JavaScript。“<p>任务1：通过Codecademy.com站点的课程来学习<p><img src=\"/content/uploadfile/201302/thum-fb5c81ed3a220004b71069645f11286720130219101039.png\" alt=\"点击查看原图\" border=\"0\" /><p>Codecademy是一个相对较新的网站，其广告语是”最易学的编码方法“。目前，该网站仅有两个课程，”初级编程“和”JavaScript快速入门指南“。沉浸在JavaScript 中是种不错的体验。跟 Try Ruby 练习非常相似，你会学到简短的课程、在浏览器里编码，然后看结果。得到全部分数、打开成就徽章。<p>（Ruby，一种为简单快捷的面向对象编程（面向对象程序设计）而创的脚本语言。）<p>如果你已熟悉了另一种编程语言，你也许可以先学”JavaScript快速入门指南“；如果这是您第一次编程（HTML和CSS除外），你会发现”初级编程“课程相当有用。Codecademy是一家免费网站，但需要注册。<p>任务2：appendTo 截屏方法<p>appendTo 视频有一套特别适合初学者的截屏方法。 如果你想用正确（容易）的方法学习JavaScript，学习这些课程绝对管用。视觉训练总是有效的！<p>”用我们提供的点播内容、务实的训练解决方案来提升自己的技能。无需注册、无需绑定、绝不忽悠。“<p>任务3：阅读一本好的关于JavaScript的说明书<p><img src=\"/content/uploadfile/201302/10fb15c77258a991b0028080a64fb42d20130219101039.png\" alt=\"点击查看原图\" border=\"0\" /><p>一旦你通过Codecademy上的课程来学习，你就会想搞到一本关于JavaScript的详细说明书–介绍所有的类型、运算符、控件架构等等。<p>如果可以的话，我来介绍几个好的说明书：<p>《再说JavaScript》 – 这本说明书可在Mozilla开发者网络上找到，语言公正。这本书内容很丰富，有很多代码实例和文段介绍。<p>《Eloquent JavaScript》 – 该书由Marijn Haverbeke 编写，可免费在线阅读，如果你想弄个硬拷贝可以上亚马逊网站购买。它比MDN说明更详细，因为它不仅涵盖了JavaScript 语言，而且包括编码风格以及在浏览器里使用JavaScript。当然，”eloquent“并非言过其实。（eloquent - 雄辩的、口若悬河的）<p>《Getting Good with JavaScript》 – 没错，这本书是我写的，但是我介绍这本书是另有原因的。它跟我在前面介绍的两本说明不同；在这本书里我只介绍了编程人员快速掌握编程技巧所需要的部分。此外，它还附带超过6个小时的截屏视频，因此，想要就去看看吧。（当然，这本不是免费的。）<p>任务4：安装、学习Firebug（或开发人员工具）<p><img src=\"/content/uploadfile/201302/thum-09dd8c2662b96ce14928333f055c558020130219101040.png\" alt=\"点击查看原图\" border=\"0\" /><p>一旦你开始在浏览器里使用JavaScript，就需要安装Firebug并熟悉它的性能。Firebug是一款用于Firefox的插件，它能帮你创建和调试网页：对网页开发者来说，它就像外科医生的”手术刀“。如果你不用Firefox？喜欢Safari 或者Chrome怎么办？没问题：可以查找类似Firebug的内置开发人员工具。<p>”你可以在Mac地址栏里按选项+命令+I 或者按快捷键Control + Shift + I ，来打开设计工具面板。“<p>通过打开你选的工具，只需在你喜欢的其中一个网站上点击点击，你就会学到很多东西。这里有一些能加速你学习的资源：<p>Firebug<p>Firebug网站和维基百科<p>Firebug的CSS-技巧说明<p>你应该在Nettuts+上使用Firebug的10大理由。<p>Firebug：从白带到黑带，Tuts+ Marketplace 网站（http://marketplace.tutsplus.com/item/firebug-white-to-black-belt/118795）<p>设计工具<p>设计工具网站<p>Google I/O 2011：由Paul Irish重组的浏览器设计工具<p>Google 浏览器设计工具：Paul Irish 的快速开发12技巧<p>任务5：读一本有关JavaScript的书籍<p><img src=\"/content/uploadfile/201302/thum-8266e4bfeda1bd42d8f9794eb4ea0a1320130219101041.png\" alt=\"点击查看原图\" border=\"0\" /><p>现在你已经熟悉了些基础知识，但是还有很多东西要学。尽管我推荐的一些书可能会让你”破产“，但你会发现任何时候我都会推荐4本高质量的书：<p><img src=\"/content/uploadfile/201302/18e2999891374a475d0687ca9f989d8320130219101042.jpg\" alt=\"点击查看原图\" border=\"0\" /><p>前两本是一般的、较深入的JavaScript 资源，它们会让你从简介到较深层次逐步理解；当然，简介里会有一些重叠的说明，但不多：刚好让你看起来很舒服。<p>（注：虽然这些书在亚马逊网站能买到，我已经链接了出版商的网站，因此，你能看看范例章节。）<p>《JavaScript高级程序设计》- Nicolas C. Zakas 编写，这本书涵盖了它能涵盖的所有内容。如果你以前看过Zakas的任何作品，你会发现他是个不折不扣的天才。除了涵盖了JavaScript语言，这本书还能让您在浏览器里很好的使用JavaScript。<p>《JavaScript 24-hour Trainer 》由Jeremy McPeak 编撰，该作者也写过Nettuts+。它不仅仅是一本书：还附带了一张长达四小时的教学光碟。全书共43节课，涉及编码句法指导和代码优化。<p>虽然这些书非常适合编程人员学习JavaScript语言以及如何在浏览器中使用这些语言，但是学无止境。虽然这些书的确进入了一些模式和实练中，我再推荐两本我认为有用的书。<p>1）《JavaScript Patterns 》- Stoyan Stefanov著。我也是刚刚读完这本书，我真希望能尽快读完它。在读过上面的资源之后，你可以学到如何编写JavaScript，但是这本书会教你如何对资源进行重组，这项技能很重要，并非如你想象般简单。<p>2）《JavaScript：The Good Parts 》- Douglas Crockford 著。该书介绍了JavaScript的优缺点。<p>任务6：做些事情！<p>在学习完上述资源后，你应该已经尝试了一些代码样本：修改代码、整合代码看看会怎么样。但是是时候让自己休息一下，做点东西出来了。<p>你能做什么呢？你能做很多东西。这里有一些意见。<p>1） 图片库：显示一套图片缩略图和主图。当用户点击缩略图的时候，要用较大的缩略图（不是原缩略图）替代当前的主图。如果你能覆盖缩略图alt 标记的标题就奖励积分，或是在用户一分钟内未点击的时候进行图片循环。<p>2） 待办列表：听起来有点难，我也不打算推荐你制作一个完整的待办列表。只需要做一个文本框并在其旁放上按钮；点击按钮的时候，已输入的文字会在一个无序列表下面变成一个项目。点击列表项目便可移除。这听起来很容易，但有几个陷阱，对初学者来说仔细想想还是很有好处的。<p>3） 动画框：动画其实是小把戏而已，并不需要弄得太复杂。做一个包含了少许文本的div，其上要有若干按钮。一个按钮用来调整宽度，一个用来调整高度；还有一个用来调整背景颜色。关键是不要让更改发生得太快，但在一秒钟之内。记住，Google 是你的朋友，特别是如果迄今为止你还未用JavaScript 做任何动画的话。<p>我相信你能想到其他的很好的练习的计划。当然，学习的唯一方法是把自己从安乐窝里拽出来。<p>”此外，在所有的技能水平上，确保JavaScript 类别在Nettuts+上有大量教程列表。“<p>（Nettuts是一个专注于提供网络开发教程的网站。）<p>任务7：开始学习如何使用JavaScript库<p><img src=\"/content/uploadfile/201302/thum-9eb9cd58b9ea5e04c890326b5c1f471f20130219101042.png\" alt=\"点击查看原图\" border=\"0\" /><p>如果你学到了这个地步，就会意识到有些JavaScript 编写任务很难（或根本不能）通过跨浏览器的方式实现。最可能违规的便是过量的DOM操作，AJAX和动画。这也就是为什么我们需要JavaScript 库的原因。<p>正如我前面提到的，一个JavaScript 库的详细内容犹如减轻痛苦的蜜糖。因此，现在有必要来看一下。这里有大量库供你选择，我会让你自己决定从哪个开始。无论是jQuery 还是Mootools，YUI 还是Dojo，它们各自的网站会为你提供开始学习时你所需要的一切信息。如果你觉得用得着就来试试吧。<p>最流行的库：<p>虽然很容易得到大量的库，你还是应该选一个受欢迎的– 至少排名第一。<p>jQuery<p>Dojo<p>YUI<p>MooTools<p>Prototype<p>任务8：紧随大师的步伐<p>有很多令人难以置信的JavaScript  天才，他们一直在做些很酷的东西，你一定不想错过。值得庆幸的是，我们的工作狂Siddharth 副主编已经搞到一份33名设计人员列表，要想成为一名JavaScript 发烧友你就必须订阅它。扔下手头的工作，订阅/跟随这些设计人员。这是必须要做的。<p>但是，你还能做更多事情。这个公平网站经常发布关于JavaScript 的信息，所以不要走开。此外，关注JavaScript Show ，一档全世界关于JavaScript最新最大的播客。你可能还想注册JavaScript电子周刊简讯。<p>还想要更多吗？关注Tuts+Marketplace 的JavaScript 类。<p>最后<p>感谢阅读此文！真诚的希望它能帮你成为一名JavaScript 爱好者。如果你已对JavaScript 很熟悉，你可以在评论中推荐其他任何相关资源。<p>本文章来源于：学习JavaScript的最佳方法<p>","description":"学习新的东西是件可怕的事。对我来说，掌握一项新技能最大的问题是，我不知道自己懂什么。鉴于此，定个计划，学习你感兴趣的东西应该会有用。这篇文章的主旨就是：你为学习JavaScript制定的蓝图、路线、行动计划！你不必担心找不到最好的资源，先整理些不好的资源，再确定下一步该学什么。遵循它，一步一步来。","category":"JavaScript","hot":"n"}]